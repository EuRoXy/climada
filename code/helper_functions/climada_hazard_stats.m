function hazard = climada_hazard_stats(hazard,return_periods,check_plot)
% NAME:
%   climada_hazard_stats
% PURPOSE:
%   plot hazard intensity maps for different return periods, based on the
%   probabilistic (and historic) data set. On output, the statistics are available.
%
%   If called with the output hazard on subsequent calls, only the plotting
%   needs to be done (e.g. to further improve plots)
%
%   previous call: e.g. climada_tc_hazard_set
% CALLING SEQUENCE:
%   climada_hazard_stats(hazard,return_periods,check_plot)
% EXAMPLE:
%   hazard=climada_hazard_stats
%   climada_hazard_stats(hazard,[],-1) % show historic events only
% INPUTS:
%   hazard: hazard structure, as generated by e.g. climada_tc_hazard_set
%       > prompted for if not given
% OPTIONAL INPUT PARAMETERS:
%   return_periods: vector containing the requested return periods
%       (default=[1 5 10 25 50 100 500 1000])
%   check_plot: default=1, draw the intensity maps for various return
%       periods for the full hazard set. Set=0 to omit plot
%       =-1: plot the return period maps based on historic events only
% OUTPUTS:
%   the field hazard.map is added to the hazard structure, with
%   map.return_period(rp_i): return period rp_i
%   map.intensity(rp_i,c_i): intensity for return period rp_i at centroid c_i
%   map.intensity_orig: same as map.intensity, only based on historic events
%       if the hazard set contains historic events (some orig_event_flag=1)
% MODIFICATION HISTORY:
% Lea Mueller, muellele@gmail.com, 20110623
% David N. Bresch, david.bresch@gmail.com, 20130317 cleanup
% David N. Bresch, david.bresch@gmail.com, 20140411 fixed some non-TC issues
% David N. Bresch, david.bresch@gmail.com, 20150114, Octave compatibility for -v7.3 mat-files
% Lea Mueller, muellele@gmail.com, 20150607, change tc max int. value to 80 instead of 100m/s
% Lea Mueller, muellele@gmail.com, 20150607, add cross for San Salvador in plot, for San Salvador only
% Lea Mueller, muellele@gmail.com, 20150716, add landslides option (LS) with specific colormap, intensities from 0 to 1
% David N. Bresch, david.bresch@gmail.com, 20160527, complete overhaul, new field hazard.map
% David N. Bresch, david.bresch@gmail.com, 20160529, otherwise in colorscale selection fixed
% David N. Bresch, david.bresch@gmail.com, 20160529, new default return periods (6)
%-

% init global variables
%global climada_global
if ~climada_init_vars, return; end

% poor man's version to check arguments
if ~exist('hazard'        , 'var'), hazard         = []; end
if ~exist('return_periods', 'var'), return_periods = []; end
if ~exist('check_plot'    , 'var'), check_plot     = 1 ; end

% Parameters
%
% density of hazard.map.intensity
mat_dens=0.5; % default 0.5
%
% set default return periods
if isempty(return_periods'),return_periods = [10 25 50 100 500 1000];end


hazard=climada_hazard_load(hazard);

if ~isfield(hazard,'units'),hazard.units='';end

% check if based on probabilistic tc track set
if isfield(hazard,'orig_event_flag')
    orig_event_pos=find(hazard.orig_event_flag);
else
    orig_event_pos=[]; % no original events
end

intensity_threshold = 0; % default
if strcmp(hazard.peril_ID,'TC'),intensity_threshold = 5;end % speeds up calcs

n_return_periods         = length(return_periods);
n_centroids              = size(hazard.intensity,2);

if ~isfield(hazard,'map')
    fprintf('calculate hazard statistics ...\n')
    
    hazard.map.return_period = return_periods;
    
    hazard.map.intensity     = spalloc(n_return_periods,n_centroids,ceil(n_return_periods*n_centroids*mat_dens));
    if ~isempty(orig_event_pos)
        hazard.map.intensity_orig= spalloc(n_return_periods,n_centroids,ceil(n_return_periods*n_centroids*mat_dens));
    end
    
    t0       = clock;
    mod_step = 10; % first time estimate after 10 tracks, then every 100
    msgstr   = sprintf('processing %i centroids',n_centroids);
    fprintf('%s (waitbar suppressed)\n',msgstr);
    format_str='%s';
    
    % % special case for LS
    % if strcmp(hazard.peril_ID,'LS') && isfield(hazard,'cutoff_m')
    %     hazard.intensity = (1-hazard.intensity)*hazard.cutoff_m;
    %     hazard.units = 'm';
    %     fprintf('Hazard for LS transformed to intensity as distance (m) from lanslide.\n')
    % end
    
    inner_loop=1;if ~isempty(orig_event_pos),inner_loop=2;end
    
    for centroid_i = 1:n_centroids
        
        for inner_loop=1:inner_loop
            
            if inner_loop==2 % 2nd time for historic events only
                [intensity_pos,ind_int]  = sort(hazard.intensity(orig_event_pos,centroid_i),'descend');
                frequency2 = hazard.frequency(orig_event_pos)*...
                    length(hazard.orig_event_flag)/length(orig_event_pos); % to convert to full view
            else
                [intensity_pos, ind_int] = sort(hazard.intensity(:,centroid_i),'descend');
                frequency2 = hazard.frequency;
            end
            intensity_pos              = full(intensity_pos);
            below_thresh_pos           = intensity_pos<intensity_threshold;
            intensity_pos(intensity_pos<intensity_threshold) = [];
            frequency2 = frequency2(ind_int); % sort frequency accordingly
            frequency2(below_thresh_pos) = [];
            
            if sum(intensity_pos)>0 % otherwise no intensity above threshold
                freq            = cumsum(frequency2(1:length(intensity_pos)))'; % exceedence frequency
                if length(freq)>1
                    p           = polyfit(log(freq), intensity_pos, 1);
                else
                    p = zeros(2,1);
                end
                exc_freq      = 1./return_periods;
                intensity_fit = polyval(p, log(exc_freq));
                intensity_fit(intensity_fit<=0)    = 0; %nan;
                R                                  = 1./freq;
                neg                                = return_periods >max(R);
                intensity_fit(neg)                 = 0; %nan;
                
                if inner_loop==2 % 2nd time for historic events only
                    hazard.map.intensity_orig(:,centroid_i) = intensity_fit;
                else
                    hazard.map.intensity(:,centroid_i)      = intensity_fit;
                end
            end % sum(intensity_pos)
            
        end % inner_loop
        
        if mod(centroid_i,mod_step)==0 % progress report
            mod_step = 100;
            t_elapsed = etime(clock,t0)/centroid_i;
            n_remaining = n_centroids-centroid_i;
            t_projected_sec = t_elapsed*n_remaining;
            if t_projected_sec<60
                msgstr = sprintf('est. %3.0f sec left (%i/%i centroids)',t_projected_sec, centroid_i, n_centroids);
            else
                msgstr = sprintf('est. %3.1f min left (%i/%i centroids)',t_projected_sec/60, centroid_i, n_centroids);
            end
            fprintf(format_str,msgstr); % write progress to stdout
            format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
        end
        
    end % centroid_i
    
    fprintf(format_str,''); % move carriage to begin of line
    
end % calculation

% FIGURE
% ------
if abs(check_plot)>0
    
    if check_plot<0
        hist_str='historic ';
    else
        hist_str='';
    end
    fprintf('plotting %sintensity vs return periods maps ',hist_str)
    
    fontsize = 12;
    % some color settings
    cmap = climada_colormap(hazard.peril_ID);
    switch hazard.peril_ID
        case 'TC'
            caxis_max = 100;
            %caxis_max = 80;
            xtick_    = caxis_max/5:caxis_max/5:caxis_max;
            %xtick_    = [20 40 60 80 caxis_max];
            cbar_str  = [hist_str 'wind speed (m/s)'];
            
        case 'TR'
            caxis_max = 300; %caxis_max = 500;
            xtick_    = caxis_max/5:caxis_max/5:caxis_max;
            %xtick_    = [10 50 100 200 caxis_max];
            cbar_str  = [hist_str 'rain sum (mm)'];
            
        case 'TS'
            caxis_max = 3;
            xtick_    = caxis_max/5:caxis_max/5:caxis_max;
            %xtick_    = [1 2 4 caxis_max];
            cbar_str  = [hist_str 'surge height (m)'];
            
        case 'MS'
            caxis_max = 3;
            xtick_    = caxis_max/5:caxis_max/5:caxis_max;
            cbar_str  = sprintf('%%s intensity (%s)',hist_str,hazard.peril_ID,hazard.units);
        case 'LS'
            caxis_max = 1;
            xtick_    = caxis_max/5:caxis_max/5:caxis_max;
            cbar_str  = sprintf('%s%s intensity (%s)',hist_str,hazard.peril_ID,hazard.units);
            cmap = flipud(climada_colormap(peril_ID));
        otherwise
            % use default colormap, hence no cmap defined
            caxis_max = full(max(max(hazard.intensity)));
            xtick_    = caxis_max/5:caxis_max/5:caxis_max;
            cbar_str  = sprintf('%s%s intensity (%s)',hist_str,hazard.peril_ID,hazard.units);
    end
    
    scale = max(hazard.lon)-min(hazard.lon);
    centroids.lon=hazard.lon; % to pass on below
    centroids.lat=hazard.lat; % to pass on below
    
    RP_count = length(return_periods);
    if RP_count < 3; y_no = RP_count; else y_no  = 3; end
    x_no         = ceil(RP_count/3);
    
    subaxis(x_no, y_no, 1,'MarginTop',0.15, 'mb',0.05)
    
    % colorbar
    subaxis(2);
    pos = get(subaxis(2),'pos');
    % distance in normalized units from the top of the axes
    dist = .06;
    hc = colorbar('location','northoutside', 'position',[pos(1) pos(2)+pos(4)+dist pos(3) 0.03]);
    set(get(hc,'xlabel'), 'String',cbar_str, 'fontsize',fontsize);
    caxis([0 caxis_max])
    set(gca,'fontsize',fontsize)
    hold on
    
    for rp_i=1:n_return_periods
        
        fprintf('.') % simplest progress indicator
        subaxis(rp_i)
        
        if check_plot>0
            values    = full(hazard.map.intensity(rp_i,:));
        else
            values    = full(hazard.map.intensity_orig(rp_i,:)); % historic
        end
        
        if sum(values(not(isnan(values))))>0 % nansum(values)>0
            [X, Y, gridded_VALUE] = climada_gridded_VALUE(values, centroids);
            gridded_VALUE(gridded_VALUE<(0.1)) = NaN;
            contourf(X, Y, gridded_VALUE,200,'edgecolor','none')
        else
            text(mean([min(hazard.lon) max(hazard.lon)]),...
                mean([min(hazard.lat ) max(hazard.lat )]),...
                'no data for this return period available','fontsize',8,...
                'HorizontalAlignment','center')
        end
        hold on
        climada_plot_world_borders(0.7)
        %title([int2str(hazard.map.return_period(rp_i)) ' yr intensity'],'fontsize',fontsize);
        title([int2str(hazard.map.return_period(rp_i)) ' yr'],'fontsize',fontsize);
        axis([min(hazard.lon)-scale/30  max(hazard.lon)+scale/30 ...
            min(hazard.lat )-scale/30  max(hazard.lat )+scale/30])
        % do not display xticks, nor yticks
        set(subaxis(rp_i),'xtick',[],'ytick',[],'DataAspectRatio',[1 1 1])
        caxis([0 caxis_max])
        if ~exist('cmap','var'), cmap = '';end
        if ~isempty(cmap), colormap(cmap);end
        set(gca,'fontsize',fontsize)
        set(hc,'XTick',xtick_)
        
    end % rp_i
    
    set(gcf,'Position',[427 29 574 644]);
    drawnow
    fprintf(' done\n')
    
end % check_plot

end % climada_hazard_stats