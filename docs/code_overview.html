<body>
<H1><FONT COLOR="FF0000">Overview of climada routines</FONT></FONT></H1>
<P>
Use <i>Find in page</i> ... from the Edit Menu to search for any text in all help-files.<P>
Use the <i>which</i> command in MATLAB to locate the specific function.<P>
This page has been automatically created by <i>compile_function_header_doc</i>.<P>
Please consult <A HREF="climada_manual.pdf">climada_manual.pdf</A> for more information.<P>
<P>
<P><STRONG>Last modified: </STRONG>09-Jun-2016 08:29:29<P>

<HR>

<A NAME="ROUTINELIST">
<UL>
<LI><A HREF="#climada">climada</A>
<LI><A HREF="#climada_EDS_calc">climada_EDS_calc</A>
<LI><A HREF="#climada_adaptation_bar_chart">climada_adaptation_bar_chart</A>
<LI><A HREF="#climada_adaptation_cost_curve">climada_adaptation_cost_curve</A>
<LI><A HREF="#climada_adaptation_event_view">climada_adaptation_event_view</A>
<LI><A HREF="#climada_demo">climada_demo</A>
<LI><A HREF="#climada_demo_gui">climada_demo_gui</A>
<LI><A HREF="#climada_demo_step_by_step">climada_demo_step_by_step</A>
<LI><A HREF="#climada_entity_plot">climada_entity_plot</A>
<LI><A HREF="#climada_entity_read">climada_entity_read</A>
<LI><A HREF="#climada_init_vars">climada_init_vars</A>
<LI><A HREF="#climada_measures_impact">climada_measures_impact</A>
<LI><A HREF="#climada_measures_impact_parametric">climada_measures_impact_parametric</A>
<LI><A HREF="#climada_tc_event_damage_ens">climada_tc_event_damage_ens</A>
<LI><A HREF="#climada_tc_event_damage_ens_gui">climada_tc_event_damage_ens_gui</A>
<LI><A HREF="#climada_tc_hazard_set">climada_tc_hazard_set</A>
<LI><A HREF="#climada_tc_hazard_set_exercise">climada_tc_hazard_set_exercise</A>
<LI><A HREF="#climada_tc_random_walk">climada_tc_random_walk</A>
<LI><A HREF="#climada_tc_read_unisys_database">climada_tc_read_unisys_database</A>
<LI><A HREF="#climada_tc_windfield">climada_tc_windfield</A>
<LI><A HREF="#climada_tc_windfield_exercise">climada_tc_windfield_exercise</A>
<LI><A HREF="#climada_viewer">climada_viewer</A>
<LI><A HREF="#climada_waterfall_graph">climada_waterfall_graph</A>
<LI><A HREF="#git_pull">git_pull</A>
<LI><A HREF="#cam_USA_hazard_check">cam_USA_hazard_check</A>
<LI><A HREF="#cam_batch">cam_batch</A>
<LI><A HREF="#cam_batch2">cam_batch2</A>
<LI><A HREF="#cam_batch_multi">cam_batch_multi</A>
<LI><A HREF="#cam_calibrate">cam_calibrate</A>
<LI><A HREF="#cam_entity_value_GDP_SSP">cam_entity_value_GDP_SSP</A>
<LI><A HREF="#cam_entity_value_GDP_SSP_one">cam_entity_value_GDP_SSP_one</A>
<LI><A HREF="#climada_tc_analyze_cam">climada_tc_analyze_cam</A>
<LI><A HREF="#climada_tc_analyze_cam_all">climada_tc_analyze_cam_all</A>
<LI><A HREF="#climada_tc_filter_basin">climada_tc_filter_basin</A>
<LI><A HREF="#climada_tc_read_cam_IBTrAC_V01">climada_tc_read_cam_IBTrAC_V01</A>
<LI><A HREF="#climada_tc_read_cam_database">climada_tc_read_cam_database</A>
<LI><A HREF="#climada_tc_read_cam_database_V01">climada_tc_read_cam_database_V01</A>
<LI><A HREF="#climada_tc_read_cam_database_V02">climada_tc_read_cam_database_V02</A>
<LI><A HREF="#climada_tc_read_cam_ibtrac_v02">climada_tc_read_cam_ibtrac_v02</A>
<LI><A HREF="#selected_countries_CAM">selected_countries_CAM</A>
<LI><A HREF="#climada_EASI_write">climada_EASI_write</A>
<LI><A HREF="#winterstorm_EASI_compare">winterstorm_EASI_compare</A>
<LI><A HREF="#Barbados_test">Barbados_test</A>
<LI><A HREF="#Fiji_Samoa_Tonga_Vanuatu_EQ">Fiji_Samoa_Tonga_Vanuatu_EQ</A>
<LI><A HREF="#MSP_PLS_read">MSP_PLS_read</A>
<LI><A HREF="#PHL_comparison">PHL_comparison</A>
<LI><A HREF="#SnP_all_in_one">SnP_all_in_one</A>
<LI><A HREF="#TEST_waterfall">TEST_waterfall</A>
<LI><A HREF="#TUV_animation">TUV_animation</A>
<LI><A HREF="#USA_TC_hist_checks">USA_TC_hist_checks</A>
<LI><A HREF="#climada_PLS_read">climada_PLS_read</A>
<LI><A HREF="#climada_event_damage_animation3">climada_event_damage_animation3</A>
<LI><A HREF="#climada_tc_equal_timestep_OLD">climada_tc_equal_timestep_OLD</A>
<LI><A HREF="#climada_topotool">climada_topotool</A>
<LI><A HREF="#cr_EDS_adjust">cr_EDS_adjust</A>
<LI><A HREF="#cr_EDS_adjust_all">cr_EDS_adjust_all</A>
<LI><A HREF="#cr_region_peril_TEST">cr_region_peril_TEST</A>
<LI><A HREF="#global_max_damage">global_max_damage</A>
<LI><A HREF="#hazards_2digit_perilID">hazards_2digit_perilID</A>
<LI><A HREF="#hazards_filename_consistency">hazards_filename_consistency</A>
<LI><A HREF="#inspect_VULN">inspect_VULN</A>
<LI><A HREF="#move_hazards">move_hazards</A>
<LI><A HREF="#ncread_TEST">ncread_TEST</A>
<LI><A HREF="#selected_countries_all_in_one_SPECIAL">selected_countries_all_in_one_SPECIAL</A>
<LI><A HREF="#selected_countries_region_peril">selected_countries_region_peril</A>
<LI><A HREF="#sparse_TEST">sparse_TEST</A>
<LI><A HREF="#toggle_SP">toggle_SP</A>
<LI><A HREF="#usgs_warnig_map_retrieve">usgs_warnig_map_retrieve</A>
<LI><A HREF="#slv_explorer">slv_explorer</A>
<LI><A HREF="#BATCH_exercise">BATCH_exercise</A>
<LI><A HREF="#climada_naturalearthdata_add">climada_naturalearthdata_add</A>
<LI><A HREF="#climada_naturalearthdata_plot">climada_naturalearthdata_plot</A>
<LI><A HREF="#climada_shp_explorer">climada_shp_explorer</A>
<LI><A HREF="#climada_assets_crop">climada_assets_crop</A>
<LI><A HREF="#climada_centroids_elevation_add">climada_centroids_elevation_add</A>
<LI><A HREF="#climada_centroids_generate">climada_centroids_generate</A>
<LI><A HREF="#climada_circle_create">climada_circle_create</A>
<LI><A HREF="#climada_entity_crop">climada_entity_crop</A>
<LI><A HREF="#climada_exceedence_freq2freq">climada_exceedence_freq2freq</A>
<LI><A HREF="#climada_hazard2xls">climada_hazard2xls</A>
<LI><A HREF="#climada_hazard_crop">climada_hazard_crop</A>
<LI><A HREF="#climada_hazard_init">climada_hazard_init</A>
<LI><A HREF="#climada_measures_construct">climada_measures_construct</A>
<LI><A HREF="#climada_measures_impact_add">climada_measures_impact_add</A>
<LI><A HREF="#barisal_ED_find_most_vulnerable">barisal_ED_find_most_vulnerable</A>
<LI><A HREF="#barisal_MI_per_peril">barisal_MI_per_peril</A>
<LI><A HREF="#barisal_adaptation_bar_chart">barisal_adaptation_bar_chart</A>
<LI><A HREF="#barisal_adaptation_cost_curve">barisal_adaptation_cost_curve</A>
<LI><A HREF="#barisal_entity_pre_process">barisal_entity_pre_process</A>
<LI><A HREF="#barisal_entity_pre_process_income">barisal_entity_pre_process_income</A>
<LI><A HREF="#barisal_get_EDS">barisal_get_EDS</A>
<LI><A HREF="#barisal_get_entity">barisal_get_entity</A>
<LI><A HREF="#barisal_get_hazard">barisal_get_hazard</A>
<LI><A HREF="#barisal_measure_zones">barisal_measure_zones</A>
<LI><A HREF="#barisal_plot_adaptation_cost_curve">barisal_plot_adaptation_cost_curve</A>
<LI><A HREF="#barisal_risk_calculations">barisal_risk_calculations</A>
<LI><A HREF="#barisal_tc_hazard_prob">barisal_tc_hazard_prob</A>
<LI><A HREF="#climada_EDS_ED_at_centroid_report_xls">climada_EDS_ED_at_centroid_report_xls</A>
<LI><A HREF="#climada_EDS_multi_calc">climada_EDS_multi_calc</A>
<LI><A HREF="#climada_ED_plot_per_point">climada_ED_plot_per_point</A>
<LI><A HREF="#climada_MI_plot">climada_MI_plot</A>
<LI><A HREF="#climada_measures_impact_advanced">climada_measures_impact_advanced</A>
<LI><A HREF="#climada_waterfall_graph_multi_peril">climada_waterfall_graph_multi_peril</A>
<LI><A HREF="#GeoDistance">GeoDistance</A>
<LI><A HREF="#TEST_sea_level_components_MEX">TEST_sea_level_components_MEX</A>
<LI><A HREF="#TEST_surge_module_MEX">TEST_surge_module_MEX</A>
<LI><A HREF="#TEST_surge_module_MEX_WithStationarySims">TEST_surge_module_MEX_WithStationarySims</A>
<LI><A HREF="#TEST_wave_climate_MEX">TEST_wave_climate_MEX</A>
<LI><A HREF="#aux_historical_storms_MEX">aux_historical_storms_MEX</A>
<LI><A HREF="#class_plot_profiles">class_plot_profiles</A>
<LI><A HREF="#climada_calculate_ACE">climada_calculate_ACE</A>
<LI><A HREF="#climada_calculate_LTtrend">climada_calculate_LTtrend</A>
<LI><A HREF="#climada_compare_windfields">climada_compare_windfields</A>
<LI><A HREF="#climada_getTemporalSerie_AT">climada_getTemporalSerie_AT</A>
<LI><A HREF="#climada_get_GlobalWaveClimate">climada_get_GlobalWaveClimate</A>
<LI><A HREF="#climada_get_LandSubsidence">climada_get_LandSubsidence</A>
<LI><A HREF="#climada_get_SLRProjection">climada_get_SLRProjection</A>
<LI><A HREF="#climada_get_SLRhistorical">climada_get_SLRhistorical</A>
<LI><A HREF="#climada_init_vars_coastal">climada_init_vars_coastal</A>
<LI><A HREF="#climada_tc_ACE_set">climada_tc_ACE_set</A>
<LI><A HREF="#climada_tc_hazard_surge">climada_tc_hazard_surge</A>
<LI><A HREF="#climada_tc_hazard_surge_CENAPRED">climada_tc_hazard_surge_CENAPRED</A>
<LI><A HREF="#climada_tc_hazard_surge_CENAPRED_field">climada_tc_hazard_surge_CENAPRED_field</A>
<LI><A HREF="#climada_tc_hazard_surge_DD92_mslope">climada_tc_hazard_surge_DD92_mslope</A>
<LI><A HREF="#climada_tc_hazard_surge_SLOSH">climada_tc_hazard_surge_SLOSH</A>
<LI><A HREF="#climada_tc_surgefield_barotropic">climada_tc_surgefield_barotropic</A>
<LI><A HREF="#climada_tc_tracks_clim_scen">climada_tc_tracks_clim_scen</A>
<LI><A HREF="#climada_tc_wavefield">climada_tc_wavefield</A>
<LI><A HREF="#climada_tc_windfield_ACE">climada_tc_windfield_ACE</A>
<LI><A HREF="#climada_tc_windfield_HURAC">climada_tc_windfield_HURAC</A>
<LI><A HREF="#create_bathymetry">create_bathymetry</A>
<LI><A HREF="#deg2utm">deg2utm</A>
<LI><A HREF="#disk_kernel">disk_kernel</A>
<LI><A HREF="#filter2">filter2</A>
<LI><A HREF="#fun_SurgeHeightFun">fun_SurgeHeightFun</A>
<LI><A HREF="#fun_calculate_mean_slope">fun_calculate_mean_slope</A>
<LI><A HREF="#fun_clean_track">fun_clean_track</A>
<LI><A HREF="#fun_writeshp_contour_lines">fun_writeshp_contour_lines</A>
<LI><A HREF="#getcontourlines">getcontourlines</A>
<LI><A HREF="#harmonics">harmonics</A>
<LI><A HREF="#pol2cart">pol2cart</A>
<LI><A HREF="#save_fig">save_fig</A>
<LI><A HREF="#tlabel">tlabel</A>
<LI><A HREF="#wave_climate_MEX_TEST">wave_climate_MEX_TEST</A>
<LI><A HREF="#centroids_generate_hazard_sets">centroids_generate_hazard_sets</A>
<LI><A HREF="#climada_create_GDP_entity">climada_create_GDP_entity</A>
<LI><A HREF="#climada_entity_GDP">climada_entity_GDP</A>
<LI><A HREF="#climada_hybrid_entity">climada_hybrid_entity</A>
<LI><A HREF="#climada_night_light_to_country">climada_night_light_to_country</A>
<LI><A HREF="#climada_nightlight_entity">climada_nightlight_entity</A>
<LI><A HREF="#climada_plot_entity_assets">climada_plot_entity_assets</A>
<LI><A HREF="#country_admin1_risk_calc">country_admin1_risk_calc</A>
<LI><A HREF="#country_risk_calc">country_risk_calc</A>
<LI><A HREF="#country_risk_calibrate">country_risk_calibrate</A>
<LI><A HREF="#country_risk_report">country_risk_report</A>
<LI><A HREF="#country_risk_report_raw">country_risk_report_raw</A>
<LI><A HREF="#country_risk_waterfall">country_risk_waterfall</A>
<LI><A HREF="#emdat_read">emdat_read</A>
<LI><A HREF="#selected_countries_all_in_one">selected_countries_all_in_one</A>
<LI><A HREF="#bf_TEST">bf_TEST</A>
<LI><A HREF="#bf_generator">bf_generator</A>
<LI><A HREF="#bf_generator2">bf_generator2</A>
<LI><A HREF="#bf_generator_large">bf_generator_large</A>
<LI><A HREF="#climada_bf_hazard_set">climada_bf_hazard_set</A>
<LI><A HREF="#firms_read">firms_read</A>
<LI><A HREF="#MMI_attenuation_calc">MMI_attenuation_calc</A>
<LI><A HREF="#climada_get_single_event">climada_get_single_event</A>
<LI><A HREF="#eq_centennial_read">eq_centennial_read</A>
<LI><A HREF="#eq_global_attenuation">eq_global_attenuation</A>
<LI><A HREF="#eq_global_attenuation_TEST">eq_global_attenuation_TEST</A>
<LI><A HREF="#eq_global_hazard_set">eq_global_hazard_set</A>
<LI><A HREF="#eq_global_hazard_set_slow">eq_global_hazard_set_slow</A>
<LI><A HREF="#eq_global_probabilistic">eq_global_probabilistic</A>
<LI><A HREF="#eq_isc_gem_read">eq_isc_gem_read</A>
<LI><A HREF="#eq_signigeq_read">eq_signigeq_read</A>
<LI><A HREF="#plot_attenuation_parameters">plot_attenuation_parameters</A>
<LI><A HREF="#plot_gutenberg_richter">plot_gutenberg_richter</A>
<LI><A HREF="#validate_eq_damage">validate_eq_damage</A>
<LI><A HREF="#vq_global_hazard_set">vq_global_hazard_set</A>
<LI><A HREF="#vq_global_probabilistic">vq_global_probabilistic</A>
<LI><A HREF="#vq_tephra_field_cm">vq_tephra_field_cm</A>
<LI><A HREF="#vq_volcano_list_read">vq_volcano_list_read</A>
<LI><A HREF="#climada_srtm_entity">climada_srtm_entity</A>
<LI><A HREF="#climada_srtm_get">climada_srtm_get</A>
<LI><A HREF="#etopo_elevation_m">etopo_elevation_m</A>
<LI><A HREF="#etopo_get">etopo_get</A>
<LI><A HREF="#climada_hazard_encode_distance">climada_hazard_encode_distance</A>
<LI><A HREF="#climada_ls_hazard_binary_plot">climada_ls_hazard_binary_plot</A>
<LI><A HREF="#climada_ls_hazard_set">climada_ls_hazard_set</A>
<LI><A HREF="#climada_ls_hazard_set_binary">climada_ls_hazard_set_binary</A>
<LI><A HREF="#DEM_rainfall">DEM_rainfall</A>
<LI><A HREF="#climada_90m_DEM">climada_90m_DEM</A>
<LI><A HREF="#climada_fl_encode">climada_fl_encode</A>
<LI><A HREF="#climada_fl_onland">climada_fl_onland</A>
<LI><A HREF="#climada_flood_module">climada_flood_module</A>
<LI><A HREF="#climada_flood_plot">climada_flood_plot</A>
<LI><A HREF="#climada_grid2array">climada_grid2array</A>
<LI><A HREF="#climada_hazard_encode_distance">climada_hazard_encode_distance</A>
<LI><A HREF="#climada_ls_hazard_binary_plot">climada_ls_hazard_binary_plot</A>
<LI><A HREF="#climada_ls_hazard_set">climada_ls_hazard_set</A>
<LI><A HREF="#climada_ls_hazard_set_binary">climada_ls_hazard_set_binary</A>
<LI><A HREF="#climada_read_srtm_DEM">climada_read_srtm_DEM</A>
<LI><A HREF="#discharge_relation">discharge_relation</A>
<LI><A HREF="#flood_calibrate">flood_calibrate</A>
<LI><A HREF="#flood_hazard_create">flood_hazard_create</A>
<LI><A HREF="#flood_hazard_create_single">flood_hazard_create_single</A>
<LI><A HREF="#flood_innund_estim">flood_innund_estim</A>
<LI><A HREF="#flood_remote_centroids_clean">flood_remote_centroids_clean</A>
<LI><A HREF="#flood_shape_write">flood_shape_write</A>
<LI><A HREF="#rain_statistics">rain_statistics</A>
<LI><A HREF="#rating_curve">rating_curve</A>
<LI><A HREF="#stream_elevation_correct">stream_elevation_correct</A>
<LI><A HREF="#streamord">streamord</A>
<LI><A HREF="#streamorder2swathobj">streamorder2swathobj</A>
<LI><A HREF="#README">README</A>
<LI><A HREF="#climada_meteorite_hazard_set">climada_meteorite_hazard_set</A>
<LI><A HREF="#climada_measure_viewer">climada_measure_viewer</A>
<LI><A HREF="#climada_value_sum">climada_value_sum</A>
<LI><A HREF="#salvador_LS_screw">salvador_LS_screw</A>
<LI><A HREF="#salvador_TC_screw">salvador_TC_screw</A>
<LI><A HREF="#salvador_calc_measures">salvador_calc_measures</A>
<LI><A HREF="#salvador_calc_waterfall">salvador_calc_waterfall</A>
<LI><A HREF="#salvador_entity_files_set">salvador_entity_files_set</A>
<LI><A HREF="#salvador_entity_future_create">salvador_entity_future_create</A>
<LI><A HREF="#salvador_hazard_future_save">salvador_hazard_future_save</A>
<LI><A HREF="#salvador_resolution_test_LS">salvador_resolution_test_LS</A>
<LI><A HREF="#salvador_resolution_test_TC">salvador_resolution_test_TC</A>
<LI><A HREF="#WS_intensity_correction">WS_intensity_correction</A>
<LI><A HREF="#winterstorm_TEST">winterstorm_TEST</A>
<LI><A HREF="#winterstorm_blend_hazard_event_sets">winterstorm_blend_hazard_event_sets</A>
<LI><A HREF="#winterstorm_compare">winterstorm_compare</A>
<LI><A HREF="#winterstorm_compare_severity">winterstorm_compare_severity</A>
<LI><A HREF="#winterstorm_scenario_hazard">winterstorm_scenario_hazard</A>
<LI><A HREF="#winterstorm_severity">winterstorm_severity</A>
<LI><A HREF="#_climada_nonspheric_distance_m">_climada_nonspheric_distance_m</A>
<LI><A HREF="#climada_EDS_scaleup_factor">climada_EDS_scaleup_factor</A>
<LI><A HREF="#climada_RCLIPER">climada_RCLIPER</A>
<LI><A HREF="#climada_admin_name">climada_admin_name</A>
<LI><A HREF="#climada_centroids_distance_to_coast">climada_centroids_distance_to_coast</A>
<LI><A HREF="#climada_centroids_hazard_expand">climada_centroids_hazard_expand</A>
<LI><A HREF="#climada_coastline_read">climada_coastline_read</A>
<LI><A HREF="#climada_event_damage_animation_ge">climada_event_damage_animation_ge</A>
<LI><A HREF="#climada_hazard_clim_scen_IPCC">climada_hazard_clim_scen_IPCC</A>
<LI><A HREF="#climada_hazard_clim_scen_advanced">climada_hazard_clim_scen_advanced</A>
<LI><A HREF="#climada_hazard_climate_screw">climada_hazard_climate_screw</A>
<LI><A HREF="#climada_hazard_distance_to_coast">climada_hazard_distance_to_coast</A>
<LI><A HREF="#climada_hazard_distance_to_coast_USA">climada_hazard_distance_to_coast_USA</A>
<LI><A HREF="#climada_hazard_distance_to_coast_australia">climada_hazard_distance_to_coast_australia</A>
<LI><A HREF="#climada_hazard_distance_to_coast_china">climada_hazard_distance_to_coast_china</A>
<LI><A HREF="#climada_hazard_distance_to_coast_japan">climada_hazard_distance_to_coast_japan</A>
<LI><A HREF="#climada_hazard_extract_event">climada_hazard_extract_event</A>
<LI><A HREF="#climada_hazard_footprint_plot">climada_hazard_footprint_plot</A>
<LI><A HREF="#climada_hazard_merge">climada_hazard_merge</A>
<LI><A HREF="#climada_plot_loss_hist">climada_plot_loss_hist</A>
<LI><A HREF="#climada_plot_lossfootprint">climada_plot_lossfootprint</A>
<LI><A HREF="#climada_plot_probabilistic_wind_speed_decay">climada_plot_probabilistic_wind_speed_decay</A>
<LI><A HREF="#climada_plot_probabilistic_wind_speed_map_gui">climada_plot_probabilistic_wind_speed_map_gui</A>
<LI><A HREF="#climada_scale_to_MSP_to_market">climada_scale_to_MSP_to_market</A>
<LI><A HREF="#climada_tc_hazard_set_slow">climada_tc_hazard_set_slow</A>
<LI><A HREF="#climada_tc_on_land">climada_tc_on_land</A>
<LI><A HREF="#climada_tc_track_google_earth">climada_tc_track_google_earth</A>
<LI><A HREF="#climada_tc_track_wind_decay">climada_tc_track_wind_decay</A>
<LI><A HREF="#climada_tc_track_wind_decay_calculate">climada_tc_track_wind_decay_calculate</A>
<LI><A HREF="#climada_tc_track_windfield_google_earth">climada_tc_track_windfield_google_earth</A>
<LI><A HREF="#climada_tc_wind_decay">climada_tc_wind_decay</A>
<LI><A HREF="#climada_tc_windfield_slow">climada_tc_windfield_slow</A>
<LI><A HREF="#climada_tr_hazard_set">climada_tr_hazard_set</A>
<LI><A HREF="#climada_tr_hazard_set_slow">climada_tr_hazard_set_slow</A>
<LI><A HREF="#climada_tr_rainfield">climada_tr_rainfield</A>
<LI><A HREF="#climada_tr_rainfield_slow">climada_tr_rainfield_slow</A>
<LI><A HREF="#climada_tr_rainrate_field_animation">climada_tr_rainrate_field_animation</A>
<LI><A HREF="#climada_tr_rainsum_field_animation">climada_tr_rainsum_field_animation</A>
<LI><A HREF="#climada_track_map">climada_track_map</A>
<LI><A HREF="#climada_ts_hazard_set">climada_ts_hazard_set</A>
<LI><A HREF="#figures_for_hazard_advanced_manual">figures_for_hazard_advanced_manual</A>
<LI><A HREF="#haversine">haversine</A>
<LI><A HREF="#tc_surge_TEST">tc_surge_TEST</A>
<LI><A HREF="#tc_surge_TEST_Netherlands">tc_surge_TEST_Netherlands</A>
<LI><A HREF="#tc_surge_plot_3d">tc_surge_plot_3d</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<PRE>


<A NAME="climada">
<H2>climada</H2></A>
<font color="blue">function measures_impact=climada(entity_today_file,entity_future_file,hazard_today_file,hazard_future_file,check_plots) </font>
 climada all in one adaptaton cost curve climate scenarios economic grwoth projection
 MODULE:
   core
 NAME:
   climada
 PURPOSE:
   Import entity today and entity future, ask for corresponding hazard
   event sets, show a few plots for checks, run all calculations and
   produce the final adaptation cost curve - all in one call.

   Special: on subsequent calls, the routine suggest last inputs - and if
   the first file selection is the same as on previous call, even asks to
   re-run with previous call's inputs without asking for each's
   confirmation.
   It further checks for the entity file to have been edited since last
   call. If not, it does not ask for plotting assets and damagefunctions
   again. If one wants to plot, needs to either save the entity again or
   select another file and then cancel.

   Programmes's note: The present code mainly handles asdmin, i.e.
   checking files, while all calculations are run be the core climada
   functions, i.e. climada_entity_read, climada_measures_impact, 
   climada_adaptation_event_view and - last but not least -
   climada_adaptation_cost_curve. 
 CALLING SEQUENCE:
   measures_impact=climada(entity,entitiy_future,hazard_today_file,hazard_future_file)
 EXAMPLE:
   measures_impact=climada % all prompted for
   measures_impact=climada('TEST_CLIMADA'); % TEST mode
 INPUTS:
   entity_today_file: entity (assets, damagefunctions and measures) today
       a climada entity file, either an Excel (.xls or .xlsx) or Open
       Office (.ods file) or an already encoded .mat file. Note that in
       case a .mat file is provided, the code does not notice if the
       original .xls or .ods got changed - hence preferable select the
       source, i.e. .xls or .ods).   
       &ampgt prompted for if empty
       ='TEST_CLIMADA': special test mode, the code uses the test files
       (as used in climada_demo and climada_demo_step_by_step)
   entity_future_file: future entity (assets, damagefunctions and measures) to
       represent projected economic growth, a climada entity structure
       (see climada_entity_read, same remark as above)
       &ampgt prompted for if empty
   hazard_today_file: a climada hazard event set for today
       &ampgt promted for if not given
   hazard_future_file: a climada hazard event set for future (climate scenario)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   check_plots: whether we show a few check plots (assets,
       damagefunctions)
       =0: no plots (default)
       =1: show plots
       The code also switches to ask for plot if it needs to prompt
       for filenames, i.e. operates in interactive mode.
 OUTPUTS:
   measures_impact: the same output as climada_measures_impact
   and plots: adaptation cost curve, adaptation event view
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150101, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_calc">
<H2>climada_EDS_calc</H2></A>
<font color="blue">function EDS=climada_EDS_calc(entity,hazard,annotation_name,force_re_encode,silent_mode,sanity_check) </font>
 climada calculate event damage set
 NAME:
   climada_EDS_calc
 PURPOSE:
   given an encoded entity (assets and damage functions) and a hazard
   event set, calculate the event damage set (EDS). The event damage set
   contains the event damage for each hazard event. In case you set
   climada_global.EDS_at_centroid=1, the damage is also stored for each
   event at each centroids (be aware of memory implications). The exepcted
   damage is always stored at each centroid, see EDS.ED_at_centroid.

   Note that the waitbar consumes quite some time, so switch it off by
   setting climada_global.waitbar=0 or by
   using the climada_code_optimizer, which removes all slowing code, i.e.
   all code lines marked by % CLIMADA_OPT - but by now, the code is pretty
   fast, hence climada_code_optimizer does usually not bring huge
   improvements (i.e. less than 4% speedup).

   Search for 'TEST output' in code to show output for VERY SMALL entities

   next (likely): climada_EDS_DFC or climada_EDS2DFC, climada_EDS_DFC_report
   See also climada_EDS_calc_parfor for a parallelized version (beta)
 CALLING SEQUENCE:
   EDS=climada_EDS_calc(entity,hazard,annotation_name)
 EXAMPLE:
   EDS=climada_EDS_calc(climada_assets_encode(climada_assets_read))
   EDS=climada_EDS_calc('demo_today','TCNA_today_small')
 INPUTS:
   entity: an entity structure or an entity .mat file, see climada_assets_encode(climada_assets_read)
       If a file and no path provided, default path ../data/entities is
       used (and name can be without extension .mat)
       &ampgt promted for if not given
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       If a file and no path provided, default path ../data/hazards is
       used (and name can be without extension .mat)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   annotation_name: a free text that will appear e.g. on plots for
       annotation, default is the name of the hazard set
   force_re_encode: if =1, force re-encoding (either to be on the safe
       side, or if the entity has been encoded t a different hazard event
       set). Default=0
   silent_mode: suppress any output to stdout (useful i.e. if called many times)
       defult=0 (output to stdout), =1: no output and no waitbar at all
       But even with silent_mode=1, the one line progress output is shown
 OUTPUTS:
   EDS, the event damage set with:
       ED: the total expected annual damage (=EDS.damage*EDS.frequency')
       reference_year: the year the damages are references to
       event_ID(event_i): the unique ID for each event_i
       damage(event_i): the damage amount for event_i (summed up over all
           assets)
       ED_at_centroid(centroid_i): expected damage at each centroid
       Value: the sum of all Values used in the calculation (to e.g.
           express damages in percentage of total Value)
       frequency(event_i): the per occurrence event frequency for each event_i
       orig_event_flag(event_i): whether an original event (=1) or a
           probabilistic one (=0)
       comment: a free comment, contains time for calculation
       hazard: itself a structure, with:
           filename: the filename of the hazard event set
           comment: a free comment
       assets.lat(asset_i): the latitude of each asset_i
       assets.lon(asset_i): the longitude of each asset_i
       assets.Value(asset_i): the Value of asset_i, i.e. used to show
           ED_at_centroid in percentage of asset value.
       assets.filename: the filename of the assets
       assets.admin0_name: the admin0_name of the assets (optional)
       assets.admin0_ISO3: the admin0_ISO3 code of the assets (optional)
       assets.admin1_name: the admin1_name of the assets (optional)
       assets.admin1_code: the admin1_code of the assets (optional)
       damagefunctions.filename: the filename of the damagefunctions
       annotation_name: a kind of default title (sometimes empty)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
 David N. Bresch, david.bresch@gmail.com, 20130623, re-encoding optional
 David N. Bresch, david.bresch@gmail.com, 20141025, peril_ID added to waitbar title
 David N. Bresch, david.bresch@gmail.com, 20141103, entity.damagefunctions.peril_ID
 David N. Bresch, david.bresch@gmail.com, 20141127, force_re_encode
 David N. Bresch, david.bresch@gmail.com, 20141218, Cover checks added
 David N. Bresch, david.bresch@gmail.com, 20141230, only assets.Value&ampgt0 prcocessed for speedup
 David N. Bresch, david.bresch@gmail.com, 20150101, annotation check for 'MAC' and 'APPLE'
 David N. Bresch, david.bresch@gmail.com, 20150103, check Octave compatibility of (large) hazard event sets
 David N. Bresch, david.bresch@gmail.com, 20150105, filesep conversion (from either PC or MAC) solved
 David N. Bresch, david.bresch@gmail.com, 20150106, add Cover and/or Deductible if missing
 David N. Bresch, david.bresch@gmail.com, 20150106, Octave issue with hazard saved as -v7.3 solved
 David N. Bresch, david.bresch@gmail.com, 20150114, EDS.peril_ID (was EDS.hazard.peril_ID)
 David N. Bresch, david.bresch@gmail.com, 20150320, spfun replaced with explicit call, turns out to be &ampgt50% faster. Further speedup, see loop_mod_step
 Gilles Stassen, gillesstassen@hotmail.com, 20150622, use complete peril_ID in asset_damfun_pos refinement (1:2) -&ampgt (:), MDD, PAA  explicitly capped at max value
 David N. Bresch, david.bresch@gmail.com, 20150804, allow for filename without path for entoity and hazard set name on input
 Lea Mueller, muellele@gmail.com, 20150805, allow centroid_index to be zero, do not integrate such assets in valid_asset_pos, no damage will be calculated
 Lea Mueller, muellele@gmail.com, 20150819, use only unique values in interp_x_table, so that interp1 works (interp_x_table is monotonically increasing)
 Lea Mueller, muellele@gmail.com, 20150819, set minimum damage to min defined in damage function (probably 0)
 Lea Mueller, muellele@gmail.com, 20150831, EDS.ED, EDS.damage, EDS.Value is the sum only of the first Value_unit encountered, all other units are not included
 David N. Bresch, david.bresch@gmail.com, 20150907, ...errant extrapolation leads to WRONG behaviour in case of hazard_intensity_impact_b, commented
 Lea Mueller, muellele@gmail.com, 20150907, add sanity_check variable to call climada_damagefunctions_check
 Lea Mueller, muellele@gmail.com, 20150910, set sanity_check to silent_mode
 Lea Mueller, muellele@gmail.com, 20151117, replace output string to &quotCalculating damage&quot instead of &quotprocessing&quot
 Lea Mueller, muellele@gmail.com, 20151127, add EDS.scenario, EDS.assets.reference_year and EDS.assets.region, add EDS.hazard.refence_year and EDS.hazard.scenario
 Lea Mueller, muellele@gmail.com, 20151127, add EDS.assets.Category
 Lea Mueller, muellele@gmail.com, 20151127, invoke climada_assets_category_ID, add EDS.assets.Category_name and EDS.assets.Category_ID
 David N. Bresch, david.bresch@gmail.com, 20160202, cleanup
 David N. Bresch, david.bresch@gmail.com, 20160210, is_unit removed and substantial speedup (damagefunctions made unique before calc)
 Lea Mueller, muellele@gmail.com, 20160303, bugfix if EDS_at_centroid and state ED in fprintf command line output
 David N. Bresch, david.bresch@gmail.com, 20160306, EDS.ED=EDS.damage*EDS.frequency'
 David N. Bresch, david.bresch@gmail.com, 20160308, no printing of ED to stdout, some silent_mode checks slow down too much, removed
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_EDS_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_bar_chart">
<H2>climada_adaptation_bar_chart</H2></A>
<font color="blue">function fig = climada_adaptation_bar_chart(measures_impact,sort_measures,scale_benefit,benefit_str,legend_location,tcr_off,cost_unit,xlim_value) </font>
 climada measures impact climate adaptation bar chart
 NAME:
   climada_adaptation_bar_chart_v2
 PURPOSE:
   plot adaptation bar chart (NPV benefits and costs)
   see also: climada_adaptation_cost_curve

 CALLING SEQUENCE:
   climada_adaptation_bar_chart_v2(measures_impact,sort_measures,cb_text_control,scale_benefit,benefit_str,legend_location,tcr_off)
 EXAMPLE:
   climada_adaptation_bar_chart_v2(climada_measures_impact(climada_entity_read),'',1) % from scratch
 INPUTS:
   measures_impact: a climada measures_impact structure, can hold multiple measures_impacts
       see climada_measures_impact
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   sort_measures: if set to 1, sort measures according to size of benefit
   cb_text_control: control position of cb_ratio 
 OUTPUTS:
   fig: a figure handle
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150921, init
 Lea Mueller, muellele@gmail.com, 20150921, measures_impact can hold multiple measures_impact(impact_i)
 Lea Mueller, muellele@gmail.com, 20150924, add cost_unit and xlim_value, introduce climada_digit_set
 Lea Mueller, muellele@gmail.com, 20151019, set bc ratio to less affected people per 10'000 USD
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_adaptation_bar_chart from climada_adaptation_bar_chart_v2
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_adaptation_bar_chart.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_cost_curve">
<H2>climada_adaptation_cost_curve</H2></A>
<font color="blue">function [insurance_benefit,insurance_cost]=climada_adaptation_cost_curve(measures_impact,measures_impact_comparison,x_text_control,y_text_control,scaled_AED,nice_numbers,reverse_cb,plot_arrows) </font>
 climada measures impact climate adaptation cost curve
 NAME:
   climada_adaptation_cost_curve
 PURPOSE:
   plot adaptation cost curve, color measures according to benefit/cost
   ratio (see measures_impact.color_keep to keep colors as defined in
   measures)

   see also: climada_adaptation_event_view

   NOTE: The mode with output arguments insurance_benefit and
   insurance_cost is only used when called from climada_demo (the flag
   called_from_climada_demo), no relevance for standard use .

   Previous call climada_measures_impact
   or read benefits directly from excel file with climada_measures_read
 CALLING SEQUENCE:
   [~,~]=climada_adaptation_cost_curve(measures_impact,measures_impact_comparison,x_text_control,y_text_control,scaled_AED,nice_numbers,reverse_cb,plot_arrows)
 EXAMPLE:
   climada_adaptation_cost_curve(climada_measures_impact(climada_entity_read)) % from scratch
 INPUTS:
   measures_impact: either a struct containing the impacts of measures or
       a measures_impact file (.mat with a struct) see climada_measures_impact
       &ampgt promted for if not given
       If theres is a field measures_impact.y_axis_max, it defines the
       maximum of the vertical axis (to shape plots comparable). There are
       no checks any more, hence if you provide a stange number, you get a
       strange vertical scale ;-)
       If theres is a field measures_impact.x_axis_max, it defines the
       maximum of the horizontal axis (to shape plots comparable).
       If there is a field measures_impact.color_keep, the colors as
       defined in measures are kept, otherwise nice colors are assigned.
 OPTIONAL INPUT PARAMETERS:
   measures_impact_comparison: same as measures_impact, but for comparison
       (will be shown in overlay). Not prompted for, so please specify in
       call, or enter 'ASK' in climada_adaptation_cost_curve('','ASK')
       If theres is a field measures_impact_comparison.label_comparison,
       it defines whether comparison wll be labeld (=1, default) or not (=0)
       If =0, also do not label TCR (total climate risk) for comparison
       These setting are usually good for decluttered plots for presentations
   x_text_control: controls the horizontal distribution of the text labels
       (divider of the length of the x-axis, default=20)
   y_text_control: controls the vertical distribution of the text labels
       (divider of the length of the y-axis, default=50)
   scaled_AED: NOT IMPLEMENTED/IN USE ANY MORE
   nice_numbers: NOT IMPLEMENTED/IN USE ANY MORE
   reverse_cb: (=1, default) show benefit per cost
       Set =0 to show cost/beenfit
   plot_arrows: whether we do (=1) or don't (=0, default) plot arrows
       underneath the x-axis to show cost-effective measures and
       non-cost-effective measures extent.
 OUTPUTS:
   insurance_benefit and insurance_cost: only used when called from
       climada_play_adapt_cost_curve, see there (in essence to write
       insurance cost on the GUI). For illustrative purposes only!
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
 David N. Bresch, david.bresch@gmail.com, 20091230 major revision, appreance similar to ECA graphs
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
 David N. Bresch, david.bresch@gmail.com, 20130316 compatibility for both direct call as well as via climada_demo_gui
 Gilles Stassen gillesstassen@hotmail.com 20141212 fixed the arrow issue; changed labeling of total climate risk to USD x m rounded to 2 s.f.
 David N. Bresch, david.bresch@gmail.com, 20141213 plot_arrows=0 by default and climada_demo option cleaned up
 David N. Bresch, david.bresch@gmail.com, 20141231 subaxis removed (not clean, troubles in Octave)
 Lea Mueller, muellele@gmail.com, 20150617, set to bc_ratio (benefits per cost) instead of cb_ratio
 David N. Bresch, david.bresch@gmail.com, 20150804 reverse_cb fixed for comparison plot
 David N. Bresch, david.bresch@gmail.com, 20150907 decluttered (for presentations), i.e. label_comparison, x_axis_max and y_axis_max introduced
 Lea Mueller, muellele@gmail.com, 20150909, introduce factor for unit 'people', to show cb ratio as people not affected/10'000 USD
 David N. Bresch, david.bresch@gmail.com, 20150909, color_keep introduced
 Lea Mueller, muellele@gmail.com, 20150930, introduce climada_digit_set
 Lea Mueller, muellele@gmail.com, 20160309, bugfix fprintf reverse_cb for insurance
 David N. Bresch, david.bresch@gmail.com, 20160427, total climate risk not plotted for climada_demo, fontsize_ adjusted
 David N. Bresch, david.bresch@gmail.com, 20160429, major review, unit display etc cleaned up
 David N. Bresch, david.bresch@gmail.com, 20160429, insurance_benefit,insurance_cost as output again
 David N. Bresch, david.bresch@gmail.com, 20160429, stdout cleaned up
 Lea Mueller, muellele@gmail.com, 20160531, show x- and y-ticks
 David N. Bresch, david.bresch@gmail.com, 20160606, display units synchronized if same unit_name
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_adaptation_cost_curve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_adaptation_event_view">
<H2>climada_adaptation_event_view</H2></A>
<font color="blue">function AEV = climada_adaptation_event_view(measures_impact,comparison_return_periods) </font>
 climada measures impact climate adaptation damage frequency effect
 NAME:
   climada_adaptation_event_view
 PURPOSE:
   show the effect of measures for events of different return periods
   see also: climada_adaptation_cost_curve
 CALLING SEQUENCE:
   climada_adaptation_event_view(measures_impact,comparison_return_periods)
 EXAMPLE:
   climada_adaptation_event_view(climada_measures_impact(climada_entity_read)) % from scratch
 INPUTS:
   measures_impact: either a struct containing the impacts of measures or a measures_impact file (.mat with a struct)
       see climada_measures_impact
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   comparison_return_periods: the list of return periods to show the
       comparison for, default is [10 25 100]
 OUTPUTS:
   graph, and AEV, a stucture which holds the data of the graph:
       damage(measure_i,return_period_i): the damage for measure_i at return_period_i
           damage(end,return_period_i) holds the damage with no measures
       return_period(return_period_i): the list of return periods
       frequency(return_period_i): the list of frequencies
       effect(measure_i,return_period_i): the effect of measure_i at return_period_i
       total_effect(return_period_i): the total effect of all measures at return_period_i
       cumulated(return_period_i): for each return period, a struct,with
           effect(measure_i): the cumulated effect up to measure i
           NOTE: measures ordered as in adaptation cost curve
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20100109
 David N. Bresch, david.bresch@gmail.com, 20150402, compatibility with version 8ff (R2014...)
 David N. Bresch, david.bresch@gmail.com, 20151021, checked to work for index insurance, too
 Lea Mueller, muellele@gmail.com, 20151125, correct 'FaceColor' issue for version 8
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_adaptation_event_view.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo">
<H2>climada_demo</H2></A>
<font color="blue">function climada_demo </font>
 climada
 NAME:
   climada_demo
 PURPOSE:
   a brief demo of climada by way of an interactive GUI
   
 CALLING SEQUENCE:
   climada_demo
 EXAMPLE:
   climada_demo
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120116
 David N. Bresch, david.bresch@gmail.com, 20141123, waitbar suppressed for speedup (noticeable)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_demo.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo_gui">
<H2>climada_demo_gui</H2></A>
<font color="blue">function varargout = climada_demo_gui(varargin) </font>
 CLIMADA_DEMO_GUI M-file for climada_demo_gui.fig
      CLIMADA_DEMO_GUI, by itself, creates a new CLIMADA_DEMO_GUI or raises the existing
      singleton*.

      H = CLIMADA_DEMO_GUI returns the handle to a new CLIMADA_DEMO_GUI or the handle to
      the existing singleton*.

      CLIMADA_DEMO_GUI('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in CLIMADA_DEMO_GUI.M with the given input
      arguments.

      CLIMADA_DEMO_GUI('Property','Value',...) creates a new CLIMADA_DEMO_GUI or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_demo_gui_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_demo_gui_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 david.bresch@gmail.com, 20140516, reverse_cb added
 muellele@gmail.com, 20160523, take demo_illu1.png from climada_global.root_dir instead of climada_global.data_dir

 Edit the above text to modify the response to help climada_demo_gui

 Last Modified by GUIDE v2.5 05-Aug-2015 17:49:27
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_demo_gui.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_demo_step_by_step">
<H2>climada_demo_step_by_step</H2></A>
 climada_demo_step_by_step
 climada
 NAME:
   climada_demo_step_by_step
 PURPOSE:
   show the core climada key functionality step-by-step. Not a function,
   just a batch-file to allow the user to step trough and inspect all
   individual steps. See climada manual, as this code implements the
   section &quotFrom tropical cyclone hazard generation to the adaptation cost
   curve ? a step-by-step guide&quot provided there.

   running it all takes (first time) about 3 minutes (faster on subsequent
   calls, since the probabilistic hazard event set is loaded rather than
   re-generated)

   Note for Octave users: due to slower processing speed of Octave, the
   demo runs with smaller datasets. Somple plots do not look nice, but all
   calculations and core graphics (adaptation cost curve) work fine.
 CALLING SEQUENCE:
   climada_demo_step_by_step
 EXAMPLE:
   climada_demo_step_by_step
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141217, updated
 David N. Bresch, david.bresch@gmail.com, 20141231, octave-compatible
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_demo_step_by_step.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_plot">
<H2>climada_entity_plot</H2></A>
<font color="blue">function climada_entity_plot(entity,markersize,plot_centroids,max_value,cbar_ylabel) </font>
 plot an entity, no detailed documentation
 NAME:
   climada_entity_plot
 PURPOSE:
   Plot the assets of an entity

   Note that you can overplot, just call hold on before calling
   climada_entity_plot, i.e. to plot assets on top of tracks (see
   climada_tc_track_info)

   See also climada_entity_read
   Possible prior call: climada_tc_track_info;hold on
 CALLING SEQUENCE:
   climada_entity_plot(entity)
 EXAMPLE:
   climada_entity_plot(climada_entity_read)
 INPUTS:
   entity: an entity (see climada_entity_read)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   markersize: the size of the 'tiles', one might need to experiment a
       bit, as the code tries (hard) to set a reasonabls default (based on
       resolution)
   plot_centroids: =1: plot centroids as small red dots
       =0: do not plot centroids (default)
   max_value: the maximum value to color
       default is max(entity.assets.Value)
   cbar_ylabel: label for the color bar, default 'Value'
       if empty, indicate entity value locations by black circles, e.g. for
       climada_hazard_plot(hazard);hold on;climada_entity_plot(entity,1,0,[],'')
 OUTPUTS:
   a figure
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141121, ICE initial
 David N. Bresch, david.bresch@gmail.com, 20160514, max_value,cbar_ylabel added
 David N. Bresch, david.bresch@gmail.com, 20160516, added climada_figure_scale_add
 David N. Bresch, david.bresch@gmail.com, 20160516, added option empty cbar_ylabel plus cleanup
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_entity_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_read">
<H2>climada_entity_read</H2></A>
<font color="blue">function [entity,entity_save_file] = climada_entity_read(entity_filename,hazard) </font>
 climada entity import, read assets, damagefunctions, discount and measures
 NAME:
   climada_entity_read
 PURPOSE:
   read the file with the assets, damagefunctions, measures and discount.
   Calls climada_assets_read, climada_damagefunctions_read,
    climada_measures_read and climada_discount_read.
   climada_assets_encode and climada_measures_encode is automatically invoked

   The code invokes climada_spreadsheet_read to really read the data,
   which implements .xls and .ods files

   For .xls, the sheet names are dynamically checked, for .ods, the sheet
   names are hard-wired (see code), means for .ods, all the sheets
   'assets', 'damagefunctions', 'measures' and 'discount' need to exist.

   NOTE: For backward compatibility, the code does read OLD entity files
   with a tab vulnerability (instead of damagefunctions) and VulnCurveID ...
   It renames respective fields in the resulting entity structure.

   OCTAVE: Please install the io package first, ether directly from source
   forge with: pkg install -forge io -auto
   or, (e.g. in case this fails, get the io package first from Octave
   source forge and then install from the downloaded package:
   pkg install {local_path}/io-2.2.5.tar -auto
   Note that it looks like Octave prefers .xlsx files

   next step: likely climada_ELS_calc
 CALLING SEQUENCE:
   [entity,entity_save_file] = climada_entity_read(entity_filename,hazard)
 EXAMPLE:
   entity = climada_entity_read;
 INPUTS:
   entity_filename: the filename of the Excel (or .ods) file with the assets
       If no path provided, default path ../data/entities is used
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       &ampgt promted for if not given (out of climada_assets_encode)
       ='NOENCODE' or 'noencode': do not encode assets, see climada_assets_encode
 OUTPUTS:
   entity: a structure, with
       assets: a structure, with
           .lat: the latitude of the values
           .lon: the longitude of the values
           .Value: the total insurable value
           .Deductible: the deductible
           .Cover: the cover
           .DamageFunID: the damagefunction curve ID
       damagefunctions: a structure, with
           .DamageFunID: the damagefunction curve ID
           .Intensity: the hazard intensity
           .MDD: the mean damage degree (severity of single asset damage)
           .PAA: the percentage of assets affected
       measures: a structure, with (not all just a list of the most frequent variables)
           .name
           .cost
           .hazard_intensity_impact_a
           .hazard_intensity_impact_b
           .hazard_event_set
           .MDD_impact_a
           .MDD_impact_b
           .PAA_impact_a
           .PAA_impact_b
           .assets_file
           .regional_scope: if assets tab found wich specifies the regional_scope of a measure
       discount: a structure, with
           .yield_ID: yield ID
           .year: year
           .discount_rate: discount_rate per year
   assets tab found wich specifies the regional_scope of a measure
   entity_save_file: the name the encoded entity got saved to
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090920
 Lea Mueller, 20110720
 David N. Bresch, david.bresch@gmail.com, 20130328, vuln_MDD_impact -&ampgt MDD_impact ...
 David N. Bresch, david.bresch@gmail.com, 20141029, entity_save_file added as output
 David N. Bresch, david.bresch@gmail.com, 20141121, hint to climada_damagefunction_read added
 David N. Bresch, david.bresch@gmail.com, 20141221, damagefunctions.MDR removed and NOENCODE added
 David N. Bresch, david.bresch@gmail.com, 20141230, cleanup
 David N. Bresch, david.bresch@gmail.com, 20150101, Octave compatibility (at least for .xlsx)
 David N. Bresch, david.bresch@gmail.com, 20150805, allow for name without path on input
 David N. Bresch, david.bresch@gmail.com, 20150829, check for valid/correct entity.assets.filename
 Lea Mueller, muellele@gmail.com, 20150831, assign assets.Value_unit with climada_global.Value_unit if not given
 Lea Mueller, muellele@gmail.com, 20150907, add damagefunctions check and measures check
 Lea Mueller, muellele@gmail.com, 20150908, add assets even it not encoded
 Lea Mueller, muellele@gmail.com, 20151016, delete nans if there are invalid entries
 Lea Mueller, muellele@gmail.com, 20151119, call climada_assets_read, climada_damagefunctions_read, climada_measures_read, climada_discount_read
 David N. Bresch, david.bresch@gmail.com, 20151229, old commented code deleted (finish 20151119 update)
 Lea Mueller, muellele@gmail.com, 20160523, complete extension, if missing
 David N. Bresch, david.bresch@gmail.com, 20160524, allow for entity without assets (e.g. called from nightlight entity)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_entity_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_init_vars">
<H2>climada_init_vars</H2></A>
<font color="blue">function ok=climada_init_vars(reset_flag) </font>
 init variables global
 NAME:
	climada_init_vars
 PURPOSE:
	initialize path and filenames

 CALLING SEQUENCE:
	ok=climada_init_vars(reset_flag)
 EXAMPLE:
	ok=climada_init_vars;
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   reset_flag: if set to 1, forced re-init
 OUTPUTS:
	ok: =1 if no troubles, 0 else
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120430
 David N. Bresch, david.bresch@gmail.com, 20130316, EDS-&ampgtEDS...
 David N. Bresch, david.bresch@gmail.com, 20130623, re_check_encoding
 Lea Mueller, muellele@gmail.com, 20140211, start year set to 2014
 David N. Bresch, david.bresch@gmail.com, 20141018, switch to modules instead of climada_additional
 David N. Bresch, david.bresch@gmail.com, 20141225, climada_global.coastline_file added
 David N. Bresch, david.bresch@gmail.com, 20141226, update to be in line with manual
 David N. Bresch, david.bresch@gmail.com, 20141231, octave compatibility
 David N. Bresch, david.bresch@gmail.com, 20150126, csv_delimiter depends on computer
 David N. Bresch, david.bresch@gmail.com, 20150203, climada_lonlat_cleanup
 David N. Bresch, david.bresch@gmail.com, 20150211, global_CAGR added
 Lea Mueller, muellele@gmail.com, 20150728, add project directory,i.e. now set to San Salvador
 Lea Mueller, muellele@gmail.com, 20150728, set waitbar to 0
 David N. Bresch, david.bresch@gmail.com, 20150805, project_dir NOT possible to set here, set to default data dir
 David N. Bresch, david.bresch@gmail.com, 20150805, climada_demo_gui parameters set here
 David N. Bresch, david.bresch@gmail.com, 20150807, climada_global.tc.extratropical_transition
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 Lea Mueller, muellele@gmail.com, 20150831, introduce climada_global.Value_unit
 David N. Bresch, david.bresch@gmail.com, 20150906, climada_global.font_scale
 Lea Mueller, muellele@gmail.com, 20150924, introduce climada_global.max_distance_to_hazard
 Lea Mueller, muellele@gmail.com, 20151204, introduce climada_global.markersize, for climada_color_plot and plotclr
 David N. Bresch, david.bresch@gmail.com, 20160222, entities_dir added
 Lea Mueller, muellele@gmail.com, 20160225, introduce climada_global.marker, for climada_color_plot and plotclr
 Lea Mueller, muellele@gmail.com, 20160229, introduce climada_global.admin1_plot, default is 0, do not show admin1 lines, for climada_color_plot
 David N. Bresch, david.bresch@gmail.com, 20160411, climada_global.present_reference_year = 2016
 David N. Bresch, david.bresch@gmail.com, 20160429, Value_* extended and cost_* added
 David N. Bresch, david.bresch@gmail.com, 20160429, climada_lonlat_cleanup and climada_centroids_cleanup switched off
 David N. Bresch, david.bresch@gmail.com, 20160606, max_encoding_distance_m (renamed from max_distance_to_hazard) set to 1e5, not 1e6 any more
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_init_vars.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact">
<H2>climada_measures_impact</H2></A>
<font color="blue">function measures_impact=climada_measures_impact(entity,hazard,measures_impact_reference,measures,map_risk_premium,sanity_check) </font>
 climada
 NAME:
   climada_measures_impact
 PURPOSE:
   calculate the impact of a series of measures on a given set of assets
   under a given hazard, main functions called are climada_EDS_calc and
   climada_measures_impact_discount

   next step: climada_adaptation_cost_curve or
   climada_adaptation_event_view

   Note on display units: consider using climada_digit_set to infer good
   values for measures_impact.Value_display_unit_name
   (measures_impact.Value_display_unit_fact) and
   measures_impact.cost_display_unit_name (measures_impact.cost_display_unit_fact)

   see also: climada_measures_impact_parametric

   Note: the risk premiums show need to be handled with UTMOST care, as
   they are proxies of real risk premiums. First, the total climate risk
   premium is calculated as NPV of total climate risk divided by the sum
   of all assets (that simple), hence it does not really reperesent a
   premium that one would i.e. charge to cover these risks over the course
   of a year (since it's the NPV...). The total climate risk premium
   reduction provides an upper bound of the risk premium reduction due to
   the cost-effective measures, since any further csosts, such as
   distribution, claims handling and capital costs are not considered at
   all. Second, the risk premiums mapped (if map_risk_premium=1) are calculated
   as the expected damage at each centroid divided by the asset value at
   this centroid, hence are again a CRUDE PROXY. Again, the difference of
   the fgu and net values is more telling than the absolute numbers.
 CALLING SEQUENCE:
   measures_impact=climada_measures_impact(entity,hazard,measures_impact_reference,measures)
 EXAMPLE:
   measures_impact=climada_measures_impact % all prompted for
   hazard_set_file='...\climada\data\hazards\TCNA_A_Probabilistic.mat';
   measures_impact=climada_measures_impact(climada_entity_read('',hazard_set_file),hazard_set_file,'no')
   measures_impact=climada_measures_impact('','','','',1) % all interactive, show risk premium map
 INPUTS:
   entity: a read and encoded assets and damagefunctions file, see climada_assets_encode(climada_assets_read)
       &ampgt promted for if not given
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   measures_impact_reference: reference measures (e.g. portfolio today and
       measures today). Used to properly calculate the net present values
       of future impacts
       set to 'no' if you would not like to be asked for a reference
   measures: either a struct containing the measures or a measures set file (.mat with a struct)
       see climada_measures_read.
       A bit complex:
       If measures is empty (not provided), it is taken from entity.measures (in case entity
           contains measures). If entity does not contain measures, user gets prompted for.
       If user provides measures, these measures are used
       If user set measures to 'ASK', he gets prompted for and these are used
   map_risk_premium: whether we show a plot (=1) of risk premium at each
       centroid using a contour plot on a map, with cost-effective
       measures and without any measures(fgu). Default=0 
       Please note that this risk premium is a proxy for a real premium,
       as it just consistes of the expected damage at each centroid.
 OUTPUTS:
   measures_impact: a structure with
       EDS(measure_i): the event damage set for each measure, last one EDS(end) for no measures
       ED(measure_i): the annual expected damage to the assets under measure_i,
           last one ED(end) for no measures
       benefit(measure_i): the benefit of measure_i
       cb_ratio(measure_i): the cost/benefit ratio of measure_i
       measures: just a copy of measures, so we have all we need together
       title_str: a meaningful title, of the format: measures @ assets | hazard
       NOTE: currently measures_impact is also stored (with a lengthy filename)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
 David N. Bresch, david.bresch@gmail.com, 20130316, ELS-&ampgtEDS...
 David N. Bresch, david.bresch@gmail.com, 20130328, vuln_MDD_impact -&ampgt MDD_impact...
 David N. Bresch, david.bresch@gmail.com, 20130623, hazard set switch added
 David N. Bresch, david.bresch@gmail.com, 20140509, non-linear damage time dependency implemented
 David N. Bresch, david.bresch@gmail.com, 20140509, risk premium calc added
 David N. Bresch, david.bresch@gmail.com, 20140510, risk premium map added
 David N. Bresch, david.bresch@gmail.com, 20141220, re-encoding check added
 David N. Bresch, david.bresch@gmail.com, 20150101, cleanup
 Gilles Stassen, gillesstassen@hotmail.com, 20150626, if exist(hazard_file,'var') -&ampgt exist('hazard_file','var')
 Lea Mueller, muellele@gmail.com, 20150831, introduce measures_impact.Value_unit
 Lea Mueller, muellele@gmail.com, 20150902, rename to hazard_intensity_impact_b from hazard_intensity_impact
 Lea Mueller, muellele@gmail.com, 20150902, call climada_measures_impact_discount in an separate function
 David N. Bresch, david.bresch@gmail.com, 20150907, hazard_intensity_impact_a and hazard_intensity_impact_b properly implemented
 Lea Mueller, muellele@gmail.com, 20150907, add variable sanity_check to perform a safety check within climada_EDS_calc, add climada_measures_check
 Lea Mueller, muellele@gmail.com, 20150908, switch assets if needed (defined in measures.assets_file)
 Lea Mueller, muellele@gmail.com, 20150915, add regional scope of measures
 Lea Mueller, muellele@gmail.com, 20150921, add measures check to ensure size of regional_scope is aligned with number of assets
 Lea Mueller, muellele@gmail.com, 20150921, save entity as .mat if assets are switched (in entity.assets.filename)
 Lea Mueller, muellele@gmail.com, 20151127, add measures_impact.scenario
 Lea Mueller, muellele@gmail.com, 20151130, invoke climada_hazard_load and climada_entity_load
 David N. Bresch, david.bresch@gmail.com, 20160429, automatic determination of display units
 David N. Bresch, david.bresch@gmail.com, 20160429, title_str without measures name
 David N. Bresch, david.bresch@gmail.com, 20160606, display units synchronized if same unit_name
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_measures_impact.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_parametric">
<H2>climada_measures_impact_parametric</H2></A>
<font color="blue">function measures_impact=climada_measures_impact_parametric(measures_impact,index_def) </font>
 climada template
 MODULE:
   core
 NAME:
   climada_measures_impact_parametric
 PURPOSE:
   Add parametric insurance to measures. Define index payout (attachement,
   cover or exit, tick value) and the centroid_ID at which the hazard is
   being evaluated.

   previous call: climada_measures_impact
   next call: climada_adaptation_cost_curve

   TEST settings:
   climada_demo_step_by_step % run this to get a reasonable measures_impact structure
   index_def.attachement=40;index_def.cover=30;index_def.tick_value=1.0000e+09;
   index_def.centroid_index=50;
   measures_impact=climada_measures_impact_parametric(measures_impact,index_def)
   climada_adaptation_event_view(measures_impact,[10,150,1500])
 CALLING SEQUENCE:
   measures_impact=climada_measures_impact_parametric(measures_impact,index_def)
 EXAMPLE:
   measures_impact=climada_measures_impact_parametric(climada_measures_impact)
 INPUTS:
   measures_impact: the output from climada_measures_impact
   index_def: the parametric index definition, with fields (in the
       metric of the pertinent hazard intensity)
       attachement: the attachement point
       cover: the cover (if missing, calculated from exit)
       exit: the exit (if missing, calculated from cover)
       tick_value: the payout per unit, default=1 (in the monetary unit)
       centroid_ID: the centroid ID (in the hazard set) at which the index
           insurance is evaluated or
       centroid_index: the index (in the hazard set) at which the index
           insurance is evaluated. If both centroid_ID and centroid_index
           are passed, centroid_index is used
       markup: the multiplier to get to cost, default=2
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20151021, intial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_measures_impact_parametric.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_event_damage_ens">
<H2>climada_tc_event_damage_ens</H2></A>
<font color="blue">function [damage,track_filename,err_msg]=climada_tc_event_damage_ens(UNISYS_regi,UNISYS_year,UNISYS_name,n_tracks,call_from_GUI) </font>
 MODULE:
   advanced
 NAME:
   climada_tc_event_damage_ens
 PURPOSE:
   Given a single track file, calculate the damage for all countries
   posibbly hit (i.e. at least one node within country boders)

   Plus generate ensemble 'forecast' damage

   Fetches data from: weather.unisys.com/hurricane, but since the format
   and layout of the webpage changed, it only works back to about 2006...
   earier years will,likely lead to errors. In such cases, retrieve the TC
   track file manually and run the code by passing the track file in the
   first variable (UNISYS_regi)

   See also climada_tc_event_damage_ens_gui
 CALLING SEQUENCE:
   [damage,track_filename]=climada_tc_event_damage_ens(UNISYS_regi,UNISYS_year,UNISYS_name,n_tracks,call_from_GUI)
 EXAMPLE:
   damage=climada_tc_event_damage_ens('w_pacific','2015','KOPPU',5)
   [damage,track_filename]=climada_tc_event_damage_ens('','NONE','NONE',5) % prompt for track file
 INPUTS:
   UNISYS_regi: the UNISYS region, i.e. 'atlantic','e_pacific','w_pacific'
       's_pacific','s_indian' or 'n_indian'
       SPECIAL: if a TC track filename (with path) is passed instead of a region
       and UNISYS_year and UNISYS_name are both set to 'NONE', the track file
       is used. This way, any TC track file can be passed as input.
   UNISYS_year: the year yyyy (as string). Note that years before 2006
       likely do not work properly (since UNISYS changed the layout of
       their webpage and the code reads the html source to figure the
       event names...). If set to 'NONE' together with UNISYS_name, the
       user gets prompted for the TC track file
   UNISYS_name: the name of the event (without Hurricane-1 ..., usually uppercase).
       If set to 'NONE' together with UNISYS_year, the user gets prompted
       for the TC track file.
   &ampgt   if all three parameters above are empty: Select the region and event
       from selection lists, the single TC track file is downloaded from
       UNISYS and processed
   n_tracks: number of tracks (incl original one), default=100
   call_from_GUI: switch to direct to the correct axes
       if empty, not called from GUI, otherwise contains the axes handles
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   damage: the vector with the calculated damages, damage(1) is the one
       for the reported track, all following ones for ensemble members
   track_filename: the TC track filename with path
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20151009, initial
 David N. Bresch, david.bresch@gmail.com, 20151018, automatic country detection
 David N. Bresch, david.bresch@gmail.com, 20151019, converted into a function, see also climada_tc_event_damage_ens_gui
 David N. Bresch, david.bresch@gmail.com, 20151021, special case for no web access added
amage=[];track_filename='';err_msg=''; % init output
 init global variables
lobal climada_global
f ~climada_init_vars,return;end
 poor man's version to check arguments
f ~exist('UNISYS_regi','var'),UNISYS_regi='';end
f ~exist('UNISYS_year','var'),UNISYS_year='';end
f ~exist('UNISYS_name','var'),UNISYS_name='';end
f ~exist('n_tracks','var'),   n_tracks   =100;end % number of tracks (incl original one)
f ~exist('call_from_GUI','var'),call_from_GUI=[];end
 PARAMETERS

 for experimenting, you might set parameters here (otherwise asked at first call)
 track_filename = [climada_global.data_dir filesep 'tc_tracks' filesep '20071116_SIDR_track.dat'];
 country_name='Bangladesh';

ontSize=12; % 18 for plots for e.g. pptx

 UNISYS regions (hard-wired)
NISYS_regis{1}='atlantic';
NISYS_regis{2}='e_pacific';
NISYS_regis{3}='w_pacific';
NISYS_regis{4}='s_pacific';
NISYS_regis{5}='s_indian';
NISYS_regis{6}='n_indian';
f strcmpi(UNISYS_name,'nowebaccess&ampgtpresscalculatebutton')
   % special case to select local file
   UNISYS_name='NONE';
   UNISYS_year='NONE';
nd
f isempty(UNISYS_name)
   
   if isempty(UNISYS_regi)
       % prompt for the region
       [selection,ok] = listdlg('PromptString','Select region:',...
           'ListString',UNISYS_regis,'SelectionMode','SINGLE');
       pause(0.1)
       if ok
           UNISYS_regi=UNISYS_regis{selection};
       end
   end % isempty(UNISYS_regi)
   
   if isempty(UNISYS_year)
       % UNISYS year (usually the actual one)
       UNISYS_year=datestr(today,'yyyy'); % e.g. '2015'
   end
   
   % fetch the index of all events
   url_str=['http://weather.unisys.com/hurricane/' UNISYS_regi '/' UNISYS_year '/index.php'];
   fprintf('fetching %s\n',url_str);
   [index_str,STATUS] = urlread(url_str);
   if STATUS
       % kind of parse index_str to get names
       UNISYS_names={};
       for event_i=100:-1:1
           for black_red=1:2
               if black_red==1
                   check_str=['&amplttr&ampgt&amplttd width=&quot20&quot align=&quotright&quot style=&quotcolor:black;&quot&ampgt' num2str(event_i) '&amplt/td&ampgt&amplttd width=&quot250&quot style=&quotcolor:black;&quot&ampgt'];
               else
                   check_str=['&amplttr&ampgt&amplttd width=&quot20&quot align=&quotright&quot style=&quotcolor:red;&quot&ampgt' num2str(event_i) '&amplt/td&ampgt&amplttd width=&quot250&quot style=&quotcolor:red;&quot&ampgt'];
               end
               
               pos=strfind(index_str,check_str);
               if pos&ampgt0
                   UNISYS_names{end+1}=index_str(pos+length(check_str):pos+length(check_str)+25);
               end
           end % black_red
       end % event_i
       
       [selection,ok] = listdlg('PromptString','Select event:',...
           'ListString',UNISYS_names,'SelectionMode','SINGLE');
       pause(0.1)
       if ok
           UNISYS_name=UNISYS_names{selection};
           % get rid of all clutter
           UNISYS_name=strrep(UNISYS_name,'Super ','');
           UNISYS_name=strrep(UNISYS_name,'Tropical Depression','');
           UNISYS_name=strrep(UNISYS_name,'Tropical Storm','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-1','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-2','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-3','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-4','');
           UNISYS_name=strrep(UNISYS_name,'Typhoon-5','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-1','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-2','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-3','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-4','');
           UNISYS_name=strrep(UNISYS_name,'Hurricane-5','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-1','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-2','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-3','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-4','');
           UNISYS_name=strrep(UNISYS_name,'Cyclone-5','');
           UNISYS_name=strrep(UNISYS_name,' ','');
           UNISYS_name=strrep(UNISYS_name,' ','');
       else
           return
       end
   else
       UNISYS_name='NONE';
   end
nd % isempty(UNISYS_name)
f strcmp(UNISYS_name,'NONE')
   track_filename=''; % force prompting for track file
   if exist(UNISYS_regi,'file'),track_filename=UNISYS_regi;end
lse
   % fetch the tc track data from the internet
   url_str=['http://weather.unisys.com/hurricane/' UNISYS_regi '/' UNISYS_year '/' UNISYS_name '/track.dat'];
   fprintf('fetching %s\n',url_str);
   track_data_str = urlread(url_str);
   track_filename=[climada_global.data_dir filesep 'tc_tracks' filesep  UNISYS_regi '_' UNISYS_year '_' UNISYS_name '.dat'];
   fprintf('saving as %s\n',track_filename);
   fid=fopen(track_filename,'w');
   % write to single track file
   fprintf(fid,'%s\r\n',track_data_str);
   fclose(fid);
nd
 get TC track (prompting for file to be selected)
tc_track,track_filename]=climada_tc_read_unisys_track(track_filename);
 resolve issue with +/-180 at dateline
c_track.lon=climada_dateline_resolve(tc_track.lon);
 automatically detec country/ies
ountry_list={};
hapes=climada_shaperead(climada_global.map_border_file); % get country shapes
or shape_i = 1:length(shapes)
   in = inpolygon(tc_track.lon,tc_track.lat,shapes(shape_i).X,shapes(shape_i).Y);
   if sum(in)&ampgt0
       country_list{end+1}=shapes(shape_i).NAME;
   end
nd % shape_i
f isempty(country_list) % prompt for country, as no direct hit
   country_list{1}=climada_country_name('SINGLE'); % obtain country
nd
or country_i=1:length(country_list)
   %for country_i=1:1
   
   country_name=char(country_list{country_i});
   
   fprintf('*** processing %s:\n',country_name);
   
   if isempty(country_name) % usually not the case any more, but left in, in case one would like to use this
       [country_name,country_ISO3,~]=climada_country_name('SINGLE'); % obtain country
   else
       [country_name,country_ISO3,~]=climada_country_name(country_name); % just get ISO3
   end
   country_name=char(country_name);
   country_ISO3=char(country_ISO3);
   
   tc_tracks=climada_tc_random_walk(tc_track,n_tracks-1,0.1,pi/30); % /15
   
   % get entity and centroids
   entity_filename=[country_ISO3 '_' strrep(country_name,' ','') '_entity'];
   entity_file=[climada_global.entities_dir filesep entity_filename '.mat'];
   centroids_file=[climada_global.centroids_dir filesep country_ISO3 '_' strrep(country_name,' ','') '_centroids.mat'];
   if exist(entity_file,'file')
       entity=climada_entity_load(entity_file);
       if exist(centroids_file,'file')
           centroids=climada_centroids_load(centroids_file);
           %entity=climada_assets_encode(entity,centroids);
       else
           % use geo locations of entity.assets
           centroids.lon=entity.assets.lon;
           centroids.lat=entity.assets.lat;
           centroids.centroid_ID=1:length(centroids.lon);
       end % exist(centroids_file,'file')
   else
       % try to create the entity
       if exist('climada_create_GDP_entity','file')
           % invoke the country_risk module to generate centroids and entity
           fprintf('*** creating %s (takes a moment)\n\n',entity_filename)
           if ~isempty(call_from_GUI)
               cla(call_from_GUI.axes_left)
               axes(call_from_GUI.axes_left);
               text(0.1,0.5,'creating assets (takes a moment) ...','FontSize',FontSize);drawnow
           end
           [centroids,entity] = climada_create_GDP_entity(country_name,[],0,1);
           save(centroids_file,'centroids');
           save(entity_file,'entity');
           climada_entity_value_GDP_adjust(entity_file); % assets based on GDP
           entity=climada_entity_load(entity_file);
           fprintf('%s created\n\n',entity_filename)
       else
           fprintf(['%s not found. Please download ' ...
               '&amplta href=&quothttps://github.com/davidnbresch/climada_module_country_risk&quot&ampgt' ...
               'climada_module_country_risk&amplt/a&ampgt from Github in order to create it.\n'],entity_filename)
           err_msg=sprintf('Please create %s entity first, see command line',country_name);
           return
       end
   end % exist(entity_file,'file')
   
   % resolve issue with +/-180 at dateline
   entity.assets.lon=climada_dateline_resolve(entity.assets.lon);
   centroids.lon=climada_dateline_resolve(centroids.lon);
   
   if isempty(call_from_GUI)
       figure('Name',['TC ensemble ' country_name],'Position',[199 55 1076 618],'Color',[1 1 1]);
       subplot(1,2,1)
   else
       cla(call_from_GUI.axes_left)
       axes(call_from_GUI.axes_left);
   end
   
   climada_entity_plot(entity,4)
   % plot(tc_track.lon,tc_track.lat,'-r');axis equal; hold on
   % climada_plot_world_borders(1,country_name,'',1)
   plot(tc_track.lon,tc_track.lat,'-r')
   plot(tc_track.lon(logical(tc_track.forecast)),tc_track.lat(logical(tc_track.forecast)),'xr')
   
   for track_i=1:length(tc_tracks),plot(tc_tracks(track_i).lon,tc_tracks(track_i).lat,'-b');end
   plot(tc_tracks(1).lon,tc_tracks(1).lat,'-r','LineWidth',2); % orig track
   axis off
   xlabel('red crosses: forecast timesteps, blue:ensemble members','FontSize',8);
   title(country_name,'FontSize',FontSize,'FontWeight','normal');drawnow
   
   if isempty(call_from_GUI)
       subplot(1,2,2)
   else
       cla(call_from_GUI.axes_right)
       axes(call_from_GUI.axes_right);
   end
   damage=zeros(1,length(tc_tracks)); % allocate
   n_tracks=length(tc_tracks);
   for track_i=1:n_tracks
       hazard=climada_tc_hazard_set(tc_tracks(track_i),'NOSAVE',centroids);
       hazard.frequency=1;
       EDS(track_i)=climada_EDS_calc(entity,hazard);
       damage(track_i)=EDS(track_i).damage;
       calc_sec=str2double(strtok(strrep(EDS(track_i).comment,'calculation took ',''),'sec'));
       cla;text(0.1,0.5,sprintf('%i seconds calculation remaining (%i tracks)',...
           ceil((n_tracks-track_i)*calc_sec),n_tracks-track_i),'FontSize',FontSize);drawnow
       %fprintf('%i seconds calculation remaining\n',ceil((length(tc_tracks)-track_i)*calc_sec));
   end % track_i
   
   cla(call_from_GUI.axes_right) % clear
   hist(damage); % plot
   [counts,~]=hist(damage); % get info
   set(gca,'FontSize',FontSize),xlabel('damage [USD]','FontSize',FontSize),ylabel('event count','FontSize',FontSize)
   hold on;plot(damage(1),0,'xr');
   ddamage=(max(damage)-min(damage))/(2*length(counts));
   text(damage(1)+ddamage,1,'damage','Rotation',90,'Color','red','FontSize',FontSize);
   [~,track_i] = max(damage);
   tc_track_name=lower(tc_track.name);
   title([[upper(tc_track_name(1)) tc_track_name(2:end)]  ' @ ' country_name],'FontSize',FontSize,'FontWeight','normal');
   drawnow
   %plot(damage(track_i),0,'xb');
   %text(damage(track_i),0,'max ensemble damage','Rotation',90);
   if isempty(call_from_GUI)
       subplot(1,2,1);hold on;
   else
       axes(call_from_GUI.axes_left);
       hold on
   end
   plot(tc_tracks(track_i).lon,tc_tracks(track_i).lat,'-b','LineWidth',2); % max damage track
   
   call_from_GUI=[]; % second plot in new figure
   
nd % country_i
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_tc_event_damage_ens.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_event_damage_ens_gui">
<H2>climada_tc_event_damage_ens_gui</H2></A>
<font color="blue">function varargout = climada_tc_event_damage_ens_gui(varargin) </font>
 CLIMADA_TC_EVENT_DAMAGE_ENS_GUI MATLAB code for climada_tc_event_damage_ens_gui.fig
      CLIMADA_TC_EVENT_DAMAGE_ENS_GUI, by itself, creates a new CLIMADA_TC_EVENT_DAMAGE_ENS_GUI or raises the existing
      singleton*.

      H = CLIMADA_TC_EVENT_DAMAGE_ENS_GUI returns the handle to a new CLIMADA_TC_EVENT_DAMAGE_ENS_GUI or the handle to
      the existing singleton*.

      CLIMADA_TC_EVENT_DAMAGE_ENS_GUI('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in CLIMADA_TC_EVENT_DAMAGE_ENS_GUI.M with the given input arguments.

      CLIMADA_TC_EVENT_DAMAGE_ENS_GUI('Property','Value',...) creates a new CLIMADA_TC_EVENT_DAMAGE_ENS_GUI or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_tc_event_damage_ens_gui_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_tc_event_damage_ens_gui_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 Edit the above text to modify the response to help climada_tc_event_damage_ens_gui
 Last Modified by GUIDE v2.5 19-Oct-2015 18:56:29
 Begin initialization code - DO NOT EDIT
ui_Singleton = 1;
ui_State = struct('gui_Name',       mfilename, ...
                  'gui_Singleton',  gui_Singleton, ...
                  'gui_OpeningFcn', @climada_tc_event_damage_ens_gui_OpeningFcn, ...
                  'gui_OutputFcn',  @climada_tc_event_damage_ens_gui_OutputFcn, ...
                  'gui_LayoutFcn',  [] , ...
                  'gui_Callback',   []);
f nargin &amp&amp ischar(varargin{1})
   gui_State.gui_Callback = str2func(varargin{1});
nd
f nargout
   [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
lse
   gui_mainfcn(gui_State, varargin{:});
nd
 End initialization code - DO NOT EDIT
 --- Executes just before climada_tc_event_damage_ens_gui is made visible.
<font color="blue">function climada_tc_event_damage_ens_gui_OpeningFcn(hObject, eventdata, handles, varargin) </font>
 This function has no output args, see OutputFcn.
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 varargin   command line arguments to climada_tc_event_damage_ens_gui (see VARARGIN)
 Choose default command line output for climada_tc_event_damage_ens_gui
andles.output = hObject;
 Update handles structure
uidata(hObject, handles);
 UIWAIT makes climada_tc_event_damage_ens_gui wait for user response (see UIRESUME)
 uiwait(handles.figure1);
et_UNISYS_name_list(hObject,eventdata,handles);
 --- Outputs from this function are returned to the command line.
<font color="blue">function varargout = climada_tc_event_damage_ens_gui_OutputFcn(hObject, eventdata, handles)  </font>
 varargout  cell array for returning output args (see VARARGOUT);
 hObject    handle to figure
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Get default command line output from handles structure
arargout{1} = handles.output;
 --- Executes on selection change in popupmenu_region.
<font color="blue">function popupmenu_region_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_region (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_region contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_region
et_UNISYS_name_list(hObject,eventdata,handles);
et(handles.pushbutton_calculate,'Enable','off');
et(handles.pushbutton_calculate,'BackgroundColor','red'); % make inactive
et(handles.popupmenu_year,'Enable','on'); % first a name region to be selected
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_region_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_region (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 UNISYS regions
lobal climada_tc_event_damage_ens_vars
limada_tc_event_damage_ens_vars.UNISYS_regis{1}='atlantic';
limada_tc_event_damage_ens_vars.UNISYS_regis{2}='e_pacific';
limada_tc_event_damage_ens_vars.UNISYS_regis{3}='w_pacific';
limada_tc_event_damage_ens_vars.UNISYS_regis{4}='s_pacific';
limada_tc_event_damage_ens_vars.UNISYS_regis{5}='s_indian';
limada_tc_event_damage_ens_vars.UNISYS_regis{6}='n_indian';
et(hObject,'String',climada_tc_event_damage_ens_vars.UNISYS_regis);
fprintf('popupmenu_region_CreateFcn\n');
 --- Executes on selection change in popupmenu_year.
<font color="blue">function popupmenu_year_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_year (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_year contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_year
et_UNISYS_name_list(hObject,eventdata,handles)
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_year_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_year (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
lobal climada_tc_event_damage_ens_vars
limada_tc_event_damage_ens_vars.UNISYS_years={}; % reset
limada_tc_event_damage_ens_vars.UNISYS_years{1}=datestr(today,'yyyy');
or year_i=1:10
   climada_tc_event_damage_ens_vars.UNISYS_years{end+1}=...
       sprintf('%i',str2double(climada_tc_event_damage_ens_vars.UNISYS_years{year_i})-1);
nd
et(hObject,'String',climada_tc_event_damage_ens_vars.UNISYS_years);
et(hObject,'Enable','off'); % first a name region to be selected
 --- Executes on selection change in popupmenu_name.
<font color="blue">function popupmenu_name_Callback(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_name (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: contents = cellstr(get(hObject,'String')) returns popupmenu_name contents as cell array
        contents{get(hObject,'Value')} returns selected item from popupmenu_name
et(handles.pushbutton_calculate,'Enable','on');
et(handles.pushbutton_calculate,'BackgroundColor','green'); % make inactive
 --- Executes during object creation, after setting all properties.
<font color="blue">function popupmenu_name_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to popupmenu_name (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: popupmenu controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
<font color="blue">function edit_ens_n_Callback(hObject, eventdata, handles) </font>
 hObject    handle to edit_ens_n (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
 Hints: get(hObject,'String') returns contents of edit_ens_n as text
        str2double(get(hObject,'String')) returns contents of edit_ens_n as a double
 --- Executes during object creation, after setting all properties.
<font color="blue">function edit_ens_n_CreateFcn(hObject, eventdata, handles) </font>
 hObject    handle to edit_ens_n (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    empty - handles not created until after all CreateFcns called
 Hint: edit controls usually have a white background on Windows.
       See ISPC and COMPUTER.
f ispc &amp&amp isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
   set(hObject,'BackgroundColor','white');
nd
 --- Executes on button press in pushbutton_calculate.
<font color="blue">function pushbutton_calculate_Callback(hObject, eventdata, handles) </font>
 hObject    handle to pushbutton_calculate (see GCBO)
 eventdata  reserved - to be defined in a future version of MATLAB
 handles    structure with handles and user data (see GUIDATA)
lobal climada_tc_event_damage_ens_vars
NISYS_regi=climada_tc_event_damage_ens_vars.UNISYS_regis{get(handles.popupmenu_region,'Value')};
NISYS_year=climada_tc_event_damage_ens_vars.UNISYS_years{get(handles.popupmenu_year,'Value')};
NISYS_name=climada_tc_event_damage_ens_vars.UNISYS_names{get(handles.popupmenu_name,'Value')};
 get rid of all clutter
NISYS_name=strrep(UNISYS_name,'Super ','');
NISYS_name=strrep(UNISYS_name,'Tropical Depression','');
NISYS_name=strrep(UNISYS_name,'Tropical Storm','');
NISYS_name=strrep(UNISYS_name,'Typhoon-1','');
NISYS_name=strrep(UNISYS_name,'Typhoon-2','');
NISYS_name=strrep(UNISYS_name,'Typhoon-3','');
NISYS_name=strrep(UNISYS_name,'Typhoon-4','');
NISYS_name=strrep(UNISYS_name,'Typhoon-5','');
NISYS_name=strrep(UNISYS_name,'Hurricane-1','');
NISYS_name=strrep(UNISYS_name,'Hurricane-2','');
NISYS_name=strrep(UNISYS_name,'Hurricane-3','');
NISYS_name=strrep(UNISYS_name,'Hurricane-4','');
NISYS_name=strrep(UNISYS_name,'Hurricane-5','');
NISYS_name=strrep(UNISYS_name,'Cyclone-1','');
NISYS_name=strrep(UNISYS_name,'Cyclone-2','');
NISYS_name=strrep(UNISYS_name,'Cyclone-3','');
NISYS_name=strrep(UNISYS_name,'Cyclone-4','');
NISYS_name=strrep(UNISYS_name,'Cyclone-5','');
NISYS_name=strrep(UNISYS_name,' ','');
NISYS_name=strrep(UNISYS_name,' ','');
ns_n=str2double(get(handles.edit_ens_n,'String'));
printf('%s %s %s - %i\n',UNISYS_regi,UNISYS_year,UNISYS_name,ens_n);
all_from_GUI.axes_left=handles.axes_left;
all_from_GUI.axes_right=handles.axes_right;
damages,~,err_msg]=climada_tc_event_damage_ens(UNISYS_regi,UNISYS_year,UNISYS_name,ens_n,call_from_GUI);
f isempty(err_msg)  &amp&amp ~isempty(damages)
   fprintf('original track: %g [USD], min/max: %g/%g\n',damages(1),min(damages),max(damages));
lse
   fprintf('%s\n',err_msg);
nd % isempty(err_msg)
<font color="blue">function get_UNISYS_name_list(hObject,eventdata,handles) </font>
 get the event names
lobal climada_tc_event_damage_ens_vars
NISYS_REGI=climada_tc_event_damage_ens_vars.UNISYS_regis{get(handles.popupmenu_region,'Value')};
NISYS_YEAR=climada_tc_event_damage_ens_vars.UNISYS_years{get(handles.popupmenu_year,'Value')};
 fetch the index of all events
rl_str=['http://weather.unisys.com/hurricane/' UNISYS_REGI '/' UNISYS_YEAR '/index.php'];
printf('fetching %s\n',url_str);
index_str,STATUS] = urlread(url_str);
f STATUS
   % kind of parse index_str to get names
   UNISYS_names={};
   for event_i=100:-1:1
       for black_red=1:2
           if black_red==1
               check_str=['&amplttr&ampgt&amplttd width=&quot20&quot align=&quotright&quot style=&quotcolor:black;&quot&ampgt' num2str(event_i) '&amplt/td&ampgt&amplttd width=&quot250&quot style=&quotcolor:black;&quot&ampgt'];
           else
               check_str=['&amplttr&ampgt&amplttd width=&quot20&quot align=&quotright&quot style=&quotcolor:red;&quot&ampgt' num2str(event_i) '&amplt/td&ampgt&amplttd width=&quot250&quot style=&quotcolor:red;&quot&ampgt'];
           end
           pos=strfind(index_str,check_str);
           if pos&ampgt0
               UNISYS_names{end+1}=index_str(pos+length(check_str):pos+length(check_str)+25);
           end
       end % black_red
   end % event_i
   set(handles.pushbutton_calculate,'Enable','off'); % first a name needs to be selected
   set(handles.pushbutton_calculate,'BackgroundColor','red'); % make inactive
lse
   UNISYS_names{1}='no web access &ampgt press Calculate button';
   set(handles.pushbutton_calculate,'Enable','on');
   set(handles.pushbutton_calculate,'BackgroundColor','green'); % make inactive
nd
limada_tc_event_damage_ens_vars.UNISYS_names=UNISYS_names;
et(handles.popupmenu_name,'String',climada_tc_event_damage_ens_vars.UNISYS_names);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_tc_event_damage_ens_gui.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_set">
<H2>climada_tc_hazard_set</H2></A>
<font color="blue">function hazard = climada_tc_hazard_set(tc_track,hazard_set_file,centroids) </font>
 climada TC hazard event set generate
 NAME:
   climada_tr_hazard_set
 PURPOSE:
   generate a tc (tropical cyclone) hazard event set

   If centroids.distance2coast_km exists, the hazard intensity is only
   calculated in the coastal_range_km (usually 200km, see PARAMETERS in
   climada_tc_windfield) - this speeds up calculation for large countries
   considerably.

   Special: the hazard event set is stored every 100 tracks in order to
   allow for interruption of the hazard set generation. Just re-start the
   calculation by calling climada_tr_hazard_set with exactly the same
   input parameters (the last track calculated is stored in hazard.track_i
   and the field track_i is removed in the final complete hazard event set).  
   Therefore, if you get errors such as 
       Subscripted assignment dimension mismatch.
       Error in climada_tr_hazard_set (line 270) % ... or nearby
       hazard.intensity(track_i,:)     = res.gust;
   It is VERY likely that you changed something between subsequent calls
   (i.e. different centroids). Just delete the hazard set .mat file and run
   climada_tr_hazard_set again.

   See climada_tc_hazard_set_slow in the tropical cyclone module 
   (https://github.com/davidnbresch/climada_module_tropical_cyclone) 
   for the old slow version (for backward compatibility).

   previous: likely climada_random_walk
   next: diverse
 CALLING SEQUENCE:
   res=climada_tr_hazard_set(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   %centroids=climada_entity_load('USA_UnitedStatesFlorida'); % works, too
   hazard=climada_tc_hazard_set(tc_track,'_TC_TEST_PARFOR',centroids);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_tc_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat). If ='NOSAVE', the hazard set is not
       saved (but returned as output)
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           lon(1,:): the longitudes
           lat(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       OR: an entity, in which case the entity.assets.lat and
       entity.assets.lon are used as centroids.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       intensity(event_i,centroid_i), sparse: the hazard intensity of 
           event_i at centroid_i
       frequency(event_i): the frequency of each event
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20090729
 david.bresch@gmail.com, 20130506, centroids filename handling improved
 david.bresch@gmail.com, 20140421, waitbar with secs
 david.bresch@gmail.com, 20141226, optional fields in centroids added
 david.bresch@gmail.com, 20150103, equal_timestep (much) improved
 muelleleh@gmail.com, 20150420, include tc category into hazard structure
 david.bresch@gmail.com, 20150804, allow for filename without path for hazard set name on input
 david.bresch@gmail.com, 20150819, climada_global.centroids_dir
 david.bresch@gmail.com, 20150824, removed 'TCNA' from hazard.comment
 david.bresch@gmail.com, 20150906, note on a frequent issue added to header
 david.bresch@gmail.com, 20151008, NOSAVE option added
 muelleleh@gmail.com, 20151127, add hazard.scenario, default is 'no climate change'
 david.bresch@gmail.com, 20160514, -v7.3 in save added
 david.bresch@gmail.com, 20160529, fast parfor version, about twenty times faster
 david.bresch@gmail.com, 20160603, header: comment added
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_tc_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_set_exercise">
<H2>climada_tc_hazard_set_exercise</H2></A>
<font color="blue">function hazard = climada_tc_hazard_set_exercise(tc_track, hazard_set_file, centroids) </font>
 climada TC hazard event set generate
 NAME:
   climada_tc_hazard_set_exercise
 PURPOSE:
   generate a tc (tropical cyclone) hazard event set

   previous: likely climada_random_walk
   next: diverse

   NOTE: code for demonstration purposes (e.g. lecture), see 
   climada_tc_windfield for the operational code

 CALLING SEQUENCE:
   res=climada_tc_hazard_set_exercise(tc_track,hazard_set_file)
 EXAMPLE:
   res=climada_tc_hazard_set_exercise(tc_track)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_tc_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes   
           Latitude(1,:): the latitudes   
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       if you select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090729
 David N. Bresch, david.bresch@gmail.com, 20120404 copy from climada_tc_hazard_set
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_tc_hazard_set_exercise.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_random_walk">
<H2>climada_tc_random_walk</H2></A>
<font color="blue">function tc_track_out=climada_tc_random_walk(tc_track,ens_size,ens_amp,Maxangle,check_plot) </font>
 TC event set random walk probabilistic
 NAME:
   climada_tc_random_walk
 PURPOSE:
   given a tc_track structure, create ens_size varied derived tracks based on
   directed random walk

   NOTE see PARAMETER section to change parameters
   (e.g. ens_amp0,ens_amp,Maxangle)

   previous step: see climada_tc_read_unisys_database
   next step: see climada_tc_hazard_set
 CALLING SEQUENCE:
   tc_track=climada_tc_random_walk(tc_track,ens_size);
 EXAMPLE:
   tc_track=climada_read_unisys_database;
   tc_track=climada_tc_random_walk(tc_track);
 INPUTS:
   tc_track: a structure with the track information for each cyclone i at
       each node j, see climada_read_unisys_database for a detailed
       description
 OPTIONAL INPUT PARAMETERS:
   ens_size: create ens_size varied derived tracks, default 9 
       (means for each original track, 9 daughter tracks are generated)
   ens_amp: amplitude of random walk wiggles in degree longitude for
       'directed', default 0.35. Be careful when changing, test with one track and plot, e.g.
       climada_tc_random_walk(tc_track(1),9,ens_amp,[],1)
   Maxangle: the angle the track direction can change for one timestep
       default=pi/7. Be careful when changing, test with one track and plot, e.g.
       climada_tc_random_walk(tc_track(1),9,[],Maxangle,1)
   check_plot: whether we show a check plot (=1) or not (=0), default=0
 OUTPUTS:
   same structure now including the ens_size times number of tracks
   all the info from the original tracks is copied, only the lat, lon
   differs
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 Markus Huber, markus.huber@env.ethz.ch, 20100412
 Omar Bellprat, mar.bellprat@env.ethz.ch, 20100412, Maxangle added as input
 David N. Bresch, david.bresch@gmail.com, 20160423, rand('seed',0) --&ampgt rng(0)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_tc_random_walk.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_read_unisys_database">
<H2>climada_tc_read_unisys_database</H2></A>
<font color="blue">function [tc_track,tc_track_hist_file]=climada_tc_read_unisys_database(unisys_file,check_plot) </font>
 TC event set track database UNISYS
 NAME:
   climada_tc_read_unisys_database
 PURPOSE:
   read UNISYS database file, raw data file to be downloaded from
   http://weather.unisys.com/hurricane/index.html (see
   climada_tc_get_unisys_databases), filter the raw data, namely:
   - a VALID record (=node) is required to have lat, lon and either pressure
     or windspeed (so recrods with only geographical information are skipped)
   - pressure [mb] needs to be in the range 800..1100, otherwise set to
     NaN, windspeeds of zero are also set to NaN
   - longitudes are converted such that east is positive and that the
     coordinates within one region (basin) are uniform, means no jump from
     180 to -180 (done based on median longitude of basin database)
   - latitudes (always North in UNISYS data) are converted for Southern
     Hemipshere datasets, if the unisys_file contains 'she' or 'bsh' in the filename
     (see parameter  convert_latitude, she: southern hemisphere, bsh: best track southern hemisphere)

   NOTE: if the binary file (see tc_track_hist_file) containing tc_track
   exists, the code just returns tc_track. This allows for recurent calls
   to the code and results in substantial speed-up.
   If the binary file (see tc_track_raw_file) exists, reading of raw
   data is skipped. This allows faster iteration iro filtering (as often
   required, since raw data contains missing and errors).
   One needs to delete the binary files to re-read the raw ASCII data.

   Wind = Maximum sustained (1 minute) surface (10m) windspeed in knots
       (in general, these are to the nearest 5 knots). 
   Pressure = Central surface pressure of storm in mb (if available).
       Since 1979, central pressures are given everytime even if a
       satellite estimation is needed.  

   More info: http://weather.unisys.com/hurricane/atlantic/tracks_atl_readme.txt

   previous step: see climada_tc_get_unisys_databases
   next step: see climada_tc_random_walk

   See also: climada_tc_hurdat_read and climada_tc_jtwc_fetch
 CALLING SEQUENCE:
   tc_track=climada_tc_read_unisys_database(unisys_file,check_plot);
 EXAMPLE:
   tc_track=climada_tc_read_unisys_database('tracks.atl.txt');
 INPUTS:
   unisys_file: the filename of the raw databse file (as downloaded from
       UNISYS), prompted for, if not given
       If no path provided, default path ../data/tc_tracks is used
   see also PARAMETERS section, especially for filters
 OPTIONAL INPUT PARAMETERS:
   check_plot: if =1, show plots, =0 not (default)
 OUTPUTS:
   tc_track: a structure with the track information for each cyclone i and
           data for each node j (times are at 00Z, 06Z, 12Z, 18Z):
       tc_track(i).lat(j): latitude at node j of cyclone i
       tc_track(i).lon(j): longitude at node j of cyclone i
       tc_track(i).MaxSustainedWind(j): Maximum sustained (1 minute)
           surface (10m) windspeed in knots (in general, these are to the nearest 5 knots).
       tc_track(i).MaxSustainedWindUnis, almost always 'kn'
           (others allowed: 'mph', 'm/s' or 'km/h')
       tc_track(i).CentralPressure(j): optional
       tc_track(i).CentralPressureUnit: 'mb'
       tc_track(i).yyyy: 4-digit year, optional
       tc_track(i).mm: month, optional
       tc_track(i).dd: day, optional
       tc_track(i).hh: hours
       tc_track(i).datenum:  matlab notation for date and time (see function datestr)
       tc_track(i).TimeStep(j)=time step [h] from this to next node
       tc_track(i).ID_no: unique ID, optional
       tc_track(i).name: name, optional
       tc_track(i).orig_event_flag: whether it is an mother(=1) or daugther(=0) storm

       Please note that a binary file of raw_data is stored (in the
       background). The raw_data is stored to ease (and speedup) re-reading the
       data. To really start from the raw text file again, please delete the
       binary file (*_raw.mat).

   tc_track_hist_file: the filename with path to the binary file
       tc_track is stored in (see NOTE above)

 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 Joeri Rogelj, jr@env.ethz.ch, 20120429 / correct time step computation
 Reto Stockmann, 20120808 / added axes labels and limits
 Lea Mueller, 20120813, added overview of years in plot and codewort 'she'
 for southern hemisphere filename
 David N. Bresch, david.bresch@gmail.com, 20140221, world border plotted on top of tracks
 David N. Bresch, david.bresch@gmail.com, 20140922 (over the Atlantic, LX016), tc_track_hist_file as output added and storing processed as mat
 David N. Bresch, david.bresch@gmail.com, 20150805, allow for unisys_file without path on input
 David N. Bresch, david.bresch@gmail.com, 20150824, made fully consistent with jtwc and hurdat
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_tc_read_unisys_database.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield">
<H2>climada_tc_windfield</H2></A>
<font color="blue">function gust = climada_tc_windfield(tc_track,centroids,~,silent_mode,~) </font>
 TC windfield calculation
 NAME:
   climada_tc_windfield
 PURPOSE:
   given a TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the wind field at locations (=centroids)

   mainly called from: see climada_tc_hazard_set

   Note: this code is optimized for speed, hence assumes that tc_track is
   free of missing data, climada_tc_equal_timestep applied and
   MaxSustainedWind calculated.

   PARFOR: this code does run with parfor, but it seems not to be faster
   at all (sine there seems to be lots of comms overhead to share tc_track
   between parallel processes) - see climada_tc_hazard_set for another
   PARFOR opportunity (we use it there, not here).

   See climada_tc_windfield_slow in the tropical cyclone module 
   (https://github.com/davidnbresch/climada_module_tropical_cyclone) 
   for the old slow version (for backward compatibility).

 CALLING SEQUENCE:
   [gust,res]=climada_tc_windfield(tc_track,centroids,~,silent_mode,~)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   tc_track=climada_tc_equal_timestep(tc_track);
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   gust=climada_tc_windfield(tc_track(68),centroids);
   climada_color_plot(gust,centroids.lon,centroids.lat);
 INPUTS:
   tc_track: a structure with the single track information (length(tc_track)!=1)
       see e.g. climada_tc_read_unisys_tc_track
       tc_track.Azimuth and/or tc_track.Celerity calculated, if not existing
       but climada_tc_equal_timestep mist have been run and
       tc_track.MaxSustainedWind must exist on input
   centroids: a structure with the centroids information (see e.g.
       climada_centroids_read):
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
   silent_mode: default=0, if =-1, use step-by-step detailed windfield,
       i.e. reduce wind to zero at center of the eye (not recommended for
       probabilistic, since hit/miss issue with closest node, see variable
       max_wind_at_bullseye in code).  
 OUTPUTS:
   gust: the windfield [m/s] at all centroids, NOT sparse for speedup
       i.e. convert like hazard.intensity()=sparse(res.gust)...
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 David N. Bresch, david.bresch@gmail.com, 20150103, not faster than climada_tc_windfield any more
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, about 20% faster than climada_tc_windfield_slow
 David N. Bresch, david.bresch@gmail.com, 20160529, only gust returned, even faster
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_tc_windfield.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield_exercise">
<H2>climada_tc_windfield_exercise</H2></A>
<font color="blue">function [res,tc_track] = climada_tc_windfield_exercise(tc_track,centroids,~,silent_mode,~) </font>
 TC windfield calculation
 NAME:
   climada_tc_windfield_exercise
 PURPOSE:
   the EXERCISE version of climada_tc_windfield, used for lecture course,
   see www.iac.ethz.ch/edu/courses/master/modules/climate-risk.html

   given a TC track (lat/lon,MaxSustainedWind), calculate
   the wind field at locations (=centroids)

   mainly called from: see climada_tc_hazard_set

   Note: this code is optimized for speed, hence assumes that tc_track is
   free of missing data, climada_tc_equal_timestep applied and
   MaxSustainedWind calculated.

   PARFOR: this code does run with parfor, but it seems not to be faster
   at all (sine there seems to be lots of comms overhead to share tc_track
   between parallel processes) - see climada_tc_hazard_set for another
   PARFOR opportunity (we use it there, not here).

   See climada_tc_windfield_slow in the tropical cyclone module 
   (https://github.com/davidnbresch/climada_module_tropical_cyclone) 
   for the old slow version (for backward compatibility).

 CALLING SEQUENCE:
   [res,tc_track]=climada_tc_windfield_exercise(tc_track,centroids,~,silent_mode,~)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   tc_track=climada_tc_equal_timestep(tc_track);
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   res=climada_tc_windfield_exercise(tc_track(68),centroids);
   climada_color_plot(res.gust,res.lon,res.lat);
 INPUTS:
   tc_track: a structure with the single track information (length(tc_track)!=1)
       see e.g. climada_tc_read_unisys_tc_track
       tc_track.Azimuth and/or tc_track.Celerity calculated, if not existing
       but climada_tc_equal_timestep mist have been run and
       tc_track.MaxSustainedWind must exist on input
   centroids: a structure with the centroids information (see e.g.
       climada_centroids_read):
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
   silent_mode: default=0, if =-1, use step-by-step detailed windfield,
       i.e. reduce wind to zero at center of the eye (not recommended for
       probabilistic, since hit/miss issue with closest node, see variable
       max_wind_at_bullseye in code).  
 OUTPUTS:
   res.gust: the windfield [m/s] at all centroids, NOT sparse for speedup
       i.e. convert like hazard.intensity()=sparse(res.gust)...
   res.lon: the longitude of the centroids (=centroids.lon)
   res.lat: the latitude of the centroids (=centroids.lat)
   res.time: the time (sec) windfield calculation used
   tc_track: provided on output, to validate added fields, such as e.g.
       Azimuth and Celerity
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 David N. Bresch, david.bresch@gmail.com, 20150103, not faster than climada_tc_windfield any more
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, about 20% faster than climada_tc_windfield_slow
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_tc_windfield_exercise.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_viewer">
<H2>climada_viewer</H2></A>
<font color="blue">function varargout = climada_viewer(varargin) </font>
 climada_viewer MATLAB code for climada_viewer.fig
      climada_viewer, by itself, creates a new climada_viewer or raises the existing
      singleton*.

      H = climada_viewer returns the handle to a new climada_viewer or the handle to
      the existing singleton*.

      climada_viewer('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in climada_viewer.M with the given input arguments.

      climada_viewer('Property','Value',...) creates a new climada_viewer or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_viewer_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_viewer_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 MODULE:
   viewer
 NAME:
   climada_viewer
 PURPOSE:
   plots entities, assets and damage
 CALLING SEQUENCE:
   climada_viewer
EXAMPLE
   climada_viewer
 INPUT:
   (all inputs are asked for by the GUI)
   entity: an entity structure, see e.g. climada_entity_load and climada_entity_read
   measures_impact: a measures_impact structure, e.g. produced by salvador_calc_measures
   type: must be specified from 'assets','benefits' and 'damage'
   unit: must be specified from 'USD' or 'people'
   timestamp: can be specified from
                  1- current state
                  2- economic growth
                  3- moderate climate change
                  4- extreme climate change
                    (default is 1)
  index_measures:  can be selected from a certain measure (see measure list in the measures_impactfile), default =1;
  categories:      Select a certain category from the list


 OUTPUTS:
   Graphical result
 OPTIONAL OUTPUTS:
   A .mat file with the current selection
   An excel with the curretn selection
   A .kmz file with the current selection
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151206, init based on climada_measure_viewer
 Lea Mueller, muellele@gmail.com, 20151209, add waterfall plot
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_viewer.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph">
<H2>climada_waterfall_graph</H2></A>
<font color="blue">function  fig = climada_waterfall_graph(EDS_today,EDS_dev,EDS_cc,return_period,check_printplot,legend_on) </font>
 NAME:
   climada_waterfall_graph
 PURPOSE:
   show waterfall plot expected damage for specific return period to
   compare
   - risk today (assets today, hazard today)
   - increase due to economic development (future assets, hazard today)
   - increase due to climate change (future assets, future hazard)

   previous call: climada_EDS_calc
 CALLING SEQUENCE:
   climada_waterfall_graph(EDS_today,EDS_dev,EDS_cc,return_period,check_printplot)
 EXAMPLE:
   climada_waterfall_graph
 INPUTS:
   EDS_today: event damage set for risk today (assets today, hazard today)
       usually generated by climada_EDS_calc
       if EDS_today is a struct with three elements, the code assumes
       EDS_today(1) to be real EDS today, EDS_today(2) to be EDS_dev and
       EDS_today(2) to be EDS_cc
       &ampgt prompted for if not provided (as saved EDS), but this is not
       recommended, as one easily mixes up EDSs.
   EDS_dev: event damage set for risk incl. econ. development (future assets, hazard today)
       &ampgt prompted for if not provided (as saved EDS), but this is not
       recommended, as one easily mixes up EDSs.
   EDS_cc: event damage set for risk incl. econ. dev. and climate change
       (future assets, future hazard)
       &ampgt prompted for if not provided (as saved EDS), but this is not
       recommended, as one easily mixes up EDSs.
 OPTIONAL INPUT PARAMETERS:
   return_period: the return period for which damages are shown, e.g. =100
       default (=9999) is annual expected damage (i.e. EDS.ED)
   check_printplot:if set to 1, figure saved, default 0.
       if =-1, avoid all the additonal labels etc (for e.g. slides)
   legend_on: if =1, show legend with entity and hazard names, default=0
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Lea Mueller, 20110622
 Martin Heynen, 20120329
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
 David N. Bresch, david.bresch@gmail.com, 20150419 try-catch for arrow plotting
 Lea Mueller, muellele@gmail.com, 20150831, integrate Value_unit from EDS_today.Value_unit
 David N. Bresch, david.bresch@gmail.com, 20150906 ED as default for return_period
 David N. Bresch, david.bresch@gmail.com, 20150906 font scale and label texts shortened
 David N. Bresch, david.bresch@gmail.com, 20150907 font scale and label texts shortened
 Lea Mueller, muellele@gmail.com, 20150930, introduce climada_digit_set
 Lea Mueller, muellele@gmail.com, 20151020, add TIV for future reference year
 Lea Mueller, muellele@gmail.com, 20151030, bugfix in climada_arrow
 Lea Mueller, muellele@gmail.com, 20151209, set no_fig=1, add legend_on=1
 David N. Bresch, david.bresch@gmail.com, 20160524, default legend_on=0, some simplifiactions
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/climada_waterfall_graph.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="git_pull">
<H2>git_pull</H2></A>
 git_pull
 just an alias for climada_git_pull(0)
limada_git_pull
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada/code/git_pull.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cam_USA_hazard_check">
<H2>cam_USA_hazard_check</H2></A>
<font color="blue">function cam_USA_hazard_check(hazard_set_file,show_plot) </font>
 batch file for CAM analysis
 NAME:
   cam_USA_hazard_check
 PURPOSE:
   check hazard set as generated in the CAM project

   restrict hazard set to 
  
 CALLING SEQUENCE:
   cam_USA_hazard_check(hazard_set_file,show_plot)
 EXAMPLE:
   cam_USA_hazard_check('USA_UnitedStates_Allstorms.ibtracs_all.v03r04_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_f.e12.FAMIPC5.ne120_g16.rcp4.5.001_10m_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_f.e13.FAMIPC5.ne120_ne120.1979_2012.001_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_f.e13.FAMIPC5.ne120_ne120.1979_2012.002_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_f.e13.FAMIPC5.ne120_ne120.1979_2012.003_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_f.e13.FAMIPC5.ne120_ne120.RCP85_2070_2099_sst3.001_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_f.e13.FAMIPC5.ne120_ne120.RCP85_2070_2099.001_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_f.e13.FAMIPC5.ne120_ne120.RCP85_2070_2099.002_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_f.e13.FAMIPC5.ne120_ne120.RCP85_2070_2099.003_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_FAMIPC5_ne120_79to05_03_omp2_10m_tracfile_TC.mat',0)
   cam_USA_hazard_check('USA_UnitedStates_FAMIPC5_ne120_2070to2100_03_omp2_10m_tracfile_TC.mat',0)
 INPUTS:
   hazard_set_file: hazard set filename
 OPTIONAL INPUT PARAMETERS:
   show_plot: if=0, only store as jpg file without showing the plot
       =1: show plot and save as jpg (default)
 OUTPUTS:
   saves jpg files, named accordingly
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 201500806, initial
 David N. Bresch, david.bresch@gmail.com, 201500807, update
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/cam_USA_hazard_check.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cam_batch">
<H2>cam_batch</H2></A>
<font color="blue">function cam_batch(basin_number,cam_dataset) </font>
 batch file for CAM analysis
 NAME:
   cam_batch
 PURPOSE:
   call climdada routines to generate cyclone tracks and loss frequency curves
  
 CALLING SEQUENCE:
   cam_batch(basin_number);
 EXAMPLE:
   cam_batch(1,['wehner'|'present_day'|'rcp45'|'rcp85']);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   basin_number: the basin numer, see climada_tc_filter_basin
       default=1 for North Atlantic
       currently, only 1 (North Atl) implemetned
 OUTPUTS:
 MODIFICATION HISTORY:  NOTE: SUPERSCEEDED BY cam_batch2.m
 Andrew Gettelman
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/cam_batch.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cam_batch2">
<H2>cam_batch2</H2></A>
<font color="blue">function cam_batch2(basin_number,cam_dataset) </font>
 batch file for CAM analysis
 NAME:
   cam_batch2
 PURPOSE:
   call climdada routines to generate cyclone tracks and loss frequency curves
  
 CALLING SEQUENCE:
   cam_batch(basin_number,cam_dataset);
 EXAMPLE:
   cam_batch(1,['wehner'|'present_day'|'rcp45'|'rcp85']);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   basin_number: the basin numer, see climada_tc_filter_basin
       default=1 for North Atlantic
       currently, only 1 (North Atl) implemetned
   cam_dataset: ['wehner'|'present_day'|'rcp45'|'rcp85']
 OUTPUTS:
 MODIFICATION HISTORY:
 Andrew Gettelman May 5 2014: based on cam_batch.m  code for original (2012) climada
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/cam_batch2.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cam_batch_multi">
<H2>cam_batch_multi</H2></A>
<font color="blue">function cam_batch_multi(basin_number) </font>
 batch file for CAM analysis
 NAME:
   cam_batch
 PURPOSE:
   call climdada routines to generate cyclone tracks and loss frequency curves
  
 CALLING SEQUENCE:
   cam_batch_multi(basin_number);
 EXAMPLE:
   cam_batch_multi(1);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   basin_number: the basin numer, see climada_tc_filter_basin
       default=1 for North Atlantic
       currently, only 1 (North Atl) implemetned
 OUTPUTS:
 MODIFICATION HISTORY:
 Andrew Gettelman  May 5, 2014
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/cam_batch_multi.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cam_calibrate">
<H2>cam_calibrate</H2></A>
<font color="blue">function cam_calibrate(method,entity_file,hazard) </font>
 climada CAM calibrate damagefunction
 MODULE:
   CAM
 NAME:
   cam_calibrate
 PURPOSE:
   Calibrate damagefunctions for CAM project

   In essence, calc EDS and compare with EM-DAT for the country as in the
   entity. At the moment, only TC (wind) is implemented, only the
   damagefunction definition is peril-dependent, see code below (search
   for PERIL EDIT).

   Standard use: run once with method=0 (checks USA) then run with method=2
   By providing any other 3-digit country ISO code, you can check any
   country by comparison with EM-DAT (see also emdat_read)
   You can check any entitie's damage function(s) with climada_damagefunctions_plot

   Previous call: country_risk_calc('USA',-3) % as for method=0 USA entity
       and TC hazard event set need to exist
 CALLING SEQUENCE:
   cam_calibrate(method,entity_file,hazard)
 EXAMPLE:
   country_risk_calc('USA',-3) % only in case you do not have an entity and hazard set already
   cam_calibrate(0,'USA') % check USA
   cam_calibrate(1,'JPN') % check and save Japan
   cam_calibrate(2,'USA','TC') % calibrate all entities
 INPUTS:
   method: =0 (default), run the calibration for the country as in the entity,
       show results, but do NOT update the damagefunction in the entity
       set =-1 to also show the plot (if=0, the plot is only saved)
       =1: DO update the damagefunction in the entity (i.e. save the
       calibrated damagefunction to the entity) - but do NOT check again
       (use method=0 for this)
       =2: update the damagefunctions in ALL entities. BE CAREFUL, this
       truly OVERWRITES the damagefunctions in ALL entities.
       If run without Xwindows, please pass hazard='TC' in this case
 OPTIONAL INPUT PARAMETERS:
   entity_file: the entity file with assets (today) to be used for calibration
       OR just the 3-digit country code, such as 'USA' - in this case, the
       code also tries to get the hazard filename from entity
       If a filename is given, it needs to be an entity file (with path) NOT entity structure
       &ampgt prompts for file if not given
   hazard: the hzard event set
       Either a hazard set file (with path) or a hazard structure
       &ampgt prompts for file if not given
 OUTPUTS:
   plot, as figure stored to .../results/cam_calibrate_{ISO3}_{peril_ID}.png
       (just saved, not shown, unless method=-1)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150307, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/cam_calibrate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cam_entity_value_GDP_SSP">
<H2>cam_entity_value_GDP_SSP</H2></A>
<font color="blue">function entity=cam_entity_value_GDP_SSP(entity_file_regexp,target_year,SSP_version) </font>
 scale up asset values
 MODULE:
   CAM
 NAME:
   cam_entity_value_GDP_SSP
 PURPOSE:
   A copy of the original climada_entity_value_GDP_adjust for the CAM
   module. Calls cam_entity_value_GDP_SSP_one, see there for details

   Scale up asset values based on a country's estimated total asset value.

   We first normalize the asset values, then multiply by GDP_value and a
   scale_up_factor based on income group. GDP_value comes from the SSP
   data file (see SSP_data_file in PARAMETER section in code), the
   scale_up_factor from economic_data_file (see PARAMETER section in code)

   Prior calls: e.g. climada_nightlight_entity, country_risk_calc
   Next calls: e.g. country_risk_calc
 CALLING SEQUENCE:
   entity=cam_entity_value_GDP_SSP(entity_file_regexp,target_year,SSP_version)
 EXAMPLE:
   cam_entity_value_GDP_SSP('*_future.mat',2035) % all future for 2035
   cam_entity_value_GDP_SSP('*_*_entity.mat',2015); % all today for 2015
 INPUT:
   entity_file_regexp: the full filename of the entity to be scaled up
       or a regexp expression, e.g. for all entities:
       entity_file_regexp=[climada_global.data_dir filesep 'entities' filesep '*.mat']
       or just a regexp to be evaluated within ../data/entities, such as
       e.g. entity_file_regexp='*future.mat';
 OPTIONAL INPUT PARAMETERS:
   target_year: the year we would like to get the GDP estimates for
       Default=2035, see SSP data file for possible years
   SSP_version: the SSP 3 or 5, hence either 'Ssp3Db' or 'Ssp5Db'. In fact
       this is the name of the tab within the Excel file we read, hence the
       user could also define a new one. Default 'Ssp3Db'
 OUTPUTS:
   entity: entity with adjusted asset values, also stored as .mat file 
   (only last entity if entity_file_regexp covers more than one)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150227, initial
 David N. Bresch, david.bresch@gmail.com, 20150228, finished
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/cam_entity_value_GDP_SSP.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cam_entity_value_GDP_SSP_one">
<H2>cam_entity_value_GDP_SSP_one</H2></A>
<font color="blue">function [entity,ok]=cam_entity_value_GDP_SSP_one(entity,target_year,SSP_version) </font>
 scale up asset values GDP
 MODULE:
   CAM
 NAME:
   cam_entity_value_GDP_SSP_one
 PURPOSE:
   A copy of the original climada_entity_value_GDP_adjust_one for the CAM
   module. Usually called from cam_entity_value_GDP_SSP (which treats a
   series of entities)

   Scale up asset values based on a country's estimated total asset value,
   based on an SSP scenario (SSP_version) and for a target year.

   We first normalize the asset values, then multiply by GDP*PPP*SCL, where
   - GDP comes from the SSP data file, either the Ssp3Db or Ssp5Db tab as
     specified by SSP_version and the column as specified by target_year
     (see SSP_data_file in PARAMETER section in code)
   - PPP, the purchase power parity conversion comes from tab &quotconversion
     rate&quot in SSP_data_file (in PARAMETER section in code)
   - SCL, the scale_up_factor based on income group comes from the core
     climada economic_data_file (see PARAMETER section in code)

   Caution: as soon as the entity has a field entity.assets.admin0_ISO3

   Note: to avoid any troubles, entity.assets.Cover is set equal to entity.assets.Value

   Prior calls: e.g. climada_nightlight_entity, country_risk_calc
   Next calls: e.g. country_risk_calc
 CALLING SEQUENCE:
   entity=cam_entity_value_GDP_SSP_one(entity,target_year,SSP_version)
 EXAMPLE:
   entity=cam_entity_value_GDP_SSP_one(entity,2035,'Ssp3Db')
 INPUT:
   entity: an entity structure, see e.g. climada_entity_load and
       climada_entity_read
 OPTIONAL INPUT PARAMETERS:
   target_year: the year we would like to get the GDP estimates for
       Default=2035, see SSP data file for possible years
   SSP_version: the SSP 3 or 5, hence either 'Ssp3Db' or 'Ssp5Db'. In fact
       this is the name of the tab within the Excel file we read, hence the
       user could also define a new one. Default 'Ssp3Db'
 OUTPUTS:
   entity: on output the entity as on inpit, with adjusted asset values,
       i.e. the sum(entity.assets.Value) now equals GDP*PPP*SCL
       The print statement to stdout does list the factors and states the
       matching ISO3 code for security checks, i.e. would they not all be
       the same (the requested country), there might either be double
       entries in tables or problems elsewhere.
   ok: =1, if successfully scaled, =0 if not
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150227, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/cam_entity_value_GDP_SSP_one.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_analyze_cam">
<H2>climada_tc_analyze_cam</H2></A>
<font color="blue">function climada_tc_analyze_cam(basin_number,cam_dataset) </font>
 climada
 NAME:
   climada_tc_analyze_cam
 PURPOSE:
   analyze CAM tracks for one basin

   present code reads all UNISYS and CAM data automatically, 
   but please see climada_tc_read_cam_database for details
 CALLING SEQUENCE:
   climada_tc_analyze_cam(basin_number,cam_dataset);
 EXAMPLE:
   climada_tc_analyze_cam(1,['wehner'|'present_day'|'rcp45'|'rcp85']);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   basin_number: the basin numer, see climada_tc_filter_basin
       default=1 for North Atlantic
       currently, only 1 (North Atl) and 3 (West Pacific) are implemented
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120406, 20120407, 20120416
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/climada_tc_analyze_cam.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_analyze_cam_all">
<H2>climada_tc_analyze_cam_all</H2></A>
<font color="blue">function climada_tc_analyze_cam_all(basin_number,cam_dataset) </font>
 climada
 NAME:
   climada_tc_analyze_cam
 PURPOSE:
   analyze CAM tracks for one basin

   present code reads all UNISYS and CAM data automatically, 
   but please see climada_tc_read_cam_database for details
 CALLING SEQUENCE:
   climada_tc_analyze_cam(basin_number,cam_dataset);
 EXAMPLE:
   climada_tc_analyze_cam(1,['wehner'|'present_day'|'rcp45'|'rcp85']);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   basin_number: the basin numer, see climada_tc_filter_basin
       default=1 for North Atlantic
       1 (North Atl) 
       3 (West Pacific) are implemented
       5 (N. Indian)
       4 (S. Hemisphere (indian &amp Pac)
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120406, 20120407, 20120416
 Andrew Gettelman: added other regions (20140512)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/climada_tc_analyze_cam_all.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_filter_basin">
<H2>climada_tc_filter_basin</H2></A>
<font color="blue">function tc_track_basin=climada_tc_filter_basin(tc_track,basin_number) </font>
 This function determines the ocean basin of storm tracks in
 structure tc_track.

 NAME:
   climada_tc_filter_basin
 PURPOSE:
   Catagorize storms in 5 different ocean basins
   (North Atlantic, South Atlantic, North Pacific, South Pacific,
   Indian Ocean). Only necessary if global data used as allocated
   in climada_tc_read_gfdl_database.m. The function reduces the
   structure to the specified basin and modifies the ID_no.

   previous call: climada_tc_read_cam_database
 CALLING SEQUENCE:
   tc_track_out=climada_tc_filter_basin(tc_track,basin);
 EXAMPLE:
   tc_track_natl=climada_tc_read_gfdl_database(tc_track,1);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/climada_tc_filter_basin.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_read_cam_IBTrAC_V01">
<H2>climada_tc_read_cam_IBTrAC_V01</H2></A>
<font color="blue">function tc_track=climada_tc_read_cam_ibtrac_v01(ibtrac_file,starty,endy) </font>
 TC tracks from a CAM high resolution simulation.
 NAME:
   climada_tc_read_cam_ibtrac_v01
 PURPOSE:
   read storm track data from an IBTrAC style netcdf file stored in
   ...climada_additional/CAM/data/track_data_V01
   Data provided by A.Gettleman (andrew.gettelman@env.ethz.ch)

   Note the V01, since there is a newer data format, you might also
   consider using climada_tc_read_cam_database instead

   filter the raw data, namely:
   - a VALID record (=node) is required to have lat, lon and either pressure
     or windspeed (so recrods with only geographical information are skipped)
   - pressure [mb] needs to be in the range 800..1100, otherwise set to
     NaN, windspeeds of zero are also set to NaN
   - longitudes are converted such that east is positive.

   Tracks were  derived with a CAM cyclone tracking algorithm
   developed by Julio Bachmeister.

   NOTE: THIS IS THE FIRST VERSION (V01)

   next step: see climada_tc_filter_basin and then climada_tc_random_walk
 CALLING SEQUENCE:
   tc_track=climada_tc_read_cam_ibtrac_v01(ibtrac_file,starty,endy);
 EXAMPLE:
   tc_track=climada_tc_read_cam_ibtrac_v01(ibtrac_file,1980,2000);
 INPUTS:
   netcdf IBTrAC style file 
       ..climada_additional/data/tc_track/cam
 OPTIONAL INPUT PARAMETERS:
   ibtrac_file: the directory where the CAM data resides (sub-folders with
       year), inside each one file traj_out.txt
       -&ampgt prompted for if not given or passed empty
   starty: the first year (yyyy) of the data to be processed, default
       first sub-folder in ibtrac_file
   endy: the last year (yyyy) of the data to be processed, default
       last sub-folder in ibtrac_file
 OUTPUTS:
   tc_track: a structure with the track information for each cyclone i and
           data for each node j (times are at 00Z, 06Z, 12Z, 18Z):
       tc_track(i).lat(j): latitude at node j of cyclone i
       tc_track(i).lon(j): longitude at node j of cyclone i
       tc_track(i).MaxSustainedWind(j): Maximum sustained (1 minute)
           surface (10m) windspeed in knots (in general, these are to the nearest 5 knots).
       tc_track(i).MaxSustainedWindUnis, almost always 'kn'
           (others allowed: 'mph', 'm/s' or 'km/h')
       tc_track(i).CentralPressure(j): optional
       tc_track(i).CentralPressureUnit: 'mb'
       tc_track(i).yyyy: 4-digit year, optional
       tc_track(i).mm: month, optional
       tc_track(i).dd: day, optional
       tc_track(i).hh: hours
       tc_track(i).datenum:  matlab notation for dat: yyyy,mm,dd,hh
       tc_track(i).TimeStep(j)=time step [h] from this to next node
       tc_track(i).ID_no: unique ID, optional
       tc_track(i).name: name, optional
       tc_track(i).orig_event_flag: whether it is an mother(=1) or daugther(=0) storm

   Save the output tc_track manually (using save) if needed. 

 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120329
 David N. Bresch, david.bresch@gmail.com, 20121024, moved into a module: CAM
 David N. Bresch, david.bresch@gmail.com, 20121026, checked V01
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/climada_tc_read_cam_IBTrAC_V01.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_read_cam_database">
<H2>climada_tc_read_cam_database</H2></A>
<font color="blue">function tc_track=climada_tc_read_cam_database(cam_data_dir,starty,endy) </font>
 TC tracks from a CAM high resolution simulation.
 NAME:
   climada_tc_read_cam_database
 PURPOSE:
   Tracks were  derived with a CAM cyclone tracking algorithm
   http://vis.lbl.gov/~romano/climate/tropicalstorms.html

   read storm track data from annual text files stored in ..CAM/data/track_data/.
   Data provided by A.Gettleman (andrew.gettelman@env.ethz.ch)

   Note that there is a previous version, the V01, in an old data format,
   you might also consider using climada_tc_read_cam_database_V01 instead

   filter the raw data, namely:
   - a VALID record (=node) is required to have lat, lon and either pressure
     or windspeed (so recrods with only geographical information are skipped)
   - pressure [mb] needs to be in the range 800..1100, otherwise set to
     NaN, windspeeds of zero are also set to NaN
   - longitudes are converted such that east is positive.

   next step: see climada_tc_filter_basin and then climada_tc_random_walk
 CALLING SEQUENCE:
   tc_track=climada_tc_read_cam_database(starty,endy);
 EXAMPLE:
   tc_track=climada_tc_read_cam_database(1980,2000);
 INPUTS:
   Text files must be stored in sub-folders (one for each year) in
       ..climada_additional/data/tc_track/cam
 OPTIONAL INPUT PARAMETERS:
   cam_data_dir: the directory where the CAM data resides (sub-folders with
       year), inside each one file traj_out.txt
       -&ampgt prompted for if not given or passed empty
   starty: the first year (yyyy) of the data to be processed, default
       first sub-folder in cam_data_dir
   endy: the last year (yyyy) of the data to be processed, default
       last sub-folder in cam_data_dir
 OUTPUTS:
   tc_track: a structure with the track information for each cyclone i and
           data for each node j (times are at 00Z, 06Z, 12Z, 18Z):
       tc_track(i).lat(j): latitude at node j of cyclone i
       tc_track(i).lon(j): longitude at node j of cyclone i
       tc_track(i).MaxSustainedWind(j): Maximum sustained (1 minute)
           surface (10m) windspeed in knots (in general, these are to the nearest 5 knots).
       tc_track(i).MaxSustainedWindUnis, almost always 'kn'
           (others allowed: 'mph', 'm/s' or 'km/h')
       tc_track(i).CentralPressure(j): optional
       tc_track(i).CentralPressureUnit: 'mb'
       tc_track(i).yyyy: 4-digit year, optional
       tc_track(i).mm: month, optional
       tc_track(i).dd: day, optional
       tc_track(i).hh: hours
       tc_track(i).datenum:  matlab notation for dat: yyyy,mm,dd,hh
       tc_track(i).TimeStep(j)=time step [h] from this to next node
       tc_track(i).ID_no: unique ID, optional
       tc_track(i).name: name, optional
       tc_track(i).orig_event_flag: whether it is an mother(=1) or daugther(=0) storm

   Save the output tc_track manually (using save) if needed.

 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120329
 David N. Bresch, david.bresch@gmail.com, 20121024, moved into a module: CAM
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/climada_tc_read_cam_database.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_read_cam_database_V01">
<H2>climada_tc_read_cam_database_V01</H2></A>
<font color="blue">function tc_track=climada_tc_read_cam_database_V01(cam_data_dir,starty,endy) </font>
 TC tracks from a CAM high resolution simulation.
 NAME:
   climada_tc_read_cam_database
 PURPOSE:
   read storm track data from annual text files stored in
   ...climada_additional/CAM/data/track_data_V01
   Data provided by A.Gettleman (andrew.gettelman@env.ethz.ch)

   Note the V01, since there is a newer data format, you might also
   consider using climada_tc_read_cam_database instead

   filter the raw data, namely:
   - a VALID record (=node) is required to have lat, lon and either pressure
     or windspeed (so recrods with only geographical information are skipped)
   - pressure [mb] needs to be in the range 800..1100, otherwise set to
     NaN, windspeeds of zero are also set to NaN
   - longitudes are converted such that east is positive.

   Tracks were  derived with a CAM cyclone tracking algorithm
   http://vis.lbl.gov/~romano/climate/tropicalstorms.html

   NOTE: THIS IS THE FIRST VERSION (V01), there is a newer code, see
   climada_tc_read_cam_database.m

   next step: see climada_tc_filter_basin and then climada_tc_random_walk
 CALLING SEQUENCE:
   tc_track=climada_tc_read_cam_database_V01(cam_data_dir,starty,endy);
 EXAMPLE:
   tc_track=climada_tc_read_cam_database_V01(cam_data_dir,1980,2000);
 INPUTS:
   Text files must be stored in sub-folders (one for each year) in
       ..climada_additional/data/tc_track/cam
 OPTIONAL INPUT PARAMETERS:
   cam_data_dir: the directory where the CAM data resides (sub-folders with
       year), inside each one file traj_out.txt
       -&ampgt prompted for if not given or passed empty
   starty: the first year (yyyy) of the data to be processed, default
       first sub-folder in cam_data_dir
   endy: the last year (yyyy) of the data to be processed, default
       last sub-folder in cam_data_dir
 OUTPUTS:
   tc_track: a structure with the track information for each cyclone i and
           data for each node j (times are at 00Z, 06Z, 12Z, 18Z):
       tc_track(i).lat(j): latitude at node j of cyclone i
       tc_track(i).lon(j): longitude at node j of cyclone i
       tc_track(i).MaxSustainedWind(j): Maximum sustained (1 minute)
           surface (10m) windspeed in knots (in general, these are to the nearest 5 knots).
       tc_track(i).MaxSustainedWindUnis, almost always 'kn'
           (others allowed: 'mph', 'm/s' or 'km/h')
       tc_track(i).CentralPressure(j): optional
       tc_track(i).CentralPressureUnit: 'mb'
       tc_track(i).yyyy: 4-digit year, optional
       tc_track(i).mm: month, optional
       tc_track(i).dd: day, optional
       tc_track(i).hh: hours
       tc_track(i).datenum:  matlab notation for dat: yyyy,mm,dd,hh
       tc_track(i).TimeStep(j)=time step [h] from this to next node
       tc_track(i).ID_no: unique ID, optional
       tc_track(i).name: name, optional
       tc_track(i).orig_event_flag: whether it is an mother(=1) or daugther(=0) storm

   Save the output tc_track manually (using save) if needed. 

 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120329
 David N. Bresch, david.bresch@gmail.com, 20121024, moved into a module: CAM
 David N. Bresch, david.bresch@gmail.com, 20121026, checked V01
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/climada_tc_read_cam_database_V01.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_read_cam_database_V02">
<H2>climada_tc_read_cam_database_V02</H2></A>
<font color="blue">function tc_track=climada_tc_read_cam_database_V01(cam_data_dir,starty,endy) </font>
 TC tracks from a CAM high resolution simulation.
 NAME:
   climada_tc_read_cam_database
 PURPOSE:
   read storm track data from annual text files stored in
   ...climada_additional/CAM/data/track_data_V01
   Data provided by A.Gettleman (andrew.gettelman@env.ethz.ch)

   Note the V01, since there is a newer data format, you might also
   consider using climada_tc_read_cam_database instead

   filter the raw data, namely:
   - a VALID record (=node) is required to have lat, lon and either pressure
     or windspeed (so recrods with only geographical information are skipped)
   - pressure [mb] needs to be in the range 800..1100, otherwise set to
     NaN, windspeeds of zero are also set to NaN
   - longitudes are converted such that east is positive.

   Tracks were  derived with a CAM cyclone tracking algorithm
   http://vis.lbl.gov/~romano/climate/tropicalstorms.html

   NOTE: THIS IS THE FIRST VERSION (V01), there is a newer code, see
   climada_tc_read_cam_database.m

   next step: see climada_tc_filter_basin and then climada_tc_random_walk
 CALLING SEQUENCE:
   tc_track=climada_tc_read_cam_database_V01(cam_data_dir,starty,endy);
 EXAMPLE:
   tc_track=climada_tc_read_cam_database_V01(cam_data_dir,1980,2000);
 INPUTS:
   Text files must be stored in sub-folders (one for each year) in
       ..climada_additional/data/tc_track/cam
 OPTIONAL INPUT PARAMETERS:
   cam_data_dir: the directory where the CAM data resides (sub-folders with
       year), inside each one file traj_out.txt
       -&ampgt prompted for if not given or passed empty
   starty: the first year (yyyy) of the data to be processed, default
       first sub-folder in cam_data_dir
   endy: the last year (yyyy) of the data to be processed, default
       last sub-folder in cam_data_dir
 OUTPUTS:
   tc_track: a structure with the track information for each cyclone i and
           data for each node j (times are at 00Z, 06Z, 12Z, 18Z):
       tc_track(i).lat(j): latitude at node j of cyclone i
       tc_track(i).lon(j): longitude at node j of cyclone i
       tc_track(i).MaxSustainedWind(j): Maximum sustained (1 minute)
           surface (10m) windspeed in knots (in general, these are to the nearest 5 knots).
       tc_track(i).MaxSustainedWindUnis, almost always 'kn'
           (others allowed: 'mph', 'm/s' or 'km/h')
       tc_track(i).CentralPressure(j): optional
       tc_track(i).CentralPressureUnit: 'mb'
       tc_track(i).yyyy: 4-digit year, optional
       tc_track(i).mm: month, optional
       tc_track(i).dd: day, optional
       tc_track(i).hh: hours
       tc_track(i).datenum:  matlab notation for dat: yyyy,mm,dd,hh
       tc_track(i).TimeStep(j)=time step [h] from this to next node
       tc_track(i).ID_no: unique ID, optional
       tc_track(i).name: name, optional
       tc_track(i).orig_event_flag: whether it is an mother(=1) or daugther(=0) storm

   Save the output tc_track manually (using save) if needed. 

 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20120329
 David N. Bresch, david.bresch@gmail.com, 20121024, moved into a module: CAM
 David N. Bresch, david.bresch@gmail.com, 20121026, checked V01
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/climada_tc_read_cam_database_V02.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_read_cam_ibtrac_v02">
<H2>climada_tc_read_cam_ibtrac_v02</H2></A>
<font color="blue">function [tc_track,tc_track_hist_file]=climada_tc_read_cam_ibtrac_v02(ibtrac_file,check_plot) </font>
 TC tracks from a CAM high resolution simulation.
 NAME:
   climada_tc_read_cam_ibtrac_v01
 PURPOSE:
   read storm track data from an IBTrAC style netcdf file stored in
   ...climada_additional/CAM/data/track_data_V01
   Data provided by A.Gettleman (andrew.gettelman@env.ethz.ch)

   Note the V01, since there is a newer data format, you might also
   consider using climada_tc_read_cam_database instead

   filter the raw data, namely:
   - a VALID record (=node) is required to have lat, lon and either pressure
     or windspeed (so recrods with only geographical information are skipped)
   - pressure [mb] needs to be in the range 800..1100, otherwise set to
     NaN, windspeeds of zero are also set to NaN
   - longitudes are converted such that east is positive.

   Tracks were  derived with a CAM cyclone tracking algorithm
   developed by Julio Bachmeister.

   NOTE: THIS IS THE FIRST VERSION (V01)

   next step: see climada_tc_filter_basin and then climada_tc_random_walk
 CALLING SEQUENCE:
   tc_track=climada_tc_read_cam_ibtrac_v01(ibtrac_file,starty,endy);
 EXAMPLE:
   tc_track=climada_tc_read_cam_ibtrac_v01(ibtrac_file,1980,2000);
 INPUTS:
   netcdf IBTrAC style file
       ..climada_additional/data/tc_track/cam
 INPUTS:
   ibtrac_file: the filename of the ibtrac style cam cyclone file
   see also PARAMETERS section, especially for filters
 OPTIONAL INPUT PARAMETERS:
   check_plot: if =1, show plots, =0 not (default)
       Note that check_plot only makes sense on first call, as 2nd time,
       the data is restored from the .mat file, not read from netCDF again
 OUTPUTS:
   tc_track: a structure with the track information for each cyclone i and
           data for each node j (times are at 00Z, 06Z, 12Z, 18Z):
       tc_track(i).lat(j): latitude at node j of cyclone i
       tc_track(i).lon(j): longitude at node j of cyclone i
       tc_track(i).MaxSustainedWind(j): Maximum sustained (1 minute)
           surface (10m) windspeed in knots (in general, these are to the nearest 5 knots).
       tc_track(i).MaxSustainedWindUnis, almost always 'kn'
           (others allowed: 'mph', 'm/s' or 'km/h')
       tc_track(i).CentralPressure(j): optional
       tc_track(i).CentralPressureUnit: 'mb'
       tc_track(i).yyyy: 4-digit year, optional
       tc_track(i).mm: month, optional
       tc_track(i).dd: day, optional
       tc_track(i).hh: hours
       tc_track(i).datenum:  matlab notation for dat: yyyy,mm,dd,hh
       tc_track(i).TimeStep(j)=time step [h] from this to next node
       tc_track(i).ID_no: unique ID, optional
       tc_track(i).name: name, optional
       tc_track(i).orig_event_flag: whether it is an mother(=1) or daugther(=0) storm

   tc_track_hist_file: the filename with path to the binary file
       tc_track is stored in.

 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150128, _prob renamed to _hist
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/climada_tc_read_cam_ibtrac_v02.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="selected_countries_CAM">
<H2>selected_countries_CAM</H2></A>
 selected_countries_CAM
 climada batch code
 MODULE:
   CAM
 NAME:
   selected_countries_CAM
 PURPOSE:
   Run all CAM project countries, all calculations

   run this code (see PARAMETERS)
   - first with  check_country_names=1;
     &ampgt checks for country list being ok
   - second check_country_names=0
     &ampgt generates all entities (the assets) and hazard event sets and
     calculates damages
   - subsequent calls just repeat the damage calculations (unless you set
     country_risk_calc_force_recalc=1). Thus if you repeat the second step,
     since all hazard sets are stored, it will be fast and easy to play with
     parameters (e.g. damage functions).

   SPECIAL: in order to process CAM files only, the global variable
   climada_global.tc.default_raw_data_ext is set to '.nc' to avoid
   processing the UNISYS ('.txt') files in tc_track, see also code
   centroids_generate_hazard_sets

   In order to TEST this code before having all the netCDF track files
   ready, just set climada_global.tc.default_raw_data_ext='.txt', which
   runs all using UNISYS track data - and produces kind of comparison
   results.

   run as a batch code, such that all is available on command line, all
   PARAMETERS are set in this file, see section below

 CALLING SEQUENCE:
   selected_countries_CAM % a batch code
 EXAMPLE:
   selected_countries_CAM % a batch code
 INPUTS:
   see PARAMETERS in this batch code
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150203, initial (on ICE to Paris)
 David N. Bresch, david.bresch@gmail.com, 20150206, tested, ok
 David N. Bresch, david.bresch@gmail.com, 20150228, tested including asset scaling, ok
 David N. Bresch, david.bresch@gmail.com, 20150301, country liost reduced to SSP listed ones
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/CAM/code/selected_countries_CAM.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EASI_write">
<H2>climada_EASI_write</H2></A>
<font color="blue">function climada_EASI_write(EASI_filename,entity,Peril_name) </font>
 climada
 NAME:
   climada_EASI_write
 PURPOSE:
   Write the assets of an entity into an EASI compatible format (as Excel)

   If possible, writes to an EASI file (if one selects an existing one).
   If troubles, the code writes just Latitude, Longitude and Value in a
   plain .csv file (the user will then have to transfer into an EASI).

   Please note that Site Deductible and COver are not written to the EASI
   file, but one can uncomment the respective sections in the code (it
   looks like the numbers get to EASI as percentage...)

   See also climada_DFC_compare
 CALLING SEQUENCE:
   climada_EASI_write(EASI_filename,entity)
 EXAMPLE:
   climada_EASI_write
 INPUTS:
   EASI_filename: the filename of an EASI Excel file
       &ampgt promted for if not given
   entity: an entity (see climada_entity_read)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   Peril_name: the peril name as used in EASI, e.g.
       WW for (European) winter storm (default)
       ES for earthquake shock
       EF for earthquake fire following
       ET for for earthquake tsunami
       TW for tropical cyclone wind
       TS for tropical cyclone surge
       TR for tropical cyclone rain
       FR for river flood
       CT for convective storms hail/tornado
       and mutiple ones comma (and one space) separated, such as:
       'ES, EF, ET' or 'TW, TS, TR'
 OUTPUTS:
   write the entity.asset information into the EASI Excel file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141207
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_EASI/code/climada_EASI_write.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_EASI_compare">
<H2>winterstorm_EASI_compare</H2></A>
<font color="blue">function winterstorm_EASI_compare </font>
 climada
 MODULE:
   EASI
 NAME:
   winterstorm_EASI_compare
 PURPOSE:
   Compare climada results (EDS and hence DFC) with EASI results

   Best option so far:
   WS blended, WS damage function (damage_function_i=3,EDS_multiplier=2,frequency_screw=1)
   and obviously closest match with reference (and EDS_multiplier=1.5)
   this justifies a bit of a multiplier

   All PARAMETERS set in code
 CALLING SEQUENCE:
   winterstorm_EASI_compare
 EXAMPLE:
   winterstorm_EASI_compare
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141212, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_EASI/code/winterstorm_EASI_compare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="Barbados_test">
<H2>Barbados_test</H2></A>
 Barbados_test
 special code to TEST all with Barbados
 Purpose:
 genersate an entity with fine grid on land (for assets) and coarse around
 (as provided by climada_create_GDP_entity)

lobal climada_global
limada_global.present_reference_year=2009;
limada_global.future_reference_year =2030;
 PARAMETERS

limada_global.font_scale=2; % bigger labels on plots
 NOTE: this factor is applied to waterfall, then set =1 for adaptation
 cost curve (looks small on screen, but OK for saved plots)

entroids.admin0_name='Barbados';
entroids.admin0_ISO3='BRB';
entroids.comment='manually generated (Barbados_test)';
DP=4224850000;
ncome_group=4;
 set to =[] to start with, but later useful to draw all adaptation cost
 curves in exact same axes
ost_curve_x_axis_max=3e9; % default=[];
ost_curve_y_axis_max=4; % default=[];
 for a first go, set all switches indicated by ++++++ to one

enerate_entity_and_centroids=0; % ++++++
entroids_file=[climada_global.data_dir filesep 'centroids' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_centroids.mat'];
igh_res_entity_file=[climada_global.data_dir filesep 'entities' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_entity_1km.mat'];
erged_entity_file=[climada_global.data_dir filesep 'entities' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_entity.mat'];
uture_entity_file=[climada_global.data_dir filesep 'entities' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_entity_future.mat'];

alibrate_damagefunction=1; % to get close to CCRIF values (well, CCRIF study excessively high DFC...)

c_track_file=[climada_global.data_dir filesep 'tc_tracks' filesep 'tracks.atl_prob.mat'];
azard_set_file=[climada_global.data_dir filesep 'hazards' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_atl_TC.mat'];
azard_set_file_CC_mod=[climada_global.data_dir filesep 'hazards' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_atl_TC_CCmod.mat'];
azard_set_file_CC_hig=[climada_global.data_dir filesep 'hazards' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_atl_TC_CChig.mat'];
_screw_mod=1.0;i_screw_mod=1.02;
_screw_hig=1.0;i_screw_hig=1.055;

alculate_EDS=0; % to compare with CCRIF DFC

how_waterfall=0; % ++++++

how_adaptation_cost_curve=1; % ++++++
ompare_mod=1; % ++++++ (only works if show_adaptation_cost_curve=1)
ompare_TC_hurdat=1; % ++++++ (only works if show_adaptation_cost_curve=1)
c_track_file_HURDAT=[climada_global.data_dir filesep 'tc_tracks' filesep 'hurdat' filesep 'hurdat2-1851-2014-060415_hist.mat'];
azard_set_file_HURDAT=[climada_global.data_dir filesep 'hazards' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_atl_TC_HURDAT.mat'];
azard_set_file_CC_mod_HURDAT=[climada_global.data_dir filesep 'hazards' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_atl_TC_CCmod_HURDAT.mat'];
azard_set_file_CC_hig_HURDAT=[climada_global.data_dir filesep 'hazards' filesep centroids.admin0_ISO3 '_' centroids.admin0_name '_atl_TC_CChig_HURDAT.mat'];

ompare_discounting=1;
iscount_rate=0.05; % in decimal, i.e. 0.05 is 5% annual discount rate
daptation_event_view=0;
reate_animation=0;
nim_tc_track_file=[climada_global.data_dir filesep 'tc_tracks' filesep '20071116_SIDR_track.dat'];
nim_entity_file=[climada_global.data_dir filesep 'entities' filesep 'BGD_Bangladesh_entity.mat'];
nimation_data_file=[climada_global.data_dir filesep 'results' filesep 'animation_data.mat'];
nimation_mp4_file=[climada_global.data_dir filesep 'results' filesep 'BGD_SIDR.mp4'];
reate_HR_animation=0;
anim_tc_track_HR_file=[climada_global.data_dir filesep 'tc_tracks' filesep '20071115_SIDR_track_HR.dat'];
nim_tc_track_HR_file=anim_tc_track_file;
nim_entity_HR_country='Bangladesh';
nim_entity_HR_file=[climada_global.data_dir filesep 'entities' filesep 'BGD_' anim_entity_HR_country '_HR_entity.mat'];
nim_centroids_HR_file=[climada_global.data_dir filesep 'centroids' 'BGD_' anim_entity_HR_country '_HR_centroids.mat'];
nimation_data_HR_file=[climada_global.data_dir filesep 'results' filesep 'animation_data_HR.mat'];
nimation_mp4_HR_file=[climada_global.data_dir filesep 'results' filesep 'BGD_SIDR_HR.mp4'];
arisal_people_indicative=0;
 all switches for a full run
 generate_entity_and_centroids=1;
 calibrate_damagefunction=1;
 show_waterfall=1;
 show_adaptation_cost_curve=1;
 compare_mod=1;
 compare_TC_hurdat=1;
 size of the figure
ost_curve_figure_Position=[1 5 1000 660]; % for screen
ost_curve_PaperPosition=[.25 .25 8 4]; % for saved image, [left bottom width height].
_years=climada_global.future_reference_year-climada_global.present_reference_year+1; % was -1
f generate_entity_and_centroids
   
   % generate coarse (10km) entity
   [centroids_10,entity_10,entity_future_10] = climada_create_GDP_entity(centroids.admin0_name,[],0,1);
   if exist(high_res_entity_file,'file');
       load(high_res_entity_file); % load fine (1km) entity
   else
       entity=climada_nightlight_entity(centroids.admin0_name,'',1); % generate fine (1km) entity
       save(high_res_entity_file,'entity');
   end
   
   % generate centroids
   
   % keep high res for assets
   assets_pos=find(entity.assets.Value&ampgt0);
   centroids.lon=entity.assets.lon(assets_pos);
   centroids.lat=entity.assets.lat(assets_pos);
   
   % coarse for surroundings
   first_non_asset_pos=entity_10.assets.centroid_index(end)+1;
   centroids.lon=[centroids.lon centroids_10.lon(first_non_asset_pos:end)];
   centroids.lat=[centroids.lat centroids_10.lat(first_non_asset_pos:end)];
   centroids.centroid_ID=1:length(centroids.lon);
   
   save(centroids_file,'centroids');
   figure('Name','centroids','Position',[1 5 1000 668]);
   plot(centroids.lon,centroids.lat,'.r');hold on
   climada_plot_world_borders
   d=1;
   x_range = [min(centroids.lon)-d max(centroids.lon)+d];
   y_range = [min(centroids.lat)-d max(centroids.lat)+d];
   set(gca,'xlim',x_range,'ylim',y_range)
   set(gca,'FontSize',24)
   
   % restrict entity
   entity.assets.lon=entity.assets.lon(assets_pos);
   entity.assets.lat=entity.assets.lat(assets_pos);
   entity.assets.Value=entity.assets.Value(assets_pos);
   entity.assets.DamageFunID=entity.assets.DamageFunID(assets_pos);
   entity.assets.Deductible=entity.assets.Deductible(assets_pos)*0;
   if isfield(entity.assets,'distance2coast_km'),...
           entity.assets.distance2coast_km=entity.assets.distance2coast_km(assets_pos);end
   entity.assets.centroid_index=1:length(assets_pos);
   entity.assets.Value=entity.assets.Value/sum(entity.assets.Value)*GDP*(income_group+1); % scale with user-defined GDP and income group
   %entity.assets.Value=entity.assets.Value/sum(entity.assets.Value)*entity.assets.GDP_EST;
   entity.assets.Cover=entity.assets.Value;
   entity.assets.reference_year=climada_global.present_reference_year;
   
   save(merged_entity_file,'entity');
   hold on; % plot asset distribution on top
   climada_entity_plot(entity,2,1);
   set(gca,'xlim',x_range,'ylim',y_range)
   saveas(gcf,'/Users/bresch/Desktop/assets_centroids.png','png');
   
   % future entity
   entity.assets.Value=entity.assets.Value*(1+0.02)^(n_years-1);
   entity.assets.Cover=entity.assets.Value;
   entity.assets.reference_year=climada_global.future_reference_year;
   save(future_entity_file,'entity');
   entity_future=entity; % for later use
   
   load(merged_entity_file,'entity'); % load present entity again
   
lse
   load(future_entity_file) % contains entity (for future)
   entity_future=entity; % for later use
   load(merged_entity_file) % contains entity (for present)
   load(centroids_file)
nd % generate_entity_and_centroids
f calibrate_damagefunction % generate TC atl hazard
   [damagefunctions,dmf_info_str]=climada_damagefunction_generate(0:5:120,21,1,1.0,'exp','TC',0);
   fprintf('%s TC atl: %s\n',centroids.admin0_name,dmf_info_str);
   entity=climada_damagefunctions_replace(entity,damagefunctions);
   save(merged_entity_file,'entity');
   
   load(future_entity_file) % contains entity (for future)
   entity=climada_damagefunctions_replace(entity,damagefunctions);
   save(future_entity_file,'entity');
   entity_future=entity; % for later use
   load(merged_entity_file) % contains entity (for present)
   
   % restrict to TC001 damagefunction
   pTC=strmatch('TC',entity.damagefunctions.peril_ID);
   p1=find(entity.damagefunctions.DamageFunID==1);
   TC1_pos=intersect(pTC,p1);
   entity.damagefunctions.Intensity=entity.damagefunctions.Intensity(TC1_pos);
   entity.damagefunctions.MDD=entity.damagefunctions.MDD(TC1_pos);
   entity.damagefunctions.PAA=entity.damagefunctions.PAA(TC1_pos);
   entity.damagefunctions.DamageFunID=entity.damagefunctions.DamageFunID(TC1_pos);
   entity.damagefunctions.datenum=entity.damagefunctions.datenum(TC1_pos);
   entity.damagefunctions.peril_ID=entity.damagefunctions.peril_ID(TC1_pos);
   entity_future.damagefunctions=entity.damagefunctions;
nd
 generate the TC hazard event set
f ~exist(hazard_set_file,'file')
   load(tc_track_file)
   hazard=climada_tc_hazard_set(tc_track,hazard_set_file,centroids);
lse
   load(hazard_set_file)
nd
f ~exist(hazard_set_file_CC_mod,'file')
   hazard_CC_mod=climada_hazard_clim_scen(hazard,hazard_set_file_CC_mod,f_screw_mod,i_screw_mod);
lse
   load(hazard_set_file_CC_mod)
   hazard_CC_mod=hazard;
nd
f ~exist(hazard_set_file_CC_hig,'file')
   hazard_CC_hig=climada_hazard_clim_scen(hazard,hazard_set_file_CC_hig,f_screw_hig,i_screw_hig);
lse
   load(hazard_set_file_CC_hig)
   hazard_CC_hig=hazard;
nd
oad(hazard_set_file) % reload
f calculate_EDS
   EDS_today=climada_EDS_calc(entity,hazard);
   DFC_today=climada_EDS2DFC(EDS_today);
   figure;climada_EDS_DFC(EDS_today);
   ylabel('damage (USD)');
   % verify using https://en.wikipedia.org/wiki/Hurricane_Tomas
   % and https://en.wikipedia.org/wiki/List_of_Barbados_hurricanes
   
   % CCRIF study
   DFC.value=6.5e9;DFC.ED=139e6;DFC.peril_ID='TC';
   DFC.return_period=[10 20 50 100 200 500 1000];
   DFC.damage=[350 1050 3700 6500 9700 15600 20000]*1e6;
   DFC.damage_of_value=DFC.damage./DFC.value;
   DFC.annotation_name='BRB_Barbados_CCRIF';
   
   hold on
   plot(DFC.return_period,DFC.damage,'-k');
   title('CCRIF curve as envelope (incl.BI) not to be reached')
   legend('climada (TC only, no BI)','CCRIF study (absolute)')
   
nd % calculate_EDS
f show_waterfall
   EDS_today=climada_EDS_calc(entity,hazard);
   EDS_future=climada_EDS_calc(entity_future,hazard);
   EDS_future_CC_mod=climada_EDS_calc(entity_future,hazard_CC_mod);
   EDS_future_CC_hig=climada_EDS_calc(entity_future,hazard_CC_hig);
   
   % nicer figures
   EDS_today.ED=EDS_today.ED/1e6;
   EDS_future.ED=EDS_future.ED/1e6;
   EDS_future_CC_mod.ED=EDS_future_CC_mod.ED/1e6;
   EDS_future_CC_hig.ED=EDS_future_CC_hig.ED/1e6;
   EDS_today.Value=EDS_today.Value/1e6;
   EDS_future.Value=EDS_future.Value/1e6;
   EDS_future_CC_mod.Value=EDS_future_CC_mod.Value/1e6;
   EDS_future_CC_hig.Value=EDS_future_CC_hig.Value/1e6;
   
   % to get nice vertical scale
   max_y_axis=ceil(EDS_future_CC_hig.ED/10)*10;
   
   % compare (with wind only of CCRIF, about 80% of total CCRIF values)
   fprintf('today USD %f mio (111)\n',EDS_today.ED);
   fprintf('today+econ USD %f mio (167)\n',EDS_future.ED);
   fprintf('today+econ+CC moderate USD %f mio (189)\n',EDS_future_CC_mod.ED);
   fprintf('today+econ+CC high USD %f mio (223)\n',EDS_future_CC_hig.ED);
   climada_waterfall_graph(EDS_today, EDS_future, EDS_future_CC_mod,9999,-1);
   hold on;ylim([0 max_y_axis]);ylabel('Damage amount (USD mio)','fontsize',24);set(gca,'FontSize',24);title('')
   set(gcf,'Position',[1 5 1000 668]);
   saveas(gcf,'/Users/bresch/Desktop/waterfall_mod.png','png');
   
   climada_waterfall_graph(EDS_today, EDS_future, EDS_future_CC_hig,9999,-1);
   hold on;ylim([0 max_y_axis]);ylabel('Damage amount (USD mio)','fontsize',24);set(gca,'FontSize',24);title('')
   set(gcf,'Position',[1 5 1000 668]);
   saveas(gcf,'/Users/bresch/Desktop/waterfall_hig.png','png');
   
   ED_today_years=ones(1,n_years)*EDS_today.ED;
   NPV_ED_today_NPV=climada_NPV(ED_today_years,entity.discount.discount_rate);
   dED=EDS_future_CC_hig.ED-EDS_today.ED;
   ED_CChig_years=ED_today_years+(0:n_years-1)/(n_years-1)*dED; % linear increase
   NPV_ED_CC_high=climada_NPV(ED_CChig_years,entity.discount.discount_rate);
   fprintf('NPV ED of high CC %f USD mio (today: %f USD mio) at %2.0f%% discount\n',NPV_ED_CC_high,NPV_ED_today_NPV,entity.discount.discount_rate(1)*100);
   
nd % show_waterfall
f show_adaptation_cost_curve
   
   % compare with www.ccrif.org/content/projects/eca-economics-climate-adaptation
   
   % pro memoria, currently:
   %entity.damagefunctions.Intensity = max(entity.damagefunctions.Intensity*(1-measures.hazard_intensity_impact_a(measure_i)),0);
   
   cost_scale=1e6;
   
   % quikcly init all
   for measure_i=1:11 % hard-wired, sorry ;-)
       measures.name{measure_i}='undef';
       measures.color{measure_i}='0.84 0.89 0.70';
       measures.cost(measure_i)=0*cost_scale;
       measures.hazard_intensity_impact_a(measure_i)=1;
       measures.hazard_intensity_impact_b(measure_i)=0;
       measures.MDD_impact_a(measure_i)=1;
       measures.MDD_impact_b(measure_i)=0;
       measures.PAA_impact_a(measure_i)=1;
       measures.PAA_impact_b(measure_i)=0;
       measures.hazard_event_set{measure_i}='nil';
       measures.damagefunctions_map{measure_i}='nil';
       measures.hazard_high_frequency_cutoff(measure_i)=0;
       measures.risk_transfer_attachement(measure_i)=0;
       measures.risk_transfer_cover(measure_i)=0;
       measures.peril_ID{measure_i}='TC';
   end
   
   % we use wind as a proxy also for surge (for simplicity)
   
   %color_solid_1='0.15 0.7 0.65';
   color_solid_1='0.0 0.4 0.1';
   color_solid_2='0.05 0.5 0.2';
   color_solid_3='0.1 0.6 0.3';
   color_solid_4='0.15 0.7 0.4';
   color_middle_1='0.2 0.8 0.5';
   color_middle_2='0.25 0.85 0.6';
   color_middle_3='0.3 0.9 0.65';
   color_unattr_1='0.8 0.4 0.4';
   color_unattr_2='0.7 0.4 0.4';
   color_unattr_3='0.6 0.4 0.4';
   color_unattr_4='0.5 0.4 0.4';
   
   measure_i=1;
   measures.name{measure_i}='reef revival';
   measures.color{measure_i}=color_solid_3;
   measures.cost(measure_i)=20*cost_scale;
   measures.hazard_intensity_impact_b(measure_i)=-0.5; % surge
   
   measure_i=measure_i+1;
   measures.name{measure_i}='mangrove revival';
   measures.color{measure_i}=color_solid_3;
   measures.cost(measure_i)=25*cost_scale;
   measures.hazard_intensity_impact_b(measure_i)=-0.5; % surge (sponge) and wind (roughness)
   
   measure_i=measure_i+1;
   measures.name{measure_i}='coastal zoning';
   measures.color{measure_i}=color_solid_3;
   measures.cost(measure_i)=30*cost_scale;
   measures.PAA_impact_a(measure_i)=0.97; % fewer buildings affeced, surge and wind
   
   measure_i=measure_i+1;
   measures.name{measure_i}='inland zoning';
   measures.color{measure_i}=color_solid_3;
   measures.cost(measure_i)=35*cost_scale;
   measures.PAA_impact_a(measure_i)=0.97; % fewer buildings affeced (wind)
   
   measure_i=measure_i+1;
   measures.name{measure_i}='coastal flood proofing';
   measures.color{measure_i}=color_middle_3;
   measures.cost(measure_i)=90*cost_scale;
   measures.PAA_impact_a(measure_i)=0.95; % surge and wind
   
   measure_i=measure_i+1;
   measures.name{measure_i}='wind building codes';
   measures.color{measure_i}=color_middle_3;
   measures.cost(measure_i)=600*cost_scale;
   measures.MDD_impact_a(measure_i)=0.77;
   
   measure_i=measure_i+1;
   measures.name{measure_i}='sea walls';
   measures.color{measure_i}=color_unattr_1;
   measures.cost(measure_i)=200*cost_scale;
   measures.hazard_high_frequency_cutoff(measure_i)=1/15;
   
   measure_i=measure_i+1;
   measures.name{measure_i}='beach nurishment';
   measures.color{measure_i}=color_unattr_1;
   measures.cost(measure_i)=120*cost_scale;
   measures.hazard_intensity_impact_b(measure_i)=-0.25;
   
   measure_i=measure_i+1;
   measures.name{measure_i}='wind adapt retrofit';
   measures.color{measure_i}=color_unattr_2;
   measures.cost(measure_i)=750*cost_scale;
   measures.PAA_impact_a(measure_i)=0.95;
   
   measure_i=measure_i+1;
   measures.name{measure_i}='breakwaters';
   measures.color{measure_i}=color_unattr_3;
   measures.cost(measure_i)=1050*cost_scale;
   measures.MDD_impact_a(measure_i)=0.97;
   
   measure_i=measure_i+1;
   measures.name{measure_i}='coastal stilts';
   measures.color{measure_i}=color_unattr_4;
   measures.cost(measure_i)=2050*cost_scale;
   measures.MDD_impact_a(measure_i)=0.95;
   
   %     measure_i=measure_i+1;
   %     measures.name{measure_i}='mobile barriers';
   %     measures.color{measure_i}=color_unattr;
   %     measures.cost(measure_i)=1500*cost_scale;
   %     measures.MDD_impact_a(measure_i)=0.98;
   
   %     measure_i=measure_i+1;
   %     measures.name{measure_i}='inland stilts';
   %     measures.color{measure_i}=color_unattr;
   %     measures.cost(measure_i)=3050*cost_scale;
   %     measures.MDD_impact_a(measure_i)=0.98;
   
   measures.filename=mfilename;
   entity.measures=climada_measures_encode(measures);
   entity_future.measures=entity.measures;
   
   measures_impact_ref=climada_measures_impact(entity,hazard,'no'); % reference
   measures_impact_hig=climada_measures_impact(entity_future,hazard_CC_hig,measures_impact_ref);
   measures_impact_hig.x_axis_max=cost_curve_x_axis_max;
   measures_impact_hig.y_axis_max=cost_curve_y_axis_max;
   measures_impact_hig.label_comparison=0; % avoid labels on comparison
   measures_impact_hig.color_keep=1; % keep colors
   
   climada_global.font_scale=1; % for adaptation cost curve, it zoomes TOO big on plots (no worries, shows small on screen)
   
   %     figure
   %     climada_adaptation_cost_curve(measures_impact_hig);
   %     hold on;title('');set(gcf,'Position',cost_curve_figure_Position);ylim([0 cost_curve_y_axis_max]);xlim([0 cost_curve_x_axis_max]);drawnow
   %     set(gcf,'PaperPosition',cost_curve_PaperPosition); % [left bottom width height]
   %     saveas(gcf,'/Users/bresch/Desktop/adaptation_cost_curve_hig.png','png');
   %     return
   
   fprintf('high only not shown, since not needed as slide\n');
   
   if compare_mod
       measures_impact_mod=climada_measures_impact(entity_future,hazard_CC_mod,measures_impact_ref);
       measures_impact_mod.x_axis_max=cost_curve_x_axis_max;
       measures_impact_mod.y_axis_max=cost_curve_y_axis_max;
       measures_impact_mod.label_comparison=0; % avoid labels on comparison
       measures_impact_mod.color_keep=1; % keep colors
       
       figure
       climada_adaptation_cost_curve(measures_impact_mod);
       hold on;title('');set(gcf,'Position',cost_curve_figure_Position);ylim([0 cost_curve_y_axis_max]);xlim([0 cost_curve_x_axis_max]);drawnow
       set(gcf,'PaperPosition',cost_curve_PaperPosition); % [left bottom width height]
       saveas(gcf,'/Users/bresch/Desktop/adaptation_cost_curve_mod.png','png');
       
       figure
       climada_adaptation_cost_curve(measures_impact_hig,measures_impact_mod)
       %climada_adaptation_cost_curve(measures_impact_mod,measures_impact_hig)
       hold on;title('');set(gcf,'Position',cost_curve_figure_Position);ylim([0 cost_curve_y_axis_max]);xlim([0 cost_curve_x_axis_max]);drawnow
       set(gcf,'PaperPosition',cost_curve_PaperPosition); % [left bottom width height]
       saveas(gcf,'/Users/bresch/Desktop/adaptation_cost_curve_hig_VS_mod.png','png');
       %saveas(gcf,'/Users/bresch/Desktop/adaptation_cost_curve_mod_VS_hig.png','png');
   end
   
   if compare_discounting
       
       discount_rate_BU=entity_future.discount.discount_rate;
       entity_future.discount.discount_rate=entity_future.discount.discount_rate*0+discount_rate; % set
       measures_impact_hig_dct=climada_measures_impact(entity_future,hazard_CC_hig,measures_impact_ref);
       entity_future.discount.discount_rate=discount_rate_BU; % reset
       measures_impact_hig_dct.x_axis_max=cost_curve_x_axis_max;
       measures_impact_hig_dct.y_axis_max=cost_curve_y_axis_max;
       measures_impact_hig_dct.label_comparison=0; % avoid labels on comparison
       measures_impact_hig_dct.color_keep=1; % avoid labels on comparison
       figure
       climada_adaptation_cost_curve(measures_impact_hig_dct,measures_impact_hig)
       hold on;title('');set(gcf,'Position',cost_curve_figure_Position);ylim([0 cost_curve_y_axis_max]);xlim([0 cost_curve_x_axis_max]);drawnow
       set(gcf,'PaperPosition',cost_curve_PaperPosition); % [left bottom width height]
       saveas(gcf,'/Users/bresch/Desktop/adaptation_cost_curve_hig_VS_dct.png','png');
       
   end % compare_discounting
   
   % comparison with another TC track database
   if compare_TC_hurdat
       if ~exist(hazard_set_file_HURDAT,'file')
           load(tc_track_file_HURDAT)
           tc_track=climada_tc_random_walk(tc_track);
           hazard_HURDAT=climada_tc_hazard_set(tc_track,hazard_set_file_HURDAT,centroids);
       else
           hazard_BU=hazard;
           load(hazard_set_file_HURDAT)
           hazard_HURDAT=hazard;
       end
       
       if ~exist(hazard_set_file_CC_mod_HURDAT,'file')
           hazard_CC_mod_HURDAT=climada_hazard_clim_scen(hazard_HURDAT,hazard_set_file_CC_mod_HURDAT,f_screw_mod,i_screw_mod);
       else
           load(hazard_set_file_CC_mod_HURDAT)
           hazard_CC_mod_HURDAT=hazard;
       end
       
       if ~exist(hazard_set_file_CC_hig_HURDAT,'file')
           hazard_CC_hig_HURDAT=climada_hazard_clim_scen(hazard_HURDAT,hazard_set_file_CC_hig_HURDAT,f_screw_hig,i_screw_hig);
       else
           load(hazard_set_file_CC_hig_HURDAT)
           hazard_CC_hig_HURDAT=hazard;
       end
       load(hazard_set_file) % reload original hazard (UNISYS)
       
       measure_i=5;
       %measures.name{measure_i}='coastal flood proofing';
       measures.cost(measure_i)=250*cost_scale;
       measures.PAA_impact_a(measure_i)=0.92; % surge and wind
       
       measure_i=6;
       %measures.name{measure_i}='wind building codes';
       measures.cost(measure_i)=600*cost_scale;
       measures.MDD_impact_a(measure_i)=0.77;
       
       measures.filename=mfilename;
       entity.measures=climada_measures_encode(measures);
       entity_future.measures=entity.measures;
       
       measures_impact_ref_HURDAT=climada_measures_impact(entity_future,hazard_HURDAT,'no');
       %measures_impact_hig_HURDAT=climada_measures_impact(entity_future,hazard_CC_hig_HURDAT,measures_impact_ref);
       measures_impact_hig_HURDAT=climada_measures_impact(entity_future,hazard_CC_hig_HURDAT,measures_impact_ref_HURDAT);
       measures_impact_hig_HURDAT.x_axis_max=cost_curve_x_axis_max;
       measures_impact_hig_HURDAT.y_axis_max=cost_curve_y_axis_max;
       measures_impact_hig_HURDAT.label_comparison=0; % avoid labels on comparison
       measures_impact_hig_HURDAT.color_keep=1; % avoid labels on comparison
       figure
       %climada_adaptation_cost_curve(measures_impact_hig,measures_impact_hig_HURDAT)
       climada_adaptation_cost_curve(measures_impact_hig_HURDAT,measures_impact_hig)
       hold on;title('');set(gcf,'Position',cost_curve_figure_Position);ylim([0 cost_curve_y_axis_max]);xlim([0 cost_curve_x_axis_max]);drawnow
       set(gcf,'PaperPosition',cost_curve_PaperPosition); % [left bottom width height]
       %saveas(gcf,'/Users/bresch/Desktop/adaptation_cost_curve_hig_VS_HURDAT.png','png');
       saveas(gcf,'/Users/bresch/Desktop/adaptation_cost_curve_HURDAT_VS_hig.png','png');
       
   end % compare_TC_hurdat
   
   if adaptation_event_view
       
       climada_global.font_scale=1; % for adaptation cost curve, it zoomes TOO big on plots (no worries, shows small on screen)
       
       figure
       climada_adaptation_event_view(measures_impact_hig,[100 200])
       hold on;title('');set(gcf,'Position',[1 5 1000 668]);
       set(gcf,'PaperPosition',[0.25 .25 6 8]);
       xlabel('return period (years)');ylabel('event damage amount (USD)');
       drawnow
       saveas(gcf,'/Users/bresch/Desktop/adaptation_event_view_hig.png','png');
       
   end % adaptation_event_view
   
nd % show_adaptation_cost_curve
f create_animation
   
   anim_entity=climada_entity_load(anim_entity_file);
   tc_track=climada_tc_read_unisys_track(anim_tc_track_file);
   anim_check_mode=1; % =0 for real, =1 to check
   %hazard_anim=climada_event_damage_data_tc(tc_track,anim_entity,animation_data_file,0,anim_check_mode);
   
   load(animation_data_file); % contains a 'rich' hazard
   % apply attenuation to reduce inland damage (for animation
   % purpose, in real, one would need to run tc_hazard_advanced, also
   % leading to attenuaton inland)
   att_start=1080; % we figured from visual inspection and cheking in hazard.tc_track.datenum
   att_end=1120; % we figured from visual inspection and cheking in hazard.tc_track.datenum
   i_start=find(hazard.tc_track_node==att_start);
   i_end=find(hazard.tc_track_node==att_end);
   % apply to damage
   for step_i=i_start:i_end
       att_fact=((i_end-i_start)-(step_i-i_start))/(i_end-i_start);
       hazard.damage(step_i,:)=hazard.damage(step_i,:)*att_fact;
   end
   hazard.damage(i_end:end,:)=0;
   save(animation_data_file,'hazard'); % store back
   climada_event_damage_animation(animation_data_file,animation_mp4_file,2,0);
   
   %     tc_tracks=climada_tc_random_walk(tc_track,9,-0.1,pi/10); % create probabilistic tracks
   %     climada_plot_world_borders;hold on;
   %     for i=1:length(tc_tracks),plot(tc_tracks(i).lon,tc_tracks(i).lat,'.-b');end
   %     plot(tc_track.lon,tc_track.lat,'.-g','LineWidth',2);
   
nd % create_animation
f create_HR_animation
   
   if not(exist(anim_entity_HR_file,'file'))
       [entity,centroids]=climada_hybrid_entity(anim_entity_HR_country);
       save(anim_centroids_HR_file,'centroids');
       save(anim_entity_HR_file,'entity');
   end
   
   anim_HR_entity=climada_entity_load(anim_entity_HR_file);
   tc_track=climada_tc_read_unisys_track(anim_tc_track_HR_file);
   anim_check_mode=0; % =0 for real, =1 to check
   hazard_anim=climada_event_damage_data_tc(tc_track,anim_HR_entity,animation_data_HR_file,0,anim_check_mode);
   
   load(animation_data_HR_file); % contains a 'rich' hazard
   % apply attenuation to reduce inland damage (for animation
   % purpose, in real, one would need to run tc_hazard_advanced, also
   % leading to attenuaton inland)
   att_start=1080; % we figured from visual inspection and cheking in hazard.tc_track.datenum
   att_end=1120; % we figured from visual inspection and cheking in hazard.tc_track.datenum
   i_start=find(hazard.tc_track_node==att_start);
   i_end=find(hazard.tc_track_node==att_end);
   % apply to damage
   for step_i=i_start:i_end
       att_fact=((i_end-i_start)-(step_i-i_start))/(i_end-i_start);
       hazard.damage(step_i,:)=hazard.damage(step_i,:)*att_fact;
   end
   hazard.damage(i_end:end,:)=0;
   save(animation_data_HR_file,'hazard'); % store back
   climada_event_damage_animation(animation_data_HR_file,animation_mp4_HR_file,-1,0);
   
nd % create_HR_animation
f Barisal_people_indicative
   
   %color_solid_1='0.15 0.7 0.65';
   color_solid_1='0.0 0.4 0.1';
   color_solid_2='0.05 0.5 0.2';
   color_solid_3='0.1 0.6 0.3';
   color_solid_4='0.15 0.7 0.4';
   color_middle_1='0.2 0.8 0.5';
   color_middle_2='0.25 0.85 0.6';
   color_middle_3='0.3 0.9 0.65';
   color_unattr_1='0.8 0.4 0.4';
   color_unattr_2='0.7 0.4 0.4';
   color_unattr_3='0.6 0.4 0.4';
   color_unattr_4='0.5 0.4 0.4';
   
   measures_impact.EDS=[];
   measures_impact.measures.name{1}='Early warning system';
   measures_impact.measures.name{2}='Evacuation plan and training';
   measures_impact.measures.name{3}='Building reinforcement (core)';
   measures_impact.measures.name{4}='Building reinforcement (comprehensive)';
   measures_impact.measures.name{5}='Road reinforcement (main)';
   measures_impact.measures.color{1}=color_solid_1;
   measures_impact.measures.color{2}=color_solid_1;
   measures_impact.measures.color{3}=color_middle_1;
   measures_impact.measures.color{4}=color_unattr_2;
   measures_impact.measures.color{5}=color_unattr_2;
   
   measures_impact.measures.color_RGB(1,:)=[0.05 0.5 0.2];
   measures_impact.measures.color_RGB(2,:)=[0.1 0.6 0.3];
   measures_impact.measures.color_RGB(3,:)=[0.3 0.9 0.65];
   measures_impact.measures.color_RGB(4,:)=[0.5 0.4 0.4];
   measures_impact.measures.color_RGB(5,:)=[0.8 0.4 0.4];
   
   measures_impact.measures.cost(1)=2e6;
   measures_impact.measures.cost(2)=2.5e6;
   measures_impact.measures.cost(3)=4e6;
   measures_impact.measures.cost(4)=55e6;
   measures_impact.measures.cost(5)=55e6;
   
   measures_impact.benefit(1)=1147;
   measures_impact.benefit(2)=970;
   measures_impact.benefit(3)=650;
   measures_impact.benefit(4)=1510;
   measures_impact.benefit(5)=1010;
   
   measures_impact.peril_ID='TC';
   measures_impact.Value_unit='people';
   measures_impact.DFC=[];
   
   measures_impact.NPV_total_climate_risk=26*228;
   
   measures_impact.cb_ratio(1)=measures_impact.measures.cost(1)/measures_impact.benefit(1);
   measures_impact.cb_ratio(2)=measures_impact.measures.cost(2)/measures_impact.benefit(2);
   measures_impact.cb_ratio(3)=measures_impact.measures.cost(3)/measures_impact.benefit(3);
   measures_impact.cb_ratio(4)=measures_impact.measures.cost(4)/measures_impact.benefit(4);
   measures_impact.cb_ratio(5)=measures_impact.measures.cost(5)/measures_impact.benefit(5);
       
   measures_impact.ED=measures_impact.benefit;
   measures_impact.ED_benefit=measures_impact.benefit;
   
   measures_impact.risk_transfer=measures_impact.ED_benefit*0;
   measures_impact.ED_risk_transfer=measures_impact.ED_benefit*0;
   measures_impact.ED_cb_ratio=measures_impact.cb_ratio;
   measures_impact.risk_premium_fgu=0;
   measures_impact.risk_premium_net=0;
   measures_impact.risk_premium_comment='total climate risk divided by the total value of assets';
   measures_impact.title_str='Bangladesh people';
   measures_impact.filename='undef';
   measures_impact.color_keep=1;
   
     OPRY=climada_global.present_reference_year;
     OFRY=climada_global.future_reference_year;
     climada_global.present_reference_year=2015;
     climada_global.future_reference_year=2040;
   
   climada_adaptation_cost_curve(measures_impact)
   hold on;title('');set(gcf,'Position',cost_curve_figure_Position);drawnow
   set(gcf,'PaperPosition',cost_curve_PaperPosition); % [left bottom width height]
   xlabel('peoples lives saved over 26 years');
   saveas(gcf,'/Users/bresch/Desktop/adaptation_cost_curve_BARISAL.png','png');
   
     climada_global.present_reference_year=OPRY;
     climada_global.future_reference_year=OFRY;
nd % Barisal_people_indicative
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/Barbados_test.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="Fiji_Samoa_Tonga_Vanuatu_EQ">
<H2>Fiji_Samoa_Tonga_Vanuatu_EQ</H2></A>
 Fiji_Samoa_Tonga_Vanuatu_EQ
 MODULE:
   LOCAL
 NAME:
   Fiji_Samoa_Tonga_Vanuatu_EQ
 PURPOSE:
   run EQ for Fiji, Samoa, Tonga and Vanuatu
   - create entities (asset base) for each country
   - create climada EQ hazard event sets
   - set default EQ vulnerability
   - plot DFC (damage frequency curve) for relative comparison
 CALLING SEQUENCE:
   Fiji_Samoa_Tonga_Vanuatu_EQ
 EXAMPLE:
   Fiji_Samoa_Tonga_Vanuatu_EQ;
 INPUTS:
   All parameters set in code (batch code)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20151028
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/Fiji_Samoa_Tonga_Vanuatu_EQ.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="MSP_PLS_read">
<H2>MSP_PLS_read</H2></A>
<font color="blue">function PLS=MSP_PLS_read(PLS_file,verbose) </font>
 read MultiSNAP period loss set
 MODULE:
   _LOCAL
 NAME:
   MSP_PLS_read
 PURPOSE:
   read MultiSNAP (MSP) Period Loss Set (PLS) and store it into a MATLAB
   structure. See climada_PLS_read to obtain a Year Damage Set (YDS)

   A PLS .csv file contains:

       id,dataScope,totalPanjerFactor,periodAverageExpectedLoss,repetitionPeriodInYears,aggregationPeriodBeginInYearNormalised,aggregationPeriodEndInYearNormalised,nbrOfYearsSimulation,currencyCode,currencyUnit,mainNatCatHazardTypes
       2003800,201508_1MIO_YEARS,1.0315346447966625,1.5307887560850577E9,1.0,0.0,1.0,2.0E7,USD,1,
       ratingZone,panjerFactor
       651002,1.0315346447966625
       time,eventId,sampleId,event rating zone,period rating zone,loss,periodId
       0.5323603633556622,2400008019,3,651002,651002,24435.731790959577,1
       0.6820032772549107,2400111073,3,651002,651002,748944.8931435767,1
       1.8630114629304617,2394903067,4,651002,651002,4.4794916625730775E7,2
       ...

   therefore, we first read the two double loines of parameters and then
   the full block of data at once (using fscanf, built in and fast)

 CALLING SEQUENCE:
   PLS=MSP_PLS_read(PLS_file,verbose)
 EXAMPLE:
   PLS=MSP_PLS_read
 INPUTS:
   PLS_file: MultiSNAP Period Loss Set (PLS) filename with path.
       if it comes w/o path, {climada_global.data_dir}/results is assumed
       if ='TEST', use sample PLS file, see PARAMETERS section in code
 OPTIONAL INPUT PARAMETERS:
   verbose: =1 print some info to stdout, =0 not (silent, default)
 OUTPUTS:
   PLS: a structure with
       filename: the filename (with path) the data has been read from
      first all header/parameter fileds, as:
       id: MultiSNAP ID
       dataScope: scope description, like '201508_1MIO_YEARS'
       totalPanjerFactor
       periodAverageExpectedLoss
       repetitionPeriodInYears
       aggregationPeriodBeginInYearNormalised
       aggregationPeriodEndInYearNormalised
       nbrOfYearsSimulation: number os years simulated
       currencyCode: like 'USD'
       currencyUnit
       mainNatCatHazardTypes
       ratingZone
       panjerFactor
      and then the data fields, namely:
       time(n)
       eventId(n)
       sampleId(n)
       event_rating_zone(n)
       period_rating_zone(n)
       loss(n)
       periodId(n)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160107, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/disaster_risk_finance/code/helper_functions/MSP_PLS_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="PHL_comparison">
<H2>PHL_comparison</H2></A>
 PHL_comparison

 batch file to compare PHL (Philippines) results
lobal climada_global
 PARAMETERS

ntity_file=[climada_global.data_dir filesep 'entities' filesep 'PHL_Philippines_entity.mat'];
azard_file=[climada_global.data_dir filesep 'hazards' filesep  'PHL_Philippines_wpa_TC.mat'];

 MultiSNAP results file (xls)
SP_results=[climada_global.data_dir filesep 'results' filesep 'PHL_10km' filesep 'EASI_TEST_Philippines_TW_results.xls'];

 maximum return to show in plots
ax_return_period=250;
DS_multiplier=1; % default=1, multiply climada results by this factor

EST_damagefunction=0; % default=0, =1 polynomial, =2 S-shaped
DD_max=1;
DD_exponent=5; % default=1, exponent for MDD=intensity.^MDD_exponent
in_Intensity=20; % minimum Intensity that leads to damage
ntity=climada_entity_load(entity_file);
oad(hazard_file);
entity.assets.DamageFunID=entity.assets.DamageFunID*2;
f TEST_damagefunction
   % TEST damage function
   entity.damagefunctions.Intensity=1:120;
   entity.damagefunctions.DamageFunID=entity.damagefunctions.Intensity*0+1;
   entity.damagefunctions=rmfield(entity.damagefunctions,'peril_ID');
   
   if TEST_damagefunction==1
       % test polynomial damage function
       entity.damagefunctions.MDD=max(entity.damagefunctions.Intensity-min_Intensity,0).^MDD_exponent;
       entity.damagefunctions.MDD=MDD_max*entity.damagefunctions.MDD/entity.damagefunctions.MDD(end);
       entity.damagefunctions.PAA=max(entity.damagefunctions.Intensity-min_Intensity,0).^MDD_exponent;
       entity.damagefunctions.PAA=entity.damagefunctions.PAA/entity.damagefunctions.PAA(end);
       dmf_title_str=sprintf('intens&ampgt%i, exp %f',min_Intensity,MDD_exponent);
   elseif TEST_damagefunction==2
       % TEST S-shaped damage function
       entity.damagefunctions.MDD=entity.damagefunctions.Intensity*0; % init
       entity.damagefunctions.PAA=entity.damagefunctions.Intensity*0; % init
       Intensity_pos=entity.damagefunctions.Intensity&ampgtmin_Intensity;
       n_x=sum(Intensity_pos);
       x = -2:4/n_x:2;y = erf(x);y=y-y(1);y=y/max(y); % erf to get S-shape
       entity.damagefunctions.MDD(Intensity_pos)=y(1:end-1);
       entity.damagefunctions.PAA(Intensity_pos)=y(1:end-1);
       entity.damagefunctions.MDD=MDD_max*(entity.damagefunctions.MDD.^MDD_exponent);
       entity.damagefunctions.PAA=(entity.damagefunctions.PAA.^MDD_exponent);
       dmf_title_str=sprintf('S-shape, intens&ampgt%i, exp %f',min_Intensity,MDD_exponent);
   end
   plot(entity.damagefunctions.Intensity,entity.damagefunctions.MDD);hold on;
   plot(entity.damagefunctions.Intensity,entity.damagefunctions.PAA,'xg');
   legend('MDD','PAA');
   xlabel('Intensity'),ylabel('MDD and PAA')
   set(gcf,'Color',[1 1 1]);title(dmf_title_str);
   figure
lse
   dmf_title_str='';
nd % TEST_damagefunction
DS(1)=climada_EDS_calc(entity,hazard);
DS(1).annotation_name='GDP_entity';
um_of_value=sum(entity.assets.Value);
ntity.assets.Value=entity.assets.Value.^2;
ntity.assets.Value=entity.assets.Value/sum(entity.assets.Value)*sum_of_value;
DS(2)=climada_EDS_calc(entity,hazard);
DS(2).annotation_name='GDP^2';
um_of_value=sum(entity.assets.Value);
ntity.assets.Value=entity.assets.Value.^2;
ntity.assets.Value=entity.assets.Value/sum(entity.assets.Value)*sum_of_value;
DS(3)=climada_EDS_calc(entity,hazard);
DS(3).annotation_name='GDP^4';
DS(4)=climada_EDS_DFC_match(EDS(1),MSP_results,-99); % -99 to omit plot
DS(4).annotation_name='matched';
DS_multiplier=0.142546; % to correct for different TIV
atch100fact=climada_DFC_compare(EDS,MSP_results,0,0,0,EDS_multiplier);
Lim = get(get(gcf,'CurrentAxes'),'YLim');axis([[0 max_return_period] [0 YLim(2)]]); % get good part of figure
itle(sprintf('multiplier %f %s',EDS_multiplier,dmf_title_str));
printf('Multiply EDS by %f to match MSP\n',match100fact);
igure % match again and compare per occurrence with annual aggregate
DS(4)=climada_EDS_DFC_match(EDS(1),MSP_results); % -99 to omit plot
DS(4).annotation_name='matched';
DS=climada_EDS2YDS(EDS(4),hazard); % to annual exceedence
old on;climada_EDS_DFC(YDS);
egend('MultiSNAP','climada matched','dito','climada annual aggregate exceedence');
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/PHL_comparison.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="SnP_all_in_one">
<H2>SnP_all_in_one</H2></A>
 SnP_all_in_one
 climada template
 MODULE:
   module name
 NAME:
   SnP_all_in_one, run all S&ampP project countries, all calculations
 PURPOSE:
   Run all climada for S&ampP project
 CALLING SEQUENCE:
   SnP_all_in_one
 EXAMPLE:
   SnP_all_in_one
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150105
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/SnP_all_in_one.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="TEST_waterfall">
<H2>TEST_waterfall</H2></A>
 TEST_waterfall
ntity=climada_entity_load('USA_UnitedStatesFlorida');
azard_TC=climada_hazard_load('USA_UnitedStatesFlorida_atl_TC');
azard_TS=climada_hazard_load('USA_UnitedStatesFlorida_atl_TS');
os=find(hazard_TS.intensity);
azard_TS.intensity(pos)=hazard_TS.intensity(pos)+1;
DS_TC_today=climada_EDS_calc(entity,hazard_TC);
DS_TS_today=climada_EDS_calc(entity,hazard_TS);
ntity_econo=entity;
ntity_econo.assets.Value=entity_econo.assets.Value*1.2;
ntity_econo.assets.Cover=entity_econo.assets.Value;
DS_TC_econo=climada_EDS_calc(entity_econo,hazard_TC);
DS_TS_econo=climada_EDS_calc(entity_econo,hazard_TS);
azard_TC_clima=hazard_TC;
azard_TC_clima.intensity=hazard_TC_clima.intensity*1.1;
azard_TS_clima=hazard_TS;
azard_TS_clima.intensity=hazard_TS_clima.intensity*1.1;
DS_TC_clima=climada_EDS_calc(entity_econo,hazard_TC_clima);
DS_TS_clima=climada_EDS_calc(entity_econo,hazard_TS_clima);
igure;climada_waterfall_graph(EDS_TC_today,EDS_TC_econo,EDS_TC_clima);
igure;climada_waterfall_graph(EDS_TS_today,EDS_TS_econo,EDS_TS_clima);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/TEST_waterfall.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="TUV_animation">
<H2>TUV_animation</H2></A>
 TUV_animation
 Tuvalu tc damage animation
c_track=climada_tc_track_load('she_prob');
ntity=climada_entity_load('TUV_Tuvalu_SRTM');
rack_i=6206; % 6206 for most damaging probabiistic track, 6201 for its original
 for the whole TUV region, mid timestep
[hazard,hazard_TS]=climada_event_damage_data_tc(tc_track(track_i),entity,'',0,-.5,[176 180 -12 -5]); % prep animation data
 for the small, high res animation
hazard,hazard_TS]=climada_event_damage_data_tc(tc_track(track_i),entity,'',0,0,[178 180 -9 -7]); % prep animation data
 load and scale Value and damage
ata_filename='/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_data/results/animation_data.mat';
oad(data_filename)
azard.assets.Value=hazard.assets.Value*1e6;
azard.damage=hazard.damage*1e6;
azard.max_damage=hazard.max_damage*1e6;
azard.assets.Cover=hazard.assets.Value;
ave(data_filename,'hazard','hazard_TS')
limada_event_damage_animation(data_filename,'TUV_6201_animation',-1) % small markers for small islands
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/TUV_animation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="USA_TC_hist_checks">
<H2>USA_TC_hist_checks</H2></A>
 USA_TC_hist_checks
ntity=climada_entity_load('USA_UnitedStates_entity');
entroids=climada_centroids_load('USA_UnitedStates_centroids');
azard_TC=climada_hazard_load('USA_UnitedStates_atl_TC_hist');
azard_TS=climada_hazard_load('USA_UnitedStates_atl_TS_hist');
DS_TC=climada_EDS_calc(entity,hazard_TC);
DS_TS=climada_EDS_calc(entity,hazard_TS);
DS_comb=climada_EDS_combine(EDS_TC,EDS_TS);
DS_comb=climada_EDS2YDS(EDS_comb);
igure('Name','TC USA damage','Color',[1 1 1]);
ar(YDS_comb.yyyy,YDS_comb.damage); % show annual damage 18xx..today
itle('historic damage [USD] based on todays assets')
ist_intens=hazard_TC.intensity(1170,:);
c_track=climada_tc_read_unisys_track('atlantic_1992_ANDREW');
azard_TC1=climada_tc_hazard_set(tc_track,'NOSAVE',centroids);
_intens=intens-hazard_TC1.intensity;
igure('Name','TC Andrew windfield difference [m/s]','Color',[1 1 1]);
limada_color_plot(d_intens,centroids.lon,centroids.lat,'Andrew comparison','Andrew windfield comparison [m/s]','','','',0)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/USA_TC_hist_checks.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_PLS_read">
<H2>climada_PLS_read</H2></A>
<font color="blue">function YDS=climada_PLS_read(PLS_file,verbose) </font>
 read MultiSNAP period loss set
 MODULE:
   _LOCAL
 NAME:
   climada_PLS_read
 PURPOSE:
   read MultiSNAP (MSP) Period Loss Set (PLS) and convert to
   climada Year Damage Set (YDS)

   calls MSP_PLS_read to read the file and then converts PLS into YDS.
   In essence, adds two fields to render the more complex MSP period set
   compatible with the straightforward climada YDS (year damage set) and
   adds all YDS fields (many with dummy values).

   See MSP_PLS_read for the low-level file i/o
 CALLING SEQUENCE:
   YDS=climada_PLS_read(PLS_file,verbose)
 EXAMPLE:
   YDS=climada_PLS_read
 INPUTS:
   PLS_file: MultiSNAP Period Loss Set (PLS) filename with path.
       if it comes w/o path, {climada_global.data_dir}/results is assumed
       if ='TEST', use sample PLS file, see PARAMETERS section in code
 OPTIONAL INPUT PARAMETERS:
   verbose: =1 print some info to stdout, =0 not (silent, default)
 OUTPUTS:
   YDS, a climada year damage set, structure with the fields:
       reference_year: set to climada_global.present_reference_year
       event_ID: =[], empty, provided for EDS compatibility
       damage(n): the damage for year n
       ED_at_centroid: [], empty, since not provided by MSP
       Value: [], empty, since not provided by MSP
       frequency: the single year frequency compared to the full YDS
       orig_event_flag: [], empty, since not needed for yearset
       peril_ID: set ='XX', since not provided by MSP
       hazard: [], empty, since not provided by MSP
       Value_unit: set to PLS.currencyCode, like 'USD'
       comment: set to ['from MSP PLS: ' PLS.filename]
       assets: [], empty, since not provided by MSP
       damagefunctions: [], empty, since not provided by MSP
       annotation_name: set to 'MSP PLS'
       ED: expected damage, set to average damage over years
       yyyy(n): the year
       orig_year_flag: all =0 since not provided by MSP
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160107, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/disaster_risk_finance/code/helper_functions/climada_PLS_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_event_damage_animation3">
<H2>climada_event_damage_animation3</H2></A>
<font color="blue">function res=climada_event_damage_animation(animation_data_file,animation_avi_file) </font>
 climada template
 MODULE:
   module name
 NAME:
   climada_event_damage_animation
 PURPOSE:
   Animation of event damage - as an .avi movie
   This code does the visualization (rendering), see e.g.
   climada_event_damage_data_tc to calculate all the data. As one often
   needs to play with visualization parameters, the process is split.

   An animation of the tropical cylclon track hitting the assets as
   defined in entity

   The code determines the plot area based on entity (but since there can be
   more than one ocean basin's tracks hitting the centroids, the user has
   to select the track file).

   Note that this code does not (yet) run in Octave, as video support is
   limited (see &amplthttp://octave.sf.net/video/&ampgt) and the present code uses
   latest MATLAB videowriter (better performance than avifile...).

   prior calls: climada_event_damage_data_tc or similar to prepare the
   event damage information
 CALLING SEQUENCE:
   res=climada_event_damage_animation(animation_data_file,animation_avi_file)
 EXAMPLE:
   res=climada_event_damage_animation; % prompt for
 INPUTS:
   animation_data_file: the data file (.mat) with hazard set which
       includes event damage information, see e.g. climada_event_damage_data_tc
       &ampgt promted for if not given
   animation_avi_file: the filename of the resulting .avi movie
       &ampgt promted for if not given (if cancel pressed, the movie frames are
       not written to file - useful for test)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150118, initial
 David N. Bresch, david.bresch@gmail.com, 20150119, hazard translucent, entity blue, damage red
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/climada_event_damage_animation3.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_equal_timestep_OLD">
<H2>climada_tc_equal_timestep_OLD</H2></A>
<font color="blue">function tc_track_out=climada_tc_equal_timestep(tc_track,default_min_TimeStep) </font>
 tropical cycline track
 NAME:
   climada_tc_equal_timestep
 PURPOSE:
   Interpolate tc_track to equal timestep, usually 1h
 
   Uses linear interpolation for all fields (for speedup) and removes the
   (anyway unused) field 'extratrop' (of the form '****..EEE')
 
   Works to interpolate on any timestep between first and last node,
   timestep measured in hours. Note that time step shall 'fit' within
   start and end, e.g. 0:6:24 -&ampgt [0 6 12 18 24], but 0:5:24 -&ampgt [0 5 10 15 20]
 
 CALLING SEQUENCE:
   tc_track=climada_tc_equal_timestep(tc_track,default_min_TimeStep)
 EXAMPLE:
   tc_track=climada_tc_equal_timestep(tc_track)
 INPUTS:
   tc_track: a tc_track structure (a single track or many), eg as returned
       by climada_tc_read_unisys_database or climada_tc_read_unisys_track 
 OPTIONAL INPUT PARAMETERS:
   default_min_TimeStep: the default minimum TimeStep in hours
       (default=1 hour as defined in climada_global.tc.default_min_TimeStep)
 OUTPUTS:
   tc_track: a tc_track structure, with equal timesteps and copy of
       time-independent fields
 MODIFICATION HISTORY:
 David N. Bresch, david_bresch@gmail.com, 20040911, 20081006
 Mathias Hauser, 20120507
 Lea Mueller, 20121203
 David N. Bresch, david_bresch@gmail.com, 20040911, new version of MATLAB does not like adding empty stuff
 David N. Bresch, david_bresch@gmail.com, 20141231, datevecmx replaced
 David N. Bresch, david_bresch@gmail.com, 20150103, simplified (a lot)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/climada_tc_equal_timestep_OLD.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_topotool">
<H2>climada_topotool</H2></A>
<font color="blue">function [topo,precip]=climada_topotool(topo,precip,n_times,show_plot) </font>
 climada template
 MODULE:
   module name
 NAME:
   climada_topotool
 PURPOSE:
   Route precipitation n_times trough a topography. Can be called
   interatively to 'animate' the routing

   Assumtion: equally spaced grid (cells must be square)
 CALLING SEQUENCE:
   [topo,precip]=climada_topotool(topo,precip,n_times)
 EXAMPLE:
   climada_topotool([],[],1,1)% TEST mode
   [topo,precip]=climada_topotool(etopo_get([7 8 46 46.5]),[],1,1); % Valais
 INPUTS:
   topo: a topography structure with fields
       h(i,j): the elevation (in any unit).
           If empty, a TEST topography [range 0..1] is used
       x(i,j): the x coordinate (optional, dummy created if show_plot=1)
       y(i,j): the y coordinate (optional, dummy created if show_plot=1)
       flow_target(I): the index cell (I) is draining to. Calculated if
           not existing (but can be passed for subsequent calls to route
           runoff only, as usually the case when working with one 
           (tile of) a DEM)
   precip: the preciptiation array, same dimension as topo.h(i,j). Unites
       irrelevant except for plotting, where scaled to min..max of topo.h 
       if empty, a TEST precipitation of 0.5 [dummy unit] per cell is assumed
   n_times: the number of timesteps the flood is routed from cell to cell
       default=1
   show_plot: =1 show plot, =0 no plots (default, obviously faster)
       =2: show a plot each timestep and wait for user to press any key to
       observe routing step-by-step
 OPTIONAL INPUT PARAMETERS:
   param2: as an example
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160124
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/climada_topotool.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_EDS_adjust">
<H2>cr_EDS_adjust</H2></A>
<font color="blue">function EDS = cr_EDS_adjust(EDS) </font>
 adjust the damages in a EDS
 MODULE:
   country_risk
 NAME:
   cr_EDS_adjust
 PURPOSE:
   Adjust the damages by multiplying them with country-specific factors
   that are based on expert judgment and comparison with target values
   provided by other models.
   The resulting damages provide the basis for the final climada
   model results of a country's expected losses over the return period(s)
   one is interested in.

   It adds the field damage_factor_applied to EDS, which =0
   for unadjusted, otherwise the adjustment factor (=1 identity, i.e.
   neutral adjustment).

   Prior call (called from): cr_EDS_adjust_all
 CALLING SEQUENCE:
   EDS = cr_EDS_adjust(EDS)
 EXAMPLE:
   EDS = climada_EDS_calc
   EDS = cr_EDS_adjust(EDS)
 INPUTS:
   EDS: a climada event damage set, see climada_EDS_calc
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   EDS: EDS with adjusted damages
       field EDS.damage_factor_applied set to adjustment factor
 NOTE:
   The function does not check whether a given input EDS has already been
   adjusted or not since no additional features (e.g. an 'adjustment
   flag') should be added to the input EDS. Thus, the function that calls
   cr_EDS_adjust (or the user) needs to make sure of that.

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150218, initial
 david.bresch@gmail.com, 20150715, HKG added
 david.bresch@gmail.com, 20150716, WSEU replaced by WS
 david.bresch@gmail.com, 20150721, EDS.damage_factor_applied
 david.bresch@gmail.com, 20150803, USA EQ redone
 david.bresch@gmail.com, 20150817, all replaced with latest factors
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/cr_EDS_adjust.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_EDS_adjust_all">
<H2>cr_EDS_adjust_all</H2></A>
<font color="blue">function country_risk=cr_EDS_adjust_all(country_risk) </font>
 climada country risk
 MODULE:
   country_risk
 NAME:
   cr_EDS_adjust_all
 PURPOSE:
   Adjusts all EDSs in a country_risk result structure (see
   country_risk_calc). You might either call this prior to
   country_risk_EDS_combine, in which case it treats all sub-perils (e.g.
   TC and TS separately), or after country_risk_EDS_combine, in which case
   it treats the main perils (e.g. TC)

   This code just calls cr_EDS_adjust for each single EDS in
   country_risk. It adds the field damage_factor_applied to EDS, which =0
   for unadjusted, otherwise the adjustment factor (=1 identity, i.e.
   neutral adjustment).

   prior call: country_risk_calc or country_risk_EDS_combine.
 CALLING SEQUENCE:
   country_risk=cr_EDS_adjust_all(country_risk)
 EXAMPLE:
   country_risk=cr_EDS_adjust_all(country_risk)
 INPUTS:
   country_risk: a structure as returned by country_risk_calc
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   country_risk: the same structure as returned by country_risk_calc,
       with all EDSs adjusted, plus a field
       country_risk(country_i).res.hazard(hazard_i).EDS_adjusted=1 added
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150216, initial
 David N. Bresch, david.bresch@gmail.com, 20150219, renamed from cr_damagefunction_adjust to cr_EDS_adjust
 David N. Bresch, david.bresch@gmail.com, 20150721, major revision, switch to damage_factor_applied instead if adjusted as a field
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/cr_EDS_adjust_all.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="cr_region_peril_TEST">
<H2>cr_region_peril_TEST</H2></A>
 cr_region_peril_TEST
 TC/TS atl
 ---------
 USA looks perfect, good match EM-DAT and cmp
 Panama ok, EM-DAT would indicate higher (but return period with 2 damages?)
 Mexico also very good (at high req good match with EM-DAT an cmp), steep
   increase &ampgt200yr, hence 250yr climada damage too high, but 100 yr fine
 Dominican Republic: climada TC originally too high, adjusted to get close to
   EM-DAT, climada TS far too high adjusted down to get close to EM-DAT
 Costa Rica: unchanged, looks pretty steep, but range of EM-DAT indicates
   that we're too cheap for say 20yr, but might be about ok for 100+ years)
 Colombia looked like Dominican Republic, hence same adjustment, now good
   fit with EM-DAT
 annual aggregate looks really good, almost too got match with EM-DAT
ountry_list={ % atl exposed from selected_countries_all_in_one
   'Colombia'
   'Costa Rica'
   'Dominican Republic'
   'Mexico'
   'Panama'
   'United States'
   };
eril_ID=['atl_TC';'atl_TS'];
ountry_risk_calibrate(country_list); % to be on the safe side
ountry_risk=country_risk_calc(country_list,-7,0,0,peril_ID); % calc EDS
r_DFC_plot(country_risk_EDS_combine(country_risk),[],[],0.05,1)
r_DFC_plot_aggregate(country_risk,[],0.05,1)
lear country_risk
 TC/TS nio
 ---------
 Pakistan: climada very low, but left as is (TC not a big threat there)
 India: climada much lower than EM-DAT, but substatially higher than cmp, left as is
 Bangladesh: climada much lower than EM-DAT, left as is for the time being
   annual aggregate combined looks reasonable, a bit ower than EM-DAT
 Myanmar hard to compare, not adjusted
ountry_list={'Bangladesh','India','Pakistan','Myanmar'}; % nio exposed from selected_countries_all_in_one
eril_ID=['nio_TC';'nio_TS'];
ountry_risk_calibrate(country_list); % to be on the safe side
ountry_risk=country_risk_calc(country_list,-7,0,0,peril_ID); % calc EDS
r_DFC_plot(country_risk_EDS_combine(country_risk),[],[],0.07,1)
r_DFC_plot_aggregate(country_risk,[],0.07,1)
lear country_risk
 TC/TS wpa
 ---------
 Vietnam looks ok, good match with EM-DAT
 Thailand ok, might be too low, good match with EM-DAT unindexed, kept for the time being
 Taiwan was completly off (and EM-DAT is at least an order of magnitude
   lower than cmp. clmada adjusted to match cmp for 250 yr (still far above EM-DAT)
 Korea adjusted to be cloase to EM-DAT
 Singapore not adjusted (no EM-DAT)
 Philippines adjusted to match EM-DAT (and getting in the cmp range, too)
 Myanmar moved to nio
 Laos no further adjustment, only 2 EM-DAT points, range of 200yr event
   covered by mac EM-DAT
 Japan TS adjusted to be in EM-DAT range (upper bound at 5% CAGR, only one point), TC also adjusted, but shape not
   really nicee. Does compare well with cmp for 100 yr, 250 yr rather high
   end
 Indonesia no adjustment, no EM-DAT
 China: 12% CAGR, TC tuned to upper bound of EM-DAT (as in China, the
   asset base grew at least as much as GDP), compares very well with cmp
ountry_list={ % wpa exposed from selected_countries_all_in_one
   'Cambodia'
   'China'
   'Indonesia'
   'Japan'
   'Laos'
   'Philippines'
   'Singapore'
   'Korea'
   'Taiwan'
   'Thailand'
   'Vietnam'
   };
eril_ID=['wpa_TC';'wpa_TS'];
ountry_risk_calibrate(country_list); % to be on the safe side
ountry_risk=country_risk_calc(country_list,-7,0,0,peril_ID); % calc EDS
r_DFC_plot(country_risk_EDS_combine(country_risk),[],[],0.085,1) % 8.5% (0.085) CAGR for the region
r_DFC_plot_aggregate(country_risk,[],0.085,1) % 8.5% (0.085) CAGR for the region
lear country_risk
 TC/TS she
 ---------
 Australia TS matches well, TS massively adjusted (was far too high)
   combined ow matchinf EM-DAT (upper end) and cmp (very well)
 Indonesia TC and TS manually adjusted (no EM-DAT) to be correct order of
   magnitude
 New Zealand same as Indonesia, but not much TC/TS exposed
ountry_list={ % TC she exposed from selected_countries_all_in_one
   'Australia'
   'Indonesia'
   'New Zealand'
   };
eril_ID=['she_TC';'she_TS'];
ountry_risk_calibrate(country_list); % to be on the safe side
ountry_risk=country_risk_calc(country_list,-7,0,0,peril_ID); % calc EDS
r_DFC_plot(country_risk_EDS_combine(country_risk),[],[],0.05,1) % 5% (0.05) CAGR for the region
r_DFC_plot_aggregate(country_risk,[],0.05,1) % 5% (0.05) CAGR for the region
lear country_risk
 EQ glb
 ------
ountry_list={ % EQ glb exposed from selected_countries_all_in_one
   'Algeria'
   'Australia'
   'Austria'
   'Bangladesh'
   'Brazil'
   'Canada'
   'Chile'
   'China'
   'Colombia'
   'Costa Rica'
   'Dominican Republic'
   'Ecuador'
   'France'
   'Germany'
   'Greece'
   'Hungary'
   'India'
   'Indonesia'
   'Israel'
   'Italy'
   'Japan'
   'Kenya'
   'Laos'
   'Mexico'
   'Morocco'
   'Myanmar'
   'Netherlands'
   'New Zealand'
   'Pakistan'
   'Panama'
   'Peru'
   'Philippines'
   'Portugal'
   'Slovenia'
   'South Africa'
   %'Switzerland' % no hazard set at the moment
   'Korea'
   'Spain'
   'Taiwan'
   'Thailand'
   'Turkey'
   'United Kingdom'
   'United States'
   'Vietnam'
   };
eril_ID='glb_EQ';
ountry_risk_calibrate(country_list); % to be on the safe side
ountry_risk=country_risk_calc(country_list,-7,0,0,peril_ID); % calc EDS
r_DFC_plot(country_risk_EDS_combine(country_risk),[],[],0.05,1) % 5% CAGR globally
r_DFC_plot_aggregate(country_risk,[],0.05,1) % % 5% CAGR globally
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/cr_region_peril_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="global_max_damage">
<H2>global_max_damage</H2></A>
 global_max_damage
 MODULE:
   LOCAL
 NAME:
   global_max_damage
 PURPOSE:
   calculate largest combined TC (tropical cyclone wind) &amp TS (storm
   surge) damage as % of GDP for a given country 
   and show max EQ (earthquake) for comparison

   requires climada core, tc_advanced, GDP_entity, country_risk and
   tc_surge modules in case entity (asset base) and hazard event sets do
   not exist yet, otherwise only core climada (if hazards etc provided)
 CALLING SEQUENCE:
   global_max_damage % a batch file
 EXAMPLE:
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150822
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/global_max_damage.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="hazards_2digit_perilID">
<H2>hazards_2digit_perilID</H2></A>
 hazards_2digit_perilID
lobal climada_global
 folder_name=[climada_global.data_dir filesep 'hazards'];
=dir([folder_name filesep '*_eur_WS.mat']);
or D_i=1:length(D)
   if ~D(D_i).isdir
       src_file=[folder_name filesep D(D_i).name];
       [fP,fN,fE]=fileparts(src_file);
       fprintf('%s\n',src_file);
         load(src_file)
         hazard.peril_ID=hazard.peril_ID(1:2);
         save(src_file,'hazard');
   end
nd % D_i
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/hazards_2digit_perilID.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="hazards_filename_consistency">
<H2>hazards_filename_consistency</H2></A>
 hazards_filename_consistency
 in case hazard.filename is not really the actual filename, climada might
 have troubles e.g. creating the YDS (since it needs to re-load the hazard
 event set to make use of the yearset)
 this code checks for hazard.filename to contain the actual filename
lobal climada_global
older_name=[climada_global.data_dir filesep 'hazards'];
folder_name=[climada_global.data_dir filesep 'hazards' filesep 'TR'];
folder_name=[climada_global.data_dir filesep 'hazards' filesep '_OFF'];
=dir([folder_name filesep '*.mat']);
or D_i=1:length(D)
   if ~D(D_i).isdir
       hazard_file=[folder_name filesep D(D_i).name];
       
       load(hazard_file)
       
       [~,fN_file]=fileparts(hazard_file);
       [~,fN_save]=fileparts(hazard.filename);
       
       if ~strcmp(fN_file,fN_save)
           fprintf('mismatch: %s in hazard: %s\n',fN_file,fN_save);
           
           hazard.filename=hazard_file;
           %hazard.filename=strrep(hazard_file,'/TR',''); % SPECIAL TR
           %hazard.filename=strrep(hazard_file,'/_OFF',''); % SPECIAL _OFF
           
           save(hazard_file,'hazard');
       end
       
   end
nd % D_i
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/hazards_filename_consistency.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="inspect_VULN">
<H2>inspect_VULN</H2></A>
 inspect_VULN
lobal climada_global
 PARAMETERS

 define the peril and region
eril_ID='TC';

 define country and VULNGEOID (see at bottom of this script
country_name='China';peril_region='wpa';VULNGEOID='TCCN0010'; %'TCUS0010';
country_name='United States';peril_region='atl';VULNGEOID='TCUS0010';
country_name='Australia';peril_region='she';VULNGEOID='TCAU0010';
ountry_name='Philippines';peril_region='wpa';VULNGEOID='TCPH0010';

 whether we print some info
erbose=0; % default=0
 
 unique ID for damagefunction (unlikely to change)
nique_ID_sel=[peril_ID ' 001'];

 further selection criteria (unlikely to change)
ISKTYPEID='RESI'; % RESI,AGRI,COMM,ENST,HULL,INDS
CCL1ID='REMX'; %REMH,REML,REMM,REMO,REMX,RESF
OCCL2ID='GENR';
CONSTRID='GENR';
OVERID='BLD';
 China:
 &ampgt&ampgt EM-DAT: climada scaling factor 0.059897
 &ampgt&ampgt with intens/1.15, we get EM-DAT: climada scaling factor 0.133665

 USA: all ok, no tuning needed
 AUS: all ok, no tuning needed
 Philippines:
 &ampgt&ampgt&ampgt EM-DAT: climada scaling factor 0.071783
country_name,country_ISO3]=climada_country_name(country_name);
ntity_file=[climada_global.data_dir filesep 'entities' filesep ...
   country_ISO3 '_' strrep(country_name,' ','') '_entity.mat'];
azard_file=[climada_global.data_dir filesep 'hazards' filesep ...
   country_ISO3 '_' strrep(country_name,' ','') '_' peril_region '_' peril_ID '.mat'];
mp_file   =[climada_global.data_dir filesep 'results' filesep ...
   'cmp_results' filesep peril_ID filesep country_ISO3 '_' ...
   strrep(country_name,' ','') '_' peril_region '_' peril_ID '_cmp_results.xlsx'];
ntity=climada_entity_load(entity_file);
es=climada_damagefunctions_plot(entity,'TC 001'); % obtain the damage function
 damage function
 ---------------
 plot climada
lose all
amfun_fig=figure('Color',[1 1 1]);legend_str={};
lot(res.Intensity,res.MDR,'-b','LineWidth',2);hold on
egend_str{end+1}='MDR';
lot(res.Intensity,res.MDD,'-b');
egend_str{end+1}='MDD';
lot(res.Intensity,res.PAA,'-g');
egend_str{end+1}='PAA';
xis tight
et(get(gcf,'CurrentAxes'),'YLim',[0 1]);
label('Intensity','FontSize',9);
label('MDR')
itle([country_name ' ' unique_ID_sel]);
rid on
rid minor
 compare with km21
oad('/Users/bresch/Documents/ETH_lecture/material/km21/km21_data/vulnerability/MSP_VULNERABILITY.mat')
f verbose,VULNGEOIDs=unique(MSP_VULNERABILITY.MAP.VULNGEOID(:,:),'rows'),end
os=strmatch(VULNGEOID,MSP_VULNERABILITY.MAP.VULNGEOID(:,:));
f verbose,RISKTYPEIDs=unique(MSP_VULNERABILITY.MAP.RISKTYPEID(pos,:),'rows'),end
os2=strmatch(RISKTYPEID,MSP_VULNERABILITY.MAP.RISKTYPEID(:,:));
os=intersect(pos,pos2);
f verbose,COVERIDs=unique(MSP_VULNERABILITY.MAP.COVERID(pos,:),'rows'),end
os2=strmatch(COVERID,MSP_VULNERABILITY.MAP.COVERID(:,:));
os=intersect(pos,pos2);
  MSP_VULNERABILITY.MAP.VULNGEOID(pos,:)
  MSP_VULNERABILITY.MAP.RISKTYPEID(pos,:)
  MSP_VULNERABILITY.MAP.OCCL1ID(pos,:)
  MSP_VULNERABILITY.MAP.OCCL2ID(pos,:)
  MSP_VULNERABILITY.MAP.CONSTRID(pos,:)
  MSP_VULNERABILITY.MAP.COVERID(pos,:)
f verbose,OCCL1IDs=unique(MSP_VULNERABILITY.MAP.OCCL1ID(pos,:),'rows'),end
os2=strmatch(OCCL1ID,MSP_VULNERABILITY.MAP.OCCL1ID(:,:));
os=intersect(pos,pos2);
  if verbose,OCCL12Ds=unique(MSP_VULNERABILITY.MAP.OCCL2ID(pos,:),'rows'),end
  pos=strmatch(OCCL2ID,MSP_VULNERABILITY.MAP.OCCL2ID(pos,:));
  if verbose,CONSTRIDs=unique(MSP_VULNERABILITY.MAP.CONSTRID(pos,:),'rows'),end
  pos=strmatch(CONSTRID,MSP_VULNERABILITY.MAP.CONSTRID(pos,:));
f verbose
   MSP_VULNERABILITY.MAP.VULNGEOID(pos,:)
   MSP_VULNERABILITY.MAP.RISKTYPEID(pos,:)
   MSP_VULNERABILITY.MAP.OCCL1ID(pos,:)
   MSP_VULNERABILITY.MAP.OCCL2ID(pos,:)
   MSP_VULNERABILITY.MAP.CONSTRID(pos,:)
   MSP_VULNERABILITY.MAP.COVERID(pos,:)
nd
ULNCURVEID=MSP_VULNERABILITY.MAP.VULNCURVEID(pos);
urve_i=find(MSP_VULNERABILITY.VulnCurveID==VULNCURVEID);
f verbose
   MSP_VULNERABILITY.curve(curve_i).INTENSITY
   MSP_VULNERABILITY.curve(curve_i).MDR
nd
old on
lot(MSP_VULNERABILITY.curve(curve_i).INTENSITY,MSP_VULNERABILITY.curve(curve_i).MDR,'-m','LineWidth',2);
egend_str{end+1}='MDR comp';
egend(legend_str,'Location','NorthWest');
amfun_legend_str=legend_str;
 EDS comparison
 --------------
DS_fig=figure('Color',[1 1 1]);legend_str={};
oad(hazard_file)
hazard.intensity=hazard.intensity/1.15; % reduce intensity
DS=climada_EDS_calc(entity,hazard);
FC=climada_EDS2DFC(EDS);
lot(DFC.return_period,DFC.damage,':b','LineWidth',2); hold on
egend_str{end+1}='climada raw';
 use EM-DAT information to calibrate, if available
m_data=emdat_read('',entity.assets.admin0_name,char(hazard.peril_ID(1:2)),1,0);
f ~isempty(em_data)
   
   % calculate climada DFC on EM-DAT return periods
   DFC_0=climada_EDS2DFC(EDS,em_data.DFC.return_period);
   
   % figure adjustment factor for climada to match EM-DAT
   climada2emdat_factor=em_data.DFC.damage./DFC_0.damage;
   
   DFC_weight_pos=em_data.DFC.return_period&ampgt20 &amp DFC_0.damage&ampgt0; % we look into &ampgt20 years
   if ~isempty(DFC_weight_pos)
       % weight the factor, in order to only have one global
       climada2emdat_factor_weighted=climada2emdat_factor(DFC_weight_pos)*...
           em_data.DFC.return_period(DFC_weight_pos)'/sum(em_data.DFC.return_period(DFC_weight_pos));
       fprintf('EM-DAT: climada scaling factor %f\n',climada2emdat_factor_weighted);
       
       figure(damfun_fig);
       plot(res.Intensity,res.MDR*climada2emdat_factor_weighted,':b','LineWidth',2);
       damfun_legend_str{end+1}='MDR adj';
       legend(damfun_legend_str,'Location','NorthWest');
       
       figure(EDS_fig)
       
   else
       climada2emdat_factor_weighted=1.0;
       fprintf('EM-DAT: no adjustment (not enough EM-DAT data)\n');
   end
   
   % adjust damagefunctions (the crude way)
   entity.damagefunctions.MDD=entity.damagefunctions.MDD*climada2emdat_factor_weighted;
   
   % re-calculate using adjusted damage function
   EDS=climada_EDS_calc(entity,hazard);
   
   %     % and, since a linear scale, we omit fgu recaculation
   %     EDS.damage=EDS.damage*climada2emdat_factor_weighted;
   DFC=climada_EDS2DFC(EDS); % same return periods as comparison
nd % em_data
 show adjusted climada
lot(DFC.return_period,DFC.damage,'-b','LineWidth',2); hold on
egend_str{end+1}='climada';
 show comparison
FC_cmp=climada_DFC_read(cmp_file);
lot(DFC_cmp.return_period,DFC_cmp.damage,'-k','LineWidth',1); hold on
egend_str{end+1}='cmp';
 add EM-DAT information if available
f ~isempty(em_data)
   if isfield(em_data,'DFC_orig')
       plot(em_data.DFC.return_period,em_data.DFC.damage,'xg'); hold on
       legend_str{end+1}=em_data.DFC.annotation_name;
       plot(em_data.DFC.return_period,em_data.DFC_orig.damage,'og'); hold on
       legend_str{end+1}=em_data.DFC_orig.annotation_name;
   else
       plot(em_data.DFC.return_period,em_data.DFC.damage,'og'); hold on
       legend_str{end+1}=em_data.DFC.annotation_name;
   end
nd
 set to cmp damage funtion
ntity.damagefunctions.Intensity=[0 20 30 40 50 60 70 80 100];
ntity.damagefunctions.MDR=[0 0 0.0000 0.0000 0.0004 0.0054 0.0584 0.1694 0.1694];
ntity.damagefunctions.MDD=entity.damagefunctions.MDR;
ntity.damagefunctions.PAA=entity.damagefunctions.MDR*0+1;
ntity.damagefunctions.DamageFunID=entity.damagefunctions.MDR*0+1;
ntity.damagefunctions.peril_ID=entity.damagefunctions.peril_ID(1:length(entity.damagefunctions.MDR));
 re-calculate using comparison damage function
DS_adj=climada_EDS_calc(entity,hazard);
FC_adj=climada_EDS2DFC(EDS_adj);
lot(DFC_adj.return_period,DFC_adj.damage,':m','LineWidth',2); hold on
egend_str{end+1}='climada cmp damage fun';
egend(legend_str)
xis tight
et(get(gcf,'CurrentAxes'),'XLim',[0 250]);
label('Return period','FontSize',9);
label('damage')
rid on
rid minor
itle([country_name ' ' unique_ID_sel]);
 % VULNGEOIDs are
 
 TC          
 TC120707    
 TC161010    
 TC191111    
 TC211111    
 TC241313    
 TC261414    
 TC302424    
 TCAF0010    
 TCAU0010    
 TCAUS01A    
 TCAUS01B    
 TCAUS01C    
 TCAUS01D    
 TCAUS01E    
 TCCN0010    
 TCGP0010    
 TCGU0010    
 TCHA0010    
 TCHK0010    
 TCIN0010    
 TCJP0010    
 TCMA0010    
 TCMQ0010    
 TCMX0010    
 TCNI0010    
 TCNI0011    
 TCNODEEP    
 TCNOMEDM    
 TCNOSHLW    
 TCNOSHMD    
 TCPH0010    
 TCPR0010    
 TCRE0010    
 TCSI0011    
 TCSI0012    
 TCSK0010    
 TCTW0010    
 TCUS0010    
 TCUS0020    
 TCUS0030    
 TCUS0040    
 TCVI0010    
 TCZZ0010    
 WSAUT       
 WSBEL       
 WSCHE       
 WSDEU       
 WSDNK       
 WSFRA       
 WSGBR       
 WSIRL       
 WSLUX       
 WSNLD       
 WSNOR       
 WSSWE  
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/inspect_VULN.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="move_hazards">
<H2>move_hazards</H2></A>
 move_hazards
lobal climada_global
folder_name=[climada_global.data_dir filesep 'hazards' filesep '_h'];
older_name=[climada_global.data_dir filesep 'hazards'];
=dir([folder_name filesep '*.mat']);
D=dir([folder_name filesep '*_p.mat']);
or D_i=1:length(D)
   if ~D(D_i).isdir
       src_file=[folder_name filesep D(D_i).name];
       
       dst_file=strrep(src_file,'EQ_global','glb_EQ');
       
       dst_file=strrep(dst_file,'WS_Europe','eur_WS');
       
       dst_file=strrep(dst_file,'TC_atl','atl_TC');
       dst_file=strrep(dst_file,'TC_epa','epa_TC');
       dst_file=strrep(dst_file,'TC_nio','nio_TC');
       dst_file=strrep(dst_file,'TC_she','she_TC');
       dst_file=strrep(dst_file,'TC_wpa','wpa_TC');
       
       dst_file=strrep(dst_file,'TS_atl','atl_TS');
       dst_file=strrep(dst_file,'TS_epa','epa_TS');
       dst_file=strrep(dst_file,'TS_nio','nio_TS');
       dst_file=strrep(dst_file,'TS_she','she_TS');
       dst_file=strrep(dst_file,'TS_wpa','wpa_TS');
       
       dst_file=strrep(dst_file,'TR_atl','atl_TR');
       dst_file=strrep(dst_file,'TR_epa','epa_TR');
       dst_file=strrep(dst_file,'TR_nio','nio_TR');
       dst_file=strrep(dst_file,'TR_she','she_TR');
       dst_file=strrep(dst_file,'TR_wpa','wpa_TR');
       
       
       fprintf('dest: %s\n',dst_file)
       if ~movefile(src_file,dst_file)
           fprintf('ERROR: %s not moved\n',src_file)
       end
   end
nd % D_i
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/move_hazards.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="ncread_TEST">
<H2>ncread_TEST</H2></A>
 ncread_TEST
ilename='/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/data/volcanoes/wind_data.nc';
FINFO = ncinfo(filename);
=ncread(filename,'u'); % u(lon,lat,P_level,month)
=ncread(filename,'v');
el=ncread(filename,'speed'); % m/s
=ncread(filename,'X');
=ncread(filename,'Y');
=ncread(filename,'P');
T=ncread(filename,'T');
on=14.426;lat=40.821; % Vesuvius
ressure_level=500; % in mb
 find position in matrix
xpos,xi]=min(abs(X-lon));
ypos,yi]=min(abs(Y-lat));
ppos,pi]=min(abs(P-pressure_level));
 obtain wind speed and direction climatology
_vel_clim=squeeze(vel(xi,yi,pi,:))*3.6; % km/h
_phi_clim=squeeze(atan2(v(xi,yi,pi,:),u(xi,yi,pi,:))); % four quadrant arctangent in radion (-pi&amplt=atan2(Y,X)&amplt= pi, in degree: ./pi*180
_vel=mean(U_vel_clim);
_phi=mean(U_phi_clim);
_phi/pi*180
_vel
ist(U_phi/pi*180)
eturn
(X&ampgt180)=X(X&ampgt180)-360; % date is 0..360, we need -180..180 for plots
x,y]=meshgrid(X,Y); % create the x/y grid
igure
limada_plot_world_borders
ontour(x',y',u(:,:,level,month))
itle('u');
igure
limada_plot_world_borders
ontour(x',y',v(:,:,level,month))
itle('v');
igure
limada_plot_world_borders
ontour(x',y',vel(:,:,level,month))
olorbar
itle('vel');
printf('max vel %f km/h\n',max(max(vel(:,:,level,month)))*3.6);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/ncread_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="selected_countries_all_in_one_SPECIAL">
<H2>selected_countries_all_in_one_SPECIAL</H2></A>
 selected_countries_all_in_one_SPECIAL
 climada template
 MODULE:
   module name
 NAME:
   selected_countries_all_in_one, run all project countries, all calculations

   run as a batch code, such that all is available on command line
 PURPOSE:
   Run all climada for project

   In order to synchronize all entities with GDP etc, country_risk_calc
   uses climada_entity_value_GDP_adjust

 CALLING SEQUENCE:
   selected_countries_all_in_one
 EXAMPLE:
   selected_countries_all_in_one
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150105
 David N. Bresch, david.bresch@gmail.com, 20150116, almost complete
 David N. Bresch, david.bresch@gmail.com, 20150121, GDP adjust added
 David N. Bresch, david.bresch@gmail.com, 20150121, GDP adjust added
 David N. Bresch, david.bresch@gmail.com, 20150215, country calibration added at the bottom (all commented out, see there)
 David N. Bresch, david.bresch@gmail.com, 20150225, figure name added
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/selected_countries_all_in_one_SPECIAL.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="selected_countries_region_peril">
<H2>selected_countries_region_peril</H2></A>
 selected_countries_region_peril
 climada batch code
 MODULE:
   country_risk
 NAME:
   selected_countries_region_peril
 PURPOSE:
   Run all countries for a given peril (e.g. TC) and region (e.g. atl)
   in order to e.g. adjust damage functions for this peril and region.
   On first call, you might have to set peril_region='' in order to
   generate all hazard event sets.

   It generates all entities (the assets) and hazard event sets and
   calculates damages. In essence, a clever caller to country_risk_calc

   Subsequent calls just repeat the damage calculations (unless you set
   country_risk_calc_force_recalc=1).
   Thus if you repeat the second step, since all hazard sets are stored, it will
   be fast and easy to play with parameters (e.g. damage functions).

   run as a batch code, such that all is available on command line, all
   PARAMETERS are set in this file, see section below

 CALLING SEQUENCE:
   peril_region='nio';selected_countries_region_peril % batch code
 EXAMPLE:
   selected_countries_region_peril % a batch code
 INPUTS:
   see PARAMETERS in this batch code
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   produce a report (.csv, see PARAMETER damage_report_filename) and a
   graph with regional (and annual) aggregate damage frequency curve, plus
       comparison with (indexed) EM-DAT damages
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150207, initial
 David N. Bresch, david.bresch@gmail.com, 20150213, substantially reduced, will be obsolete soon
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/selected_countries_region_peril.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="sparse_TEST">
<H2>sparse_TEST</H2></A>
 sparse_TEST
oad('/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_data/hazards/TCNA_today_small.mat');
igure
py(hazard.intensity(1:100,:))
nz(hazard.intensity)
azard_ok=hazard;
oad('/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_data/hazards/TCNA_today_small_v73.mat');
 size(hazard.intensity.jc) 51
 size(hazard.intensity.ir) 101092
printf('allocating %i x %i\n',hazard.event_count,length(hazard.intensity.jc)-1);
 allocate
ntensity=zeros(hazard.event_count,length(hazard.intensity.jc)-1);
parse_i=hazard.intensity.data*0;
parse_j=hazard.intensity.data*0;
or j=1:length(hazard.intensity.jc)-1
   for i=hazard.intensity.jc(j)+1:hazard.intensity.jc(j+1)
         fprintf('non-zero element (%i,%i) is %d\n',...
              hazard.intensity.ir(i+1),j,hazard.intensity.data(i+1));
       intensity(hazard.intensity.ir(i)+1,j)=hazard.intensity.data(i);
       
       sparse_i(i)=hazard.intensity.ir(i)+1;
       sparse_j(i)=j;
   end
nd
igure
py(intensity(1:100,:))
nz(intensity)
azard_ok.intensity(11,1)
ntensity(11,1)
 checksum
um(sum(hazard_ok.intensity-intensity))
ize(sparse_i)
=sparse(sparse_i,sparse_j,hazard.intensity.data,floor(hazard.event_count),length(hazard.intensity.jc)-1);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/sparse_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="toggle_SP">
<H2>toggle_SP</H2></A>
 toggle_SP: to switch main data folder to S&ampP project
 20150819 centroids_dir added
f strfind(climada_global.data_dir,'climada_data_SP')
   climada_global.data_dir=strrep(climada_global.data_dir,'climada_data_SP','climada_data');
   climada_global.centroids_dir=strrep(climada_global.centroids_dir,'climada_data_SP','climada_data');
   fprintf('NOTE: switched to back to standard data folders\n');
lse
   climada_global.data_dir=strrep(climada_global.data_dir,'climada_data','climada_data_SP');
   climada_global.centroids_dir=strrep(climada_global.centroids_dir,'climada_data','climada_data_SP');
   fprintf('NOTE: switched to S&ampP project data folders, system and tc_track NOT switched\n');
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/toggle_SP.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="usgs_warnig_map_retrieve">
<H2>usgs_warnig_map_retrieve</H2></A>
<font color="blue">function [img,info]=usgs_warnig_map_retrieve(yyyy,mm,dekad,check_plot) </font>
 usgs warnig map retrieve
 MODULE:
   _LOCAL
 NAME:
   usgs_warnig_map_retrieve
 PURPOSE:
   Retrieve warning map from USGS
   See http://earlywarning.usgs.gov/fews/product/133
 CALLING SEQUENCE:
   img=usgs_warnig_map_retrieve(yyyy,mm,dekad,check_plot)
 EXAMPLE:
   [img,info]=usgs_warnig_map_retrieve(2016,05,2,1);
   for yyyy=2003:2016,for mm=1:12,img=usgs_warnig_map_retrieve(yyyy,mm,1,0);end;end % all
 INPUTS:
   yyyy: year (4 digits)
   mm: month
   dekad: =1,2 or 3
 OPTIONAL INPUT PARAMETERS:
   check_plot: =1, plot the data (=0 not, default)
 OUTPUTS:
   img: the image
   info: the image info, see imfinfo
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20160531, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_LOCAL/code/usgs_warnig_map_retrieve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="slv_explorer">
<H2>slv_explorer</H2></A>
<font color="blue">function slv_explorer(show_plot) </font>
 climada
 MODULE
   SLV
 NAME:
   slv_explorer
 PURPOSE:
   explore content of shape files in SLV module

   see www.diva-gis.org/gdata

 CALLING SEQUENCE:
   slv_explorer
 EXAMPLE:
   slv_explorer
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   show_plot: whether we show plot (=1, default)
       or not (=0, just save it)
 OUTPUTS:
   just a figure with content of shapes files plotted
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150225, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_SLV/code/slv_explorer.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="BATCH_exercise">
<H2>BATCH_exercise</H2></A>
<font color="blue">function BATCH_exercise(skip_TC_hazard_event_set,full_TC_track_file_switch,check_climada_switch) </font>
 climada exercise test BATCH
 NAME:
   BATCH_exercise
 PURPOSE:
   Test the climada exercise - the present code calculates all the steps
   required for successful completion of the climada exercise, as
   described in the exercise sheet exercise_2_FS2013_V1 (or similar, year
   will change), see also www.iac.ethz.ch/edu/courses/master/modules/climate_risk

   NOTE: to test whether the parameters for the adaptation measures really
   make sense, use full_TC_track_file_switch=1, since otherwise the hazard
   event set is (too) small to obtain reasonable results for the
   adaptation cost curve. But to test whether all works, running with all
   default parameters BATCH_exercise(0,0,0) is ok - only the final adaptation 
   cost curve will not look very reasonable
 CALLING SEQUENCE:
   BATCH_exercise
 EXAMPLE:
   BATCH_exercise % default, test full exercise
   BATCH_exercise(0,1,1) % check climada with full TC hazard set
   BATCH_exercise(1,1,1) % previous call once the TC hazard sets have been
       %generated (which takes each time a few minutes). Used to e.g. check
       %whether waterfal graph still works properly...
 INPUTS:
   param1: 
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   skip_TC_hazard_event_set: whether we start from scratch (=0, default)
       or check based on already created hazard sets (=1). 
       Since climada changes might rather affect all the subsequent steps,
       hence re-testing whether the hazard creation works, is not always
       necessary)
   full_TC_track_file_switch: which TC track data base to use (default=0): 
       - Either the TEST (10yrs, fast; =0) or 
       - the full (100yrs, takes some minutes, =1) TC track database
   check_climada_switch: whether we test the exercise (=0) or the original
       climada (=1). It mainly affects where the test files are searched for.
       For the case check_climada_switch=1, entity files need to be in
       ../climada/data/entities, not in
       ../climada_additional/exercise_solutions/data/entities
 OUTPUTS:
   several files written (hazard event sets, encoded entities, results...
   and graphics, just as they should appear if climada exercise is solved
   correctly.
 MODIFICATION HISTORY:
 Reto Stockmann, 20120918, updated inputs to run within the solution module
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS...
 David N. Bresch, david.bresch@gmail.com, 20130317 allow to skip hazard set testing
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_exercise_solutions/code/BATCH_exercise.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_naturalearthdata_add">
<H2>climada_naturalearthdata_add</H2></A>
<font color="blue">function shapes=climada_naturalearthdata_add(naturalearthdata_file,linewidth,fill_color) </font>
 climada
 NAME:
   climada_naturalearthdata_add
 PURPOSE:
   add naturalearthdat shape(s) to an existing plot, e.g. to add Admin
   (file ne_50m_admin_0_boundary_lines_land.shp or
   ne_50m_admin_1_states_provinces_lines.shp) or urban areas (file
   ne_50m_urban_areas.shp) or...
 CALLING SEQUENCE:
   climada_naturalearthdata_plot(linewidth,keep_boundary,annotate_places,urban_areas)
 EXAMPLE:
   climada_plot_world_borders;hold on % to plot world borders
   climada_naturalearthdata_add % prompt for what to add
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   naturalearthdata_file: filename of the shape (*.shp) file to be added
       to the plot
   linewidth: line width of borders, default is 1
   country_color: the RGB triple for country coloring (e.g. [255 236
       139]/255). Default set in code (yellow). Or just 'b', 'r'... as in
       plot
 OUTPUTS:
   a plot, map_data contains all the elements requested/plottet
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141125, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_naturalearthdata/code/climada_naturalearthdata_add.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_naturalearthdata_plot">
<H2>climada_naturalearthdata_plot</H2></A>
<font color="blue">function map_data=climada_naturalearthdata_plot(linewidth,keep_boundary,world_borders,annotate_places,urban_areas) </font>
 climada
 NAME:
   climada_naturalearthdata_plot
 PURPOSE:
   plot almost any shapes as found in www.naturalearthdata.com
   (www.naturalearthdata.com/downloads)
 CALLING SEQUENCE:
   climada_naturalearthdata_plot(linewidth,keep_boundary,annotate_places,urban_areas)
 EXAMPLE:
   climada_naturalearthdata_plot(1,0,0,1) % borders and urban areas
   climada_plot_world_borders;hold on
   climada_naturalearthdata_plot(1,0,0,0,1) % overlay urban areas
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   linewidth: line width of borders, default is 1
   keep_boundary: if =1, keep axes boundaries, default =0, undefined
   world_borders: if =1, plot world borders, =0 not
   annotate_places: if =1, annotate places (cities), =0 not (default)
   urban_areas: =1, show urban areas, =0 not (default)
 OUTPUTS:
   a plot, map_data contains all the elements requested/plottet
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141125, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_naturalearthdata/code/climada_naturalearthdata_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_shp_explorer">
<H2>climada_shp_explorer</H2></A>
<font color="blue">function climada_shp_explorer(shapes_folder,single_mode,fast_check) </font>
 climada
 MODULE
   _shapes
 NAME:
   climada_shp_explorer
 PURPOSE:
   explore content of shape files and folders full of shape files

   WARNING: might take a LONG time, hence see fast_check

 CALLING SEQUENCE:
   climada_shp_explorer(shapes_folder,single_mode,fast_check)
 EXAMPLE:
   climada_shp_explorer('',0,10) % plot every 10th shape (often a good start)
 INPUTS:
   shapes_folder: a folder with shape files (or a single shape file, if
       extension .shp, if single_mode=1)
       This flder is persistent, i.e. remains the same for subsequent
       calls (but gets updated if again prompted for)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   single_mode: =0, select all files in the folder
       =1 only the actually selected file
   fast_check: &ampgt1: only plot every fast check shape (to get a feel)
       start e.g. with fast_check=100 and then fast_check=10
       =1: plot all shapes (default)
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141223
 David N. Bresch, david.bresch@gmail.com, 20160516, persistent gis_data_dir
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/_naturalearthdata/code/climada_shp_explorer.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_assets_crop">
<H2>climada_assets_crop</H2></A>
<font color="blue">function assets = climada_assets_crop(assets,polygon_focus_area) </font>
 climada_assets_crop
 MODULE:
   advanced
 NAME:
   climada_assets_crop
 PURPOSE:
   Reduce assets to focus only on a given area. Very useful for large assets, 
   where only a speficic area is need. 
   Usually this is the case after climada_nightlight_entity or 
   climada_create_centroids_entity_base. Analogue to climada_hazard_crop.
 CALLING SEQUENCE:
   assets = climada_assets_crop(assets,polygon_focus_area)
 EXAMPLE:
   assets = climada_assets_crop(assets,polygon_focus_area)
 INPUTS: 
   assets: a climada assets structure
   polygon_focus_area: structure with polygon coordinate information in fields
                       .lon and .lat, or .X and .Y that define the focus
                       area, can be multiple polygon_focus_area(2) or more
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:      
   assets: a climada assets structure, with .lon, .lat and .Value,
                        where all coordinates are within the given polygon focus area.
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160314, init
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_assets_crop.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_elevation_add">
<H2>climada_centroids_elevation_add</H2></A>
<font color="blue">function centroids = climada_centroids_elevation_add(centroids,centroids_rectangle,check_plot) </font>
 climada 
 NAME:
   climada_centroids_elevation_add
 PURPOSE:
   add elevation to given centroids or create centroids given a rectangle of
   lon/lat. Uses SRTM data (90 m digitial elevation data, climada module dem)
 CALLING SEQUENCE:
   centroids = climada_centroids_elevation_add(centroids,centroids_rectangle)
 EXAMPLE:
   centroids = climada_centroids_elevation_add;
   centroids = climada_centroids_elevation_add(centroids);
   centroids = climada_centroids_elevation_add('',[-89.15 -89.1 13.695 13.73]);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroids: climada centroids with lon,lat but not elevation_m info
   centroids_rectangle: rectangle that indicates the area where centroids
          should be created (on a 90 m resolution, as given by SRTM) 
          including elevation_m field
   if both inputs are empty, the user can choose a country and define a
   rectangle area in a figure
   check_plot: =1, do show check plot 
 OUTPUTS:
   centroids: a climada centroids structure with fields
       .lon, .lat, .elevation_m for elevation in meters
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151123, init
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_centroids_elevation_add.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_generate">
<H2>climada_centroids_generate</H2></A>
<font color="blue">function centroids = climada_centroids_generate(centroids_rectORcountry_nameORshapes, resolution_km, buffer_check, save_file, check_plot) </font>
 climada generate gridded centroids
 MODULE:
   advanced
 NAME:
   climada_generate_centroids
 PURPOSE:
   Given a rectangle defining the location of interest, generate an evenly
   spaced rectilinear grid of hazard centroids
 CALLING SEQUENCE:
   centroids = climada_generate_centroids(centroids_rectORcountry_nameORshapes, resolution_km, buffer_check, save_file, check_plot)
 EXAMPLE:
   centroids = climada_generate_centroids
   centroids = climada_generate_centroids(centroids_rect, 0.5, 1, 'NO_SAVE', 1)
   centroids = climada_generate_centroids('Netherlands', 1.0, 1, '', 0)
   centroids = climada_generate_centroids(shapes, 1.0, 1, '', 0)
 INPUTS:
   centroids_rectORcountry_nameORshapes [prompted for if not given] 
       can be any one of the following:
       centroids_rect: 4-element row vector defining the longitude and latitude
           limits of the study region [min_lon max_lon min_lat max_lat]
       country_name: the name of a country of interest, or ISO3 code
       shapes: any generic shapes struct, with fields .X and .Y
           defining lat and lon coords of study boundary region respectively.
 OPTIONAL INPUT PARAMETERS:
   resolution_km: specify the centroid resolution (default = 1 km)
   buffer_check: specifies whether a lower resolution grid of centroids 
       is generated outside the boundary defined by shapes,
       or if the high resolution centroids fill the entire
       boudning box (default = 1). Can also be set to -1, for
       centroids that only fill the shape
   save_file: full pathname of save location. If set to 'AUTO',
       centroids are automatically saved in the climada global 
       data directory. If set to 'NO_SAVE', centroids will not 
       be saved. (default = 'AUTO')
 OUTPUTS:
   centroids:      climada centroids struct with fields
                     .Longitude
                     .Latitude
                     .onLand
                     .centroid_ID
                     .countryname - cell array same size as .centroid_ID
                     .admin0_name - country name char array
                     .admin0_ISO3 - ISO 3 country code
                     .comment
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150119
 Gilles Stassen, 20150128, added .comment field
 Gilles Stassen, 20150326, added buffer
 Gilles Stassen, 20150408, increased buffer size
 Gilles Stassen, 20150416, save functionality, general shape input
 Gilles Stassen, 20150423, documentation updated
 Gilles Stassen, 20150703, struct array shape input
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 Lea Mueller, muellele@gmail.com, 20151106, move to advanced
 Lea Mueller, muellele@gmail.com, 20151123, set shapes_check to 0 for centroids_rect
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_generate from climada_generate_centroids
 David N. Bresch, david.bresch@gmail.com, 20160122, ISO3 debugged
 David N. Bresch, david.bresch@gmail.com, 20160126, header updated
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_centroids_generate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_circle_create">
<H2>climada_circle_create</H2></A>
<font color="blue">function circle = climada_circle_create(center_lon,center_lat,radius_deg,check_plot) </font>
 climada create circle polygon
 MODULE:
   climada advanced
 NAME:
   climada_circle_create
 PURPOSE:
   Create a circe polygon (circle.lon, .lat) based on a given center (lon,
   lat) and radius_deg. Hint: 1 is roughly 100km.
 CALLING SEQUENCE:
   circle = climada_circle_create(center_lon,center_lat,radius_deg)
 EXAMPLE:
   circle = climada_circle_create(115,23,0.1)
 INPUTS:
   center_lon: longitude of center point
   center_lat: latitude of center point
   radius_km: radius in km of circle
 OPTIONAL INPUT PARAMETERS:
   check_plot: set to 1 to show a plot
 OUTPUTS:
   circle: a struct with fields .lon, .lat, .center_lon, .center.lat and .radius_deg
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160509, init
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_circle_create.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_crop">
<H2>climada_entity_crop</H2></A>
<font color="blue">function entity = climada_entity_crop(entity, bounding_box, entity_scale_factor) </font>
 climada
 NAME:
   climada_clip_centroids_entity
 PURPOSE:
   Given an entity struct on country level (generated using 
   climada_create_GDP_entity or climada_nightlight_entity) this function 
   crops the entity struct to a bounding box and/or scales its resolution
   (interpolating values).
 CALLING SEQUENCE:
   entity = climada_entity_crop(entity, bounding_box, [entity_scale_factor])
 EXAMPLE:
 INPUTS:
   entity:         The entity created by climada_create_GDP_entity or
                   climada_nightlight_entity
   bounding_box:   An array of size 4 bounding the region of interest,
                   defined by [min_lon max_lon min_lat max_lat]
 OPTIONAL INPUT PARAMETERS:
   entity_scale_factor: Can be a single number (scales by same factor along 
                   lat and lon), or an array of size 2, such that the first
                   index indicates the lon, and the second the lat scale 
                   factors. Default value is set to 2 along both lat and lon.
 OUTPUTS:
   entity:         Entity struct
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20141121
 Gilles Stassen, gillesstassen@hotmail.com, 20141218 change variable names whole_world_borders.lon/lat -&ampgt shapes.X/Y
 Gilles Stassen, gillesstassen@hotmail.com, 20141223 add check_country input arg.
 Gilles Stassen, gillesstassen@hotmail.com, 20150220 centroids routine removed, new function: climada_clip_centroids_entity -&ampgt climada_entity_crop
 Lea Mueller, muellele@gmail.com, 20151125, move to advanced from flood
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_entity_crop.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_exceedence_freq2freq">
<H2>climada_exceedence_freq2freq</H2></A>
<font color="blue">function event_freq = climada_exceedence_freq2freq(exceedence_freq) </font>
 climada calculate event frequency based on exceedence frequency
 MODULE:
   advanced
 NAME:
   climada_exceedence_freq2freq
 PURPOSE:
   Calculate event frequency based on exceedence frequency. The reverse
   from climada_damage_exceedence.
 CALLING SEQUENCE:
   event_freq = climada_exceedence_freq2freq(exceedence_freq)
 EXAMPLE:
   event_freq = climada_exceedence_freq2freq(1./[70 10])
 INPUTS:
   exceedence_freq: exceedence frequencies, i.e. 1./return_period (array)
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   event_freq: occurrence frequency of each event damage (array)
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160308, init
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_exceedence_freq2freq.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard2xls">
<H2>climada_hazard2xls</H2></A>
<font color="blue">function climada_hazard2xls(hazard, hazard_xls_file) </font>
 climada hazard save in xls
 MODULE:
   advanced
 NAME:
   climada_hazard2xls
 PURPOSE:
   Save hazard as xls file
 CALLING SEQUENCE:
   climada_hazard2xls(hazard, hazard_xls_file)
 EXAMPLE:
   climada_hazard2xls(hazard)
 INPUTS:
   hazard: hazard strucure to write out in excel file
   hazard_xls_file: the filename of the Excel file to be written
 OUTPUTS:
   excel file
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160308, init
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_hazard2xls.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_crop">
<H2>climada_hazard_crop</H2></A>
<font color="blue">function hazard = climada_hazard_crop(hazard,polygon_focus_area) </font>
 climada_hazard_crop
 MODULE:
   advanced
 NAME:
   climada_hazard_crop
 PURPOSE:
   Reduce hazard to focus only on a given area. Very useful for large hazards, 
   that contain gridded information and only a speficic area is need. 
   Usually this is the case after climada_asci2hazard.m. 
 CALLING SEQUENCE:
   hazard = climada_hazard_crop(hazard, polygon_focus_area)
 EXAMPLE:
   hazard = climada_hazard_crop(hazard, polygon_focus_area)
 INPUTS: 
   hazard            : a climada hazard structure
   polygon_focus_area: structure with polygon coordinate information in fields
                       .lon and .lat, or .X and .Y that define the focus
                       area, can be multiple polygon_focus_area(2) or more
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:      
   hazard: a climada hazard structure, with .lon, .lat and .intensity,
                   where all coordinates are within the given polygon focus area.
   hazard.focus_area: copy of polygon struct
   hazard.in_focus_area: a vector to indicate in which polygon/focus_area
                   a centroid is located
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150724, init
 Lea Mueller, muellele@gmail.com, 20151106, move to advanced
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_hazard_crop from climada_hazard_focus_area
 Lea Mueller, muellele@gmail.com, 20160224, enable for multiple polygons
 Lea Mueller, muellele@gmail.com, 20160314, loop over segments divided by nans
 Lea Mueller, muellele@gmail.com, 20160318, introduce polygon_tolerance
 Lea Mueller, muellele@gmail.com, 20160427, bugfix if hazard.comment does not exist 
 Lea Mueller, muellele@gmail.com, 20160509, add in_focus_area
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_hazard_crop.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_init">
<H2>climada_hazard_init</H2></A>
<font color="blue">function hazard = climada_hazard_init(hazard) </font>
 init hazard structure
 MODULE:
   climada advanced
 NAME:
   climada_hazard_init
 PURPOSE:
   init a climada hazard struct that contains the necessary fields
   (e.g. .lon, .lat, .intensity etc), or append add the necessary fields
   to an existing hazard and order fields
 CALLING SEQUENCE:
   hazard = climada_hazard_init(hazard)
 EXAMPLE:
   hazard = climada_hazard_init
 INPUTS: none
 OPTIONAL INPUT PARAMETERS:
   hazard: an existing hazard structure where one wants to add the
   necessary fields and order the fields
 OUTPUTS:
   hazard: a climada hazard struct with all the necessary fields
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20160427, init
f ~exist('hazard','var'), hazard = ''; end
f ~isstruct(hazard), clear hazard; hazard.lon = []; end %init as struct
f ~isfield(hazard,'lon'), hazard.lon = []; end
f ~isfield(hazard,'lat'), hazard.lat = []; end
f ~isfield(hazard,'intensity'), hazard.intensity = []; end
f ~isfield(hazard,'frequency'), hazard.frequency = []; end
f ~isfield(hazard,'centroid_ID'), hazard.centroid_ID = ''; end
f ~isfield(hazard,'peril_ID'), hazard.peril_ID = ''; end
f ~isfield(hazard,'units'), hazard.units = ''; end
f ~isfield(hazard,'event_count'), hazard.event_count = []; end
f ~isfield(hazard,'orig_event_count'), hazard.orig_event_count = []; end
f ~isfield(hazard,'event_ID'), hazard.event_ID = []; end
f ~isfield(hazard,'orig_event_flag'), hazard.orig_event_flag = []; end
f ~isfield(hazard,'datenum'), hazard.datenum = []; end
f ~isfield(hazard,'reference_year'), hazard.reference_year = []; end
f ~isfield(hazard,'filename'), hazard.filename = ''; end
f ~isfield(hazard,'comment'), hazard.comment = ''; end
 if ~isfield(hazard,'yyyy'), hazard.yyyy = []; end
 if ~isfield(hazard,'mm'), hazard.mm = []; end
 if ~isfield(hazard,'dd'), hazard.dd = []; end
 order fields in hazard struct
ames = fieldnames(hazard);
iven_order = {'lon','lat','intensity','frequency','centroid_ID','peril_ID','units','event_count','orig_event_count','event_ID','orig_event_flag','datenum','reference_year','filename','comment'};
dditional_name = ~ismember(names,given_order);
ll_names = {given_order{:} names{additional_name}};
azard = orderfields(hazard,all_names);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_hazard_init.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_construct">
<H2>climada_measures_construct</H2></A>
<font color="blue">function measures = climada_measures_construct(measures,n_measures) </font>
 create measures structure
 MODULE:
   climada advanced
 NAME:
   climada_measures_construct
 PURPOSE:
   create a climada measures struct that contains the necessary fields
   (e.g. .name, .hazard_intensity_impact_b etc), or append a new measure
   to an existing measures structure
 CALLING SEQUENCE:
   measures = climada_measures_construct(measures,n_measures)
 EXAMPLE:
   measures = climada_measures_construct
 INPUTS: none
 OPTIONAL INPUT PARAMETERS:
   measures: an existing measures structure where one want to add one or more measures 
   n_measures: number of measures to be created or added
 OUTPUTS:
   measures: a climada measures struct
 MODIFICATION HISTORY:
 Gilles Stassen, init
 Lea Mueller, muellele@gmail.com, 20150902, rename to hazard_intensity_impact_b from hazard_intensity_impact
 Lea Mueller, muellele@gmail.com, 20151117, add filename, add documentation, move to advanced
f ~exist('measures'    ,'var'),    measures = '';  end
f ~exist('n_measures'  ,'var'),    n_measures = 1; end
f isempty(measures)
   measures.name={};
   measures.color={};
   measures.color_RGB = [];
   measures.cost= [];
   measures.hazard_intensity_impact_a=[];
   measures.hazard_intensity_impact_b=[];
   measures.hazard_high_frequency_cutoff=[];
   measures.hazard_event_set={};
   measures.MDD_impact_a= [];
   measures.MDD_impact_b= [];
   measures.PAA_impact_a= [];
   measures.PAA_impact_b= [];
   measures.damagefunctions_map={}; 
   measures.entity_file={};
   measures.risk_transfer_attachement = [];
   measures.risk_transfer_cover = [];
   measures.peril_ID={}; 
   measures.hazard_event_set_operator={}; 
nd
f n_measures == 0
   return;
nd
f n_measures &ampgt=1
   for measure_i = 1:n_measures
       measures.name{end+1}    = ['measure_' num2str(measure_i+length(measures.cost))];
       R = rand; G = rand; B = rand; % random colors for a (pleasant) surprise each time :)
       measures.color{end+1}                           = [num2str(R) ' ' num2str(G) ' ' num2str(B)];
       measures.color_RGB(end+1,:)                     = [R; G; B];
       measures.cost(end+1)                            = 1;
       measures.hazard_intensity_impact_a(end+1)       = 1;
       measures.hazard_intensity_impact_b(end+1)       = 0;
       measures.hazard_high_frequency_cutoff(end+1)    = 0;
       measures.hazard_event_set{end+1}                = 'nil';
       measures.MDD_impact_a(end+1)                    = 1;
       measures.MDD_impact_b(end+1)                    = 0;
       measures.PAA_impact_a(end+1)                    = 1;
       measures.PAA_impact_b(end+1)                    = 0;
       measures.damagefunctions_map{end+1}             = 'nil';
       measures.risk_transfer_attachement(end+1)       = 0;
       measures.risk_transfer_cover(end+1)             = 0;
       measures.entity_file{end+1}                     = 'nil';
       measures.peril_ID{end+1}                        = '';
       measures.hazard_event_set_operator{end+1}       = '';
   end
nd
f all(n_measures &amplt 0)
   rm_measures = sort(abs(unique(n_measures)),'descend');
   flds = fieldnames(measures);
   for measure_i = rm_measures
       total_no_measures = length(measures.name);
       for fld_i = 1:length(flds)
           if length(measures.(flds{fld_i})) == total_no_measures &amp&amp ~ischar(measures.(flds{fld_i}))
               if strcmp(flds{fld_i},'color_RGB')
                   measures.(flds{fld_i})(measure_i,:) = [];
               else
                   measures.(flds{fld_i})(measure_i) = [];
               end
           end
       end
   end
nd                  
easures = climada_measures_encode(measures);
easures.filename = 'constructed directly in matlab';
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_measures_construct.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_add">
<H2>climada_measures_impact_add</H2></A>
<font color="blue">function measures_impact = climada_measures_impact_add(measures_impact,EDS,entity) </font>
 climada_measures_impact_add
 MODULE:
   advanced
 NAME:
   climada_measures_impact_add
 PURPOSE:
   Add control EDS to existing measures_impact so that the before
   'control' run is the asset change run (i.e. urban planning)
 CALLING SEQUENCE:
   measures_impact = climada_measures_impact_add(measures_impact,EDS,entity)
 EXAMPLE:
   measures_impact = climada_measures_impact_add(measures_impact,EDS,entity)
 INPUTS:
   measures_impact: a climada measures_impact structure where we want to
       add a new control run from EDS.
       with fields .EDS,
       .ED, .benefit, .scenario, .peril
       &ampgt promted for if not given
   EDS: a climada EDS structure that contains the control run that will be
       added to measures_impact.
       with field .refence_year,
       .ED, .ED_at_centroid, .peril
       &ampgt promted for if not given
   entity: special case for Barisal to copy asset characteristics
       (.Category, .Caterogy_name, .Category_ID)
 OPTIONAL INPUT PARAMETERS:
   param2: as an example
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151207, init
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/advanced/code/climada_measures_impact_add.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_ED_find_most_vulnerable">
<H2>barisal_ED_find_most_vulnerable</H2></A>
<font color="blue">function entity = barisal_ED_find_most_vulnerable(entity, EDS, criterion_A, criterion_B) </font>
% compare AED with income
 set to small income numbers to zero
ntity.assets.income(entity.assets.income&amplt1) = 0;
 calculate relative AED, relative to income
ED_rel = EDS(1).ED_at_centroid(:) ./entity.assets.income(:) ;
 AED_rel = measures_impact3(1).EDS(1).ED_at_centroid(:) ./entity.assets.income(:) ;
ED_rel(isinf(AED_rel)) = 0;
ED_rel(isnan(AED_rel)) = 0;
 find top-most relative AEDs
 Y = prctile(AED_rel,75) 
AED_sort AED_sort_indx] = sort(AED_rel,'descend');
 number of centroids with residential categories
_residential = 6*7753;
 find most vulnerable buildings
riterion_absolute_A      = int64(criterion_A*n_residential);
riterion_absolute_B      = int64(criterion_B*n_residential);
ndx_most_vuln_building_A = AED_sort_indx(1:criterion_absolute_A);
ndx_most_vuln_building_B = AED_sort_indx(1:criterion_absolute_B);
 index with centroids that point to the most vulnerable residential buildings
ndx_all = 1:numel(entity.assets.lon);
ndx_most_vuln_building_A = ismember(indx_all, indx_most_vuln_building_A);
ndx_most_vuln_building_B = ismember(indx_all, indx_most_vuln_building_B);
 sum(indx_most_vuln_building)
 load resilient_buildings_zone_B
arisal_data_dir= [fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
oad([barisal_data_dir filesep 'entities' filesep 'Measures_package' filesep 'resilient_buildings_zones_B.mat'])
 find lat/lon in zone B
ndx_zone_B = inpoly([entity.assets.lon entity.assets.lat],[resilient_buildings_zone_B.lon' resilient_buildings_zone_B.lat']);
 create vector with 
     - zeros (not most vulnerable)
     - A (most vulnerable buildings in zone A) and 
     - B (most vulnerable buildings in zone B)
ost_vuln_zone_B   = logical(indx_most_vuln_building_B .* indx_zone_B');
ost_vuln_zone_A   = logical(indx_most_vuln_building_A .* ~indx_zone_B');
ost_vuln_building = cell(size(entity.assets.lon));
ost_vuln_building(most_vuln_zone_A) = repmat({'A'},sum(most_vuln_zone_A),1);
ost_vuln_building(most_vuln_zone_B) = repmat({'B'},sum(most_vuln_zone_B),1);
ntity.assets.most_vuln_building     = most_vuln_building;
limada_figuresize(0.4,0.4)
lot(entity.assets.lon(most_vuln_zone_A), entity.assets.lat(most_vuln_zone_A),'or','markersize',2)
old on
lot(entity.assets.lon(most_vuln_zone_B), entity.assets.lat(most_vuln_zone_B),'ob','markersize',2)
itle(sprintf('%d%% most vulnerable res. buildings in Zone A (red) and %d%% in Zone B (blue)',criterion_A*100,criterion_B*100),'fontsize',10)
xis equal
% extend to other buildings
 % unique asset categories
 [categories_uni ia ic] = unique(entity.assets.Category);
 residential categories that we have income information for
ategories_residential = {'Residential_buildings_Pucca_ASSETS'...
                         'Residential_buildings_Semi_Pucca_ASSETS'...
                         'Residential_buildings_Katcha_ASSETS'...
                         'Residential_buildings_Pucca_ASSETS_30_cm_elevation_'...
                         'Residential_buildings_Semi_Pucca_ASSETS_30_cm_elevation_'};
ore_building_categories = {'Commercial' 'industry' 'public'};
 loop over construction types
or c_i = 1:numel(categories_residential)
   
   indx = strcmp(entity.assets.Category, categories_residential{c_i});
   %sum(indx)
   
   % loop over building categories
   for c_ii = 1:numel(more_building_categories)
       category_name = strrep(categories_residential{c_i},'Residential',more_building_categories{c_ii});
       indx_2        = strcmp(entity.assets.Category, category_name);
       %sum(indx_2)
       entity.assets.most_vuln_building(indx_2) = entity.assets.most_vuln_building(indx);
   end
nd
                         
 climada_figuresize(0.4,0.4)
 indxA = strcmp(entity.assets.most_vuln_building,'B') &amp strcmp(entity.assets.Category, 'public_buildings_Pucca_ASSETS')';
 plot(entity.assets.lon(indxA), entity.assets.lat(indxA),'or','markersize',2)
 hold on
 plot(entity.assets.lon(strcmp(entity.assets.most_vuln_building,'B')), entity.assets.lat(strcmp(entity.assets.most_vuln_building,'B')),'ob','markersize',2)
 title(sprintf('%d%% most vulnerable res. buildings in Zone A (red) and B (blue)',criterion*100),'fontsize',10)
 axis equal
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_ED_find_most_vulnerable.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_MI_per_peril">
<H2>barisal_MI_per_peril</H2></A>
<font color="blue">function barisal_MI_per_peril(measures_impact5,measures,peril_IDs) </font>
 climada barisal demo
 NAME:
   barisal_EDS_DFC, special version for BARISAL
 PURPOSE:
   create xls-report for measures impact per peril (and overall effectiveness 
   of measures)

View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_MI_per_peril.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_adaptation_bar_chart">
<H2>barisal_adaptation_bar_chart</H2></A>
 barisal measures adaptation bar chart
 ------------------------------------
 create adaptation bar chart based on measures information from table 5.3
 from Vulnerability Analysis Report
 ------------------------------------
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_adaptation_bar_chart from climada_adaptation_bar_chart_v2
 set directory
arisal_data_dir= [fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
esults_dir     = [barisal_data_dir filesep 'results' filesep '20150916_new_runs'];
eturn
 read input from excel (table 5.3)
xcel_file = [climada_global.project_dir filesep 'results' filesep '20150916_new_runs' filesep 'measures' filesep 'measures_impact.xlsx'];
easures = climada_xlsread(0,excel_file,'measures',0);
 create measures_impact structure and set values according to xls-input
 today (cost capex+opex, benefit 2015)
easures_impact.Value_unit = 'Tk. Crore';
easures_impact.title_str = 'Benefit 2015';
 measures_impact.NPV_total_climate_risk = 100;
easures_impact.NPV_total_climate_risk = 90;
easures_impact.benefit = measures.benefit_2015;
easures_impact.cb_ratio = 1./measures.bc_ratio;
easures_impact.measures.name = measures.name;
easures_impact.measures.cost = measures.cost_capex_opex;
 reference (cost capex benefit 2050)
 measures_impact_reference = measures_impact;
 measures_impact_reference.benefit = measures.benefit_2050;
 measures_impact_reference.measures.cost = measures.cost_capex;
easures_impact(2) = measures_impact;
easures_impact(2).benefit = measures.benefit_2050;
easures_impact(2).measures.cost = measures.cost_capex;
easures_impact(2).title_str = 'Benefit 2050';
ave([results_dir filesep 'measures' filesep 'measures_impact_BDT'],'measures_impact');
 create adaptation bar chart
enefit_str = 'Risk reduction in AED (%)';
cale_benefit = 2.5;
cr_off = 1;
ort_benefit = 1;
ig = climada_adaptation_bar_chart(measures_impact,sort_benefit,scale_benefit,benefit_str,'south',tcr_off);
rint(fig,'-dpdf',[results_dir filesep sprintf('Barisal_measures_proposal.pdf')]);
   
 sort_benefit = 0;
 fig = climada_adaptation_bar_chart(measures_impact,measures_impact_reference,sort_benefit,'',sort_benefit,scale_benefit,benefit_str,'east',tcr_off);
 print(fig,'-dpdf',[results_dir filesep sprintf('Barisal_measures_proposal_sorted.pdf')]);
 sort_benefit = 0;
 fig = climada_adaptation_bar_chart(measures_impact,measures_impact_reference,sort_benefit,'',sort_benefit,scale_benefit,benefit_str,'east',tcr_off);
 print(fig,'-dpdf',[results_dir filesep sprintf('Barisal_measures_proposal_sorted.pdf')]);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_adaptation_bar_chart.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_adaptation_cost_curve">
<H2>barisal_adaptation_cost_curve</H2></A>
<font color="blue">function [insurance_benefit,insurance_cost]=barisal_adaptation_cost_curve(measures_impact, measures_impact_comparison,x_text_control,y_text_control,scaled_AED,nice_numbers,reverse_cb,plot_arrows) </font>
 climada measures impact climate adaptation cost curve
 NAME:
   climada_adaptation_cost_curve
 PURPOSE:
   plot adaptation cost curve
   see also: climada_adaptation_event_view

   NOTE: The mode with output arguments insurance_benefit and
   insurance_cost is only used when called from climada_demo (the flag
   called_from_climada_demo), no relevance for standard use .
 CALLING SEQUENCE:
   climada_adaptation_cost_curve(measures_impact,measures_impact_comparison)
 EXAMPLE:
   climada_adaptation_cost_curve(climada_measures_impact(climada_entity_read)) % from scratch
   climada_adaptation_cost_curve(climada_measures_impact,climada_measures_impact) % one needs to really understand what's going on
   climada_adaptation_cost_curve('','','','',0,0,1) % inverted c/b
 INPUTS:
   measures_impact: either a struct containing the impacts of measures or a measures_impact file (.mat with a struct)
       see climada_measures_impact
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   measures_impact_comparison: same as measures_impact, but for comparison
       (will be shown in overlay). Not prompted for, so please specify in
       call, or enter 'ASK' in climada_adaptation_cost_curve('','ASK')
   x_text_control: controls the horizontal distribution of the text labels
       (divider of the length of the x-axis, default=20)
   y_text_control: controls the vertical distribution of the text labels
       (divider of the length of the y-axis, default=50)
   scaled_AED: scaled annual expected damage (only used by Lea Mueller),
       default=0 (inactive)
   nice_numbers: used in the special mode for the climada_play_gui, where
       this code is called from climada_play_adapt_cost_curve,
       default=0 (inactive)
   reverse_cb: reverse the vertical axis (=1), instead of cost/benefit,
       show benefit per cost, default=0
   plot_arrows: whether we do (=1) or don't (=0, default) plot arrows
   underneath the x-axis to show cost-effective measures and
   non-cost-effective measures extent.
 OUTPUTS:
   insurance_benefit and insurance_cost: only used when called from
       climada_play_adapt_cost_curve, see there (in essence to write
       insurance cost on the GUI)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20091228
 David N. Bresch, david.bresch@gmail.com, 20091230 major revision, appreance similar to ECA graphs
 David N. Bresch, david.bresch@gmail.com, 20130316 EDS-&ampgtEDS
 David N. Bresch, david.bresch@gmail.com, 20130316 compatibility for both direct call as well as via climada_demo_gui
 Gilles Stassen gillesstassen@hotmail.com 20141212 fixed the arrow issue; changed labeling of total climate risk to BDT x m rounded to 2 s.f.
 David N. Bresch, david.bresch@gmail.com, 20141213 plot_arrows=0 by default and climada_demo option cleaned up
 David N. Bresch, david.bresch@gmail.com, 20141231 subaxis removed (not clean, troubles in Octave)
 Lea Mueller, muellele@gmail.com, 20150617, set to bc_ratio (benefits per cost) instead of cb_ratio
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_adaptation_cost_curve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_entity_pre_process">
<H2>barisal_entity_pre_process</H2></A>
<font color="blue">function entity = barisal_entity_pre_process(entity_in) </font>
 barisal_entity_pre_process
 MODULE:
   barisal_demo
 NAME:
   barisal_entity_pre_process
 PURPOSE:
   Pre process entity into climada entity format from input as provided
   by Barisal/Ecorys team, where assetinformation is in a matrix 
   (lon, lat, Ward Nr, and two columns for every category (one with 
   category name ASSETS and second with category name DAMAGE FUNCTION).
   check that column headers have unique names, otherwise data is lost.
 CALLING SEQUENCE:
   entity = barisal_entity_pre_process(entity_in)
 EXAMPLE:
   entity = barisal_entity_pre_process(entity_in)
 INPUTS:
   entity_in: entity as read from Ecorys input in matrix format
       climada_xlsread('no',ecorys_entity_file_xls,'Floods_2014',1);
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity: a climada entity structure
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150909, add documentation
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_entity_pre_process.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_entity_pre_process_income">
<H2>barisal_entity_pre_process_income</H2></A>
<font color="blue">function entity = barisal_entity_pre_process_income(entity) </font>
% create income column in entity.assets structure, so that the income 
 corresponds to the residential buildings
 - 4 different income figures for Juphri, Katcha, Pucca and Semi-Pucca houses
 - Pucca and Semi-Pucca house values are distributed to normal and +30cm houses, 
   whereas we need to assign the income value relative to the portion of normal or +30cm houses
 unique asset categories
ategories_uni = unique(entity.assets.Category);
 residential categories that we have income information for
ategories_residential = {'buildings_Juphri' 'buildings_Katcha' 'buildings_Pucca' 'buildings_Semi_Pucca'};
 income field names
lds_names_income = {'Income_of_juphri_residents' 'Income_of_katcha_residents' 'Income_of_semipucca_residents' 'Income_of_pucca_residents'};
 all categories that contain residential categories
ndx_residential = strfind(categories_uni,'Residential');
ndx_residential = find(~cellfun(@isempty,indx_residential));
 all categories that are part of the +30 cm category
ndx_30 = strfind(categories_uni,'30');
ndx_30 = find(~cellfun(@isempty,indx_30));
 find asset categories where we have income information for
or c_i = 1:numel(categories_residential)
   indx  = strfind(categories_uni,categories_residential{c_i});
   indx  = find(~cellfun(@isempty,indx));
   indx  = indx(ismember(indx, indx_residential));  
   %indx  = indx(~ismember(indx, indx_30));  
   %fprintf('%s, %s\n',categories_residential{c_i},categories_uni{indx});
   income2category_indx{c_i} = indx;
nd
 init income vector
ntity.assets.income = zeros(size(entity.assets.lon));
or c_i = 1:numel(categories_residential)
   
   Value_temp = [];
   % find all values that belong to this income information
   indx = income2category_indx{c_i};
   for ii = 1:numel(indx)
       assets_indx = strcmp(entity.assets.Category,categories_uni{indx(ii)});
       Value_temp(:,ii) = entity.assets.Value(assets_indx);
   end
   % add up all values for this income information (e.g. residential pucca &amp residential pucca +30cm)
   Value_temp_tot = sum(Value_temp,2);
   
   % assign income value relative to building values (portion)
   for ii = 1:numel(indx)
       assets_indx = strcmp(entity.assets.Category,categories_uni{indx(ii)});
       portion = Value_temp(:,ii)./Value_temp_tot;
       portion(isnan(portion)) = 0;
       entity.assets.income(assets_indx) = entity.assets.(flds_names_income{c_i})(1:sum(assets_indx)) .*portion;
   end
   
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_entity_pre_process_income.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_get_EDS">
<H2>barisal_get_EDS</H2></A>
<font color="blue">function [EDS, eds_i] = barisal_get_EDS(EDS,entity_file,hazard_file) </font>
or eds_i =1:length(EDS)
   if strcmp(EDS(eds_i).assets.filename,entity_file) ...
           &amp&amp strcmp(EDS(eds_i).hazard.filename,hazard_file)
       EDS = EDS(eds_i);
       return
   end
nd
printf('ERROR: EDS not found\n')
DS = []; eds_i = [];
eturn
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_get_EDS.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_get_entity">
<H2>barisal_get_entity</H2></A>
<font color="blue">function [entity, e_i] = barisal_get_entity(reference_year,peril,entity_files,eco_scen) </font>
 barisal_get_entity
 MODULE:
   barisal_demo
 NAME:
   barisal_get_entity
 PURPOSE:
   Get/load entity for barisal, based on exisiting mat-files that are
   saved in barisal_demo/data/entities/....mat as specified in entiy_files
 CALLING SEQUENCE:
   [entity, e_i] = barisal_get_entity(reference_year,peril,entity_files,eco_scen)
 EXAMPLE:
   entity = barisal_get_entity(2014,'cyclones',entity_files,'scenario 1')
 INPUTS:
   reference_year: 2014, 2030 or 2050
   peril: 'cyclones' or 'floods'
   entity_files: a cell with all the existing entity-mat files e.g. 
        entity_files{1} = '...barisal_demo\data\entities\Assets_at_risk_100x100_09092015 Baseline scenario 1_cyclones_2014.mat';
        entity_files{2} = '...barisal_demo\data\entities\Assets_at_risk_100x100_09092015 Baseline scenario 1_cyclones_2030.mat';
   eco_scen: 'scenario 1', or 'scenario 2', or 'scenario 3'
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity: a climada entity structure, loaded
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150909, add documentation
 Lea Mueller, muellele@gmail.com, 20150910, load entity 2014 scenario 1 to copy damagefunctions and discount
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_get_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_get_hazard">
<H2>barisal_get_hazard</H2></A>
<font color="blue">function [hazard, h_i] = barisal_get_hazard(reference_year,cc,peril_ID,hazard_files) </font>
f iscell(peril_ID), peril_ID = char(peril_ID); end
f iscell(cc),       cc       = char(cc);       end
or h_i = 1:length(hazard_files)
   if isempty(strfind(hazard_files{h_i},num2str(reference_year)))
       continue
   end
   if ~isempty(cc) &amp&amp isempty(strfind(hazard_files{h_i},cc))
       continue
   end
   if ~isempty(strfind(hazard_files{h_i},peril_ID))
       load(hazard_files{h_i})
       return;
   end
nd
printf('ERROR: specified hazard not found\n')
azard = []; h_i = [];
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_get_hazard.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_measure_zones">
<H2>barisal_measure_zones</H2></A>
ilename = 'M:\BGCC\CHR\RK\RS\A_Sustainable_Development\Projects\ECA\BarisalBangladesh\risk_modelling\4_measures\adaptation_strategy\Measure_zone.shp';
ones = shaperead(filename);
 figure
 climada_shapeplotter(zones,'Zones_code')
igure
ill(zones(1).X(~isnan(zones(1).X)),zones(1).Y(~isnan(zones(1).X)),'-b')
old on
ill(zones(2).X(~isnan(zones(2).X)),zones(2).Y(~isnan(zones(2).X)),'-c')
ill(zones(3).X(~isnan(zones(3).X)),zones(3).Y(~isnan(zones(3).X)),'-g')
ill(zones(4).X(~isnan(zones(4).X)),zones(4).Y(~isnan(zones(4).X)),'-r')
or s = 1:4
   text(mean(zones(s).X(~isnan(zones(s).X))),mean(zones(s).Y(~isnan(zones(s).X))),int2str(s),'fontsize',14)
nd
xis equal
esilient_buildings_zone_B.X = zones(1).X(~isnan(zones(1).X));
esilient_buildings_zone_B.Y = zones(1).Y(~isnan(zones(1).Y));
resilient_buildings_zone_B.lon resilient_buildings_zone_B.lat] = utm2ll_shift(resilient_buildings_zone_B.X, resilient_buildings_zone_B.Y);
igure
ill(resilient_buildings_zone_B.X, resilient_buildings_zone_B.Y ,'-b')
igure
ill(resilient_buildings_zone_B.lon, resilient_buildings_zone_B.lat ,'-b')
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_measure_zones.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_plot_adaptation_cost_curve">
<H2>barisal_plot_adaptation_cost_curve</H2></A>
 plot selection of measures impact for barisal
 Lea Mueller, 20160531, for ECA publication Barisal
easures_filename = [climada_global.data_dir filesep 'results' filesep 'measures_impact_barisal.xlsx'];
measures, measures_impact] = climada_measures_read(measures_filename);
easures_impact.color_keep = 1;
ig = climada_figuresize(0.4,0.95);
limada_adaptation_cost_curve(measures_impact)
rint(fig,'-dpdf',[climada_global.data_dir filesep 'results' filesep 'adaptation_cost_curve_barisal.pdf'])
 climada_adaptation_cost_curve(measures_impact,'','','','','','',1)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_plot_adaptation_cost_curve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_risk_calculations">
<H2>barisal_risk_calculations</H2></A>
% Barisal Risk Calculations
 Lea Mueller, muellele@gmail.com, 20150906, baseline run for scenarios 1, 2, 3
 Lea Mueller, muellele@gmail.com, 20151117, project package run for scenario 1 based on a 
           - new assets (location, values and damage function change)
           - reduced hazard (FL depth monsoon, FL duration mosoon, FL depth cyclone, FL duration cyclone)
           - land raising by 0.3 m(hazard_intensity_impact_b = -0.3)
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
lc
limada_global.waitbar = 0;
limada_global.EDS_at_centroid = 0;
% Directories
arisal_data_dir = climada_global.data_dir;
 barisal_data_dir= [fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
ntities_dir    = [barisal_data_dir filesep 'entities'];
azards_dir     = [barisal_data_dir filesep 'hazards'];
esults_dir     = [barisal_data_dir filesep 'results' filesep '20151116_measure_project_package'];
 results_dir     = [barisal_data_dir filesep 'results' filesep '20150909_new_runs'];
 results_dir     = [barisal_data_dir filesep 'results'];
% load barisal specifics
CC_border_file = [entities_dir filesep 'BCC_border.mat'];
oad(BCC_border_file)
 load BCC ward boundaries (35 polygons)
CC_wards_file = [entities_dir filesep 'BCC_wards_number_added.mat'];
oad(BCC_wards_file)
CC_wards_ll     = BCC_wards;
BCC_wards_ll.x] = BCC_wards_ll.X;      BCC_wards_ll = rmfield(BCC_wards_ll,'X');
BCC_wards_ll.y] = BCC_wards_ll.Y;      BCC_wards_ll = rmfield(BCC_wards_ll,'Y');
BCC_wards_ll.X] = BCC_wards_ll.lon;    BCC_wards_ll = rmfield(BCC_wards_ll,'lon');
BCC_wards_ll.Y] = BCC_wards_ll.lat;    BCC_wards_ll = rmfield(BCC_wards_ll,'lat');
limada_admin_name('Bangladesh','Barisal S.',4,1);
lear BCC_border_file BCC_wards_file
% hazard file name
 This section stores the filenames of all the relevant hazards in a cell
 array for easy retrieval later (using barisal_get_hazard)
 Step 1: call barisal_hazard_read to read Witteveen &amp Bos hazard asci
 files and save resulting hazard structs as .mat files in the climada_GIT
 barisal_demo module data directory.
orce_hazard_asci_read = 0;
f force_hazard_asci_read
   barisal_hazard_read
nd
 Step 2: construct a cell array with all the hazard file names
azard_file_tmp = 'Barisal_BCC_hazard_PIDSPEC_CCSCEN.mat';
 loop over climate change scenarios
CSCEN  = {'2014' 'cc_2030_moderate' 'cc_2030_extreme' 'cc_2050_moderate' 'cc_2050_extreme'};
 loop over hazard perils
ID = {'TC' 'FL_depth_cyclone' 'FL_depth_monsoon' 'FL_duration_cyclone' 'FL_duration_monsoon'};
PEC= {'' }; %'_rain_only'};
ile_i = 0; hazard_files = {};
or cc = CCSCEN
   for pid = PID
       for spec = SPEC
           hazard_file = hazard_file_tmp;
           hazard_file = strrep(hazard_file,'PID',char(pid));
           hazard_file = strrep(hazard_file,'SPEC',char(spec));
           hazard_file = strrep(hazard_file,'CCSCEN',char(cc));
           if exist([hazards_dir filesep hazard_file],'file')
               file_i = file_i+1;
               hazard_files{file_i} = [hazards_dir filesep hazard_file];
               load(hazard_files{file_i})
               % ensure peril ID is correct
               if ~isempty(strfind(hazard_file,'duration'))
                   hazard.peril_ID = 'FL_';
               end
               % consistency in hazard.comment
               if strcmp(hazard.peril_ID,'TC')
                   % hazard.comment = strrep(strrep(hazard_file,'_',' '),'.mat','');
                   hazard.comment = ['TC wind speed ' strrep(char(cc),'_',' ')];
                   fprintf('%s\n',hazard.comment)
               else
                   hazard.comment = strrep([char(pid) ' ' char(cc) ', modelled by W+B'],'_',' ');
                   fprintf('%s\n',hazard.comment)
               end
               
               % datenum for monsoon hazard events
               if ~isempty(strfind(pid,'monsoon'))
                   hazard.yyyy     = [1:length(hazard.yyyy)]+1982;
                   hazard.datenum  = datenum(hazard.yyyy,hazard.mm,hazard.dd);
               end
               
               % consistency in hazard.filename
               hazard.filename = hazard_files{file_i};
               % save corrected hazard
               save(hazard.filename,'hazard')
           end
       end
   end
nd
lear cc CCSCEN pid PID spec SPEC file_i hazard_file_tmp hazard_file force_hazard_asci_read
eturn 
% entity
 This section constructs a cell array with entity file names for easy
 retrieval later with barisal_get_entity
 Entity excel file from Ecorys (unstructured)
 entity_file_xls = [entities_dir filesep 'BCC_entity_260615_se_1.xls'];
 entity_file_xls = [entities_dir filesep 'Asset Entity CLIMADA - Effect Project Package 07072015.xls'];
 run 20151116 measure project package
ntity_file_xls{1} = [entities_dir filesep '20151116_measure_project_package' filesep 'Assets_at_risk_100x100_16112015 Final FS Project package - scenario 1.xlsx'];
 run 20150909 baseline
 entity_file_xls{1} = [entities_dir filesep '20150909_new_runs' filesep 'Assets_at_risk_100x100_09092015 Baseline scenario 1.xlsx'];
 entity_file_xls{2} = [entities_dir filesep '20150909_new_runs' filesep 'Assets_at_risk_100x100_09092015 Baseline scenario 2.xlsx'];
 entity_file_xls{3} = [entities_dir filesep '20150909_new_runs' filesep 'Assets_at_risk_100x100_09092015 Baseline scenario 3.xlsx'];
 % Different entities for the adaptation measures
 % entity_file_xls = [entities_dir filesep 'Measure_spatial_planning_290615_se_1.xls'];
 % entity_file_xls = [entities_dir filesep 'Measure_early_warning_system_290615_se_1.xls'];
 % entity_file_xls = [entities_dir filesep 'Measure_Flood_proof_road_infrastructure_290615_se_1.xls'];
 entity_file_xls = [entities_dir filesep 'Measure_package_070715_se_1.xls'];
 Damage function file from Ecorys
amfun_file_xls = [entities_dir filesep 'BCC_dmg_functions_260615.xls'];
 Entity template file from global data dir
ntity_temp_xls = [climada_global.data_dir filesep 'entities' filesep 'entity_template.xls'];
 Sheet names in Ecorys entity xls file
heets          = {'Floods_2014' 'Floods_2030' 'Floods_2050' 'Cyclones_2014' 'Cyclones_2030' 'Cyclones_2050'};
 sheets          = {'2014' '2030' '2050'}; % for population entity
 Whether to re-read entity/damagefunctions from Ecorys xls (1) or load matfiles (0)
orce_assets_re_read   = 0;
orce_damfun_re_read   = 0;
dd_measures = 1;
ounter = 0;
 counter = 6;
or scenario_eco_i = 1:numel(entity_file_xls)
   for s_i = 1:length(sheets)
       clear entity
       % mat file name - separate mat file for each sheet in Ecorys entity xls
       entity_file_mat     = strrep(entity_file_xls{scenario_eco_i},'.xlsx',['_' lower(sheets{s_i}) '.mat']);
       counter = counter+1;
       
       if exist(entity_file_mat,'file') &amp&amp ~force_assets_re_read
           % Load mat file
           [~,fN] = fileparts(entity_file_mat);
           fprintf('entity %s already exists, skipping\n',fN)
           entity_files{counter} = entity_file_mat;
   %         load(entity_file_mat)
   %         % append filename for consistency
   %         entity.assets.filename = entity_file_mat;
   % 
   %         % get reference year, comment from sheet name
   %         [~,yr_]                         = strtok(sheets{s_i},'_');
   %         entity.assets.reference_year    = str2num(yr_(2:end));
   % 
   %         % add income information to entity.assets for residential categories only
   %         entity = barisal_entity_pre_process_income(entity);
   %         
   %         % find top-most vulnerable buildings -- load specific EDS before
   %         switch entity.assets.reference_year
   %             case 2030,  criterion_A = 0.25;     criterion_B = 0.10;
   %             case 2050,  criterion_A = 0.50;     criterion_B = 0.15;
   %             otherwise, continue;
   %         end
   %         load([entities_dir filesep 'ED_at_centroid_baseline.mat'])
   %         entity    = barisal_ED_find_most_vulnerable(entity, EDS_FL, criterion_A,criterion_B);
   % 
   %         % save corrected entity
   %         save(entity.assets.filename,'entity')
   % ==================
   % This section for looking at slum houses only. Be careful when
   % uncommenting!
   % ==================
   %         entity.assets.Value(~(strcmp(entity.assets.Category,'Residential_buildings_Juphri_ASSETS')...
   %             | strcmp(entity.assets.Category,'Residential_buildings_Katcha_ASSETS')))=0;
   %
   %         figure; hold on
   %         climada_entity_plot(entity,5,'BDT',0);
   %         box on
   %         climada_shapeplotter(BCC_wards_ll,'','linewidth',1,'color',[81 81 81]/255);
   %         axis([min(entity.assets.lon)-0.01 max(entity.assets.lon)+0.01 min(entity.assets.lat)-0.01 max(entity.assets.lat)+0.01])
   %
   %         entity_file_mat = strrep(entity_file_mat,'.mat','_slums.mat');
   %         [~,fN] = fileparts(entity_file_mat);
   %         print(gcf,'-dpng',[results_dir filesep fN '.png'])
   %         clear fN
   %         close
   %====================
       else
           force_damfun_re_read = 1; % since file does not yet exist
           % read in entity from Ecorys xls
           % assets
           entity.assets = climada_xlsread('no',entity_file_xls{scenario_eco_i},sheets{s_i},1);
           % restructure into climada entity format (not necessary for
           % population entity)
           entity        = barisal_entity_pre_process(entity);
           % remove NaN entries in assets uniformly from all fields
           nan_ndx = isnan(entity.assets.Ward_Nr);
           flds = fieldnames(entity.assets);
           for fld_i = 1:length(flds)
               if (iscell(entity.assets.(flds{fld_i})) || isnumeric(entity.assets.(flds{fld_i}))) ...
                       &amp&amp length(entity.assets.(flds{fld_i}))==length(nan_ndx)
                   entity.assets.(flds{fld_i})(nan_ndx) = [];
               end
           end
           entity.assets.Value(isnan(entity.assets.Value)) = 0;
           % set negative asset values to 0
           fprintf('setting %d negative asset values to zero\n',sum(entity.assets.Value&amplt0))
           entity.assets.Value(entity.assets.Value&amplt0) = 0;
           % set deductible &amp cover
           fprintf('setting deductible and cover\n')
           entity.assets.Deductible    = entity.assets.Value .* 0;
           entity.assets.Cover         = entity.assets.Value;
           % add income information to entity.assets for residential categories only
           %entity = barisal_entity_pre_process_income(entity);
           % find top-most vulnerable buildings -- load specific EDS before
           %criterion = 0.050;
           %entity    = barisal_ED_find_most_vulnerable(entity, EDS, criterion);
           % coord transformation from UTM to lat lon
           [entity.assets.lon, entity.assets.lat] = utm2ll_shift(entity.assets.lon, entity.assets.lat);
           % get reference year, comment from sheet name
           [region,yr_]                    = strtok(sheets{s_i},'_');
           entity.assets.reference_year    = str2num(yr_(2:end));
           entity.assets.comment           = strrep(sheets{s_i},'_',' ');
           entity.assets.filename          = entity_file_mat;
           entity.assets.region            = sprintf('Barisal, Scenario %d',scenario_eco_i);
           fprintf('saving entity as %s\n',entity.assets.filename)
           save(entity.assets.filename,'entity')
           entity_files{counter} = entity.assets.filename; % for filename consistency
       end
       if force_damfun_re_read
           fprintf('adding damage functions from %s\n',damfun_file_xls)
           load(entity_file_mat)
           
           %add region
           [region,yr_]                    = strtok(sheets{s_i},'_');
           entity.assets.region            = sprintf('Barisal assets exposed to %s',lower(region));
           
           % damagefunctions from Ecorys xls
           entity.damagefunctions          = climada_xlsread(0,damfun_file_xls,'formatted',1);
           % find TC damfuns
           tc_ndx                          = strcmp(entity.damagefunctions.peril_ID,'TC');
           % widnspeed conversion from km/h to m/s
           entity.damagefunctions.Intensity(tc_ndx) = entity.damagefunctions.Intensity(tc_ndx)./3.6;
           entity.damagefunctions.units    (tc_ndx) = {'m/s'};
           % need MDD and PAA for EDS_calc, not given in Ecorys entity, so
           % take sqrt of MDR instead.
           entity.damagefunctions.MDD = sqrt(entity.damagefunctions.MDR);
           entity.damagefunctions.PAA = sqrt(entity.damagefunctions.MDR);
           % discount
           entity.discount          = climada_xlsread(0,entity_temp_xls,'discount',1);
           fprintf('saving entity as %s\n',entity.assets.filename)
           entity_files{counter} = entity.assets.filename;
           save(entity.assets.filename,'entity')
       end
       
       if add_measures
           fprintf('adding measures\n')
           load(entity_file_mat)
           load([entities_dir filesep '20151116_measure_project_package' filesep 'measures_project_package.mat'])
           entity.measures = measures;
           
           % add assets specifics
           entity.assets.filename = entity_file_mat;
           entity.assets.region   = sprintf('Barisal, Scenario %d',scenario_eco_i);
           entity.assets = climada_assets_category_ID(entity.assets); % add .Category_name and .Category_ID
           if isfield(entity.assets,'X')
               entity.assets = rmfield(entity.assets,'X');
               entity.assets = rmfield(entity.assets,'Y');
           end
           save(entity.assets.filename,'entity')
       end
       
   end %sheets
nd % scenario_eco_i
lear entity_file_xls sheets ul_loc s_i tc_ndx damfun_file_xls entity_temp_xls fN yr_
lear fld_i flds nan_ndx entity_file_mat force_damfun_re_read force_assets_re_read asci_file
% create measures to represent project package (20151117)
 create four measures
  1. reduced FL depth due to a package of measures
  2. regional scope of land raising on top of reduced FL depth, read regional scope from excel file, given from Ecorys  
  3. reduced FL duration due to a package of measures
  4. TC with no measures so that it runs through the calculation nontheless
ntity_file_xls{1} = [entities_dir filesep '20151116_measure_project_package' filesep 'Assets_at_risk_100x100_16112015 Final FS Project package - scenario 1.xlsx'];
oad([strrep(entity_file_xls{1},'.xlsx','') '_floods_2014'])
lear measures
_measures = 4;
easures = climada_measures_construct('',n_measures);
 reduced FL depth hazard due to a package of measures
sci_path = [barisal_data_dir filesep 'entities' filesep '20151116_measure_project_package' filesep 'reduced_FL_hazard'];
easure_i = 1; 
easures.name{measure_i} = 'FL depth project package';
easures.peril_ID(measure_i) = {'FL'};
easures.hazard_event_set{measure_i} = [asci_path filesep 'CaseDifferenceDepth_m.asc'];
easures.hazard_event_set_operator{measure_i} = 'plus';
 land raising at selected locations
easure_i = 2; 
easures.name{measure_i} = 'final package';%'land raising';
easures.hazard_event_set{measure_i} = [asci_path filesep 'CaseDifferenceDepth_m.asc'];
easures.hazard_event_set_operator{measure_i} = 'plus';
easures.hazard_intensity_impact_b(measure_i) = -0.3; % land raising by 0.3m
easures.peril_ID(measure_i) = {'FL'};
easure_location = climada_xlsread('no',...
   [entities_dir filesep '20151116_measure_project_package' filesep 'Locations for resilient buildings measure.xlsx'],'Assets',1);
_categories = length(entity.assets.lon)/length(measure_location.flood_resilient_buildings);
 replicate matrix for all categories
egional_scope = repmat(measure_location.flood_resilient_buildings,n_categories,1);
printf('Measure final package (asset change, hazard change, land raising at selected locations)\n')
printf('\t - %d locations (1 category), %d locations with land raising \n',length(measure_location.flood_resilient_buildings),sum(measure_location.flood_resilient_buildings))
printf('\t - %d all locations (%d categories) \n',length(entity.assets.lon),n_categories)
 initialize logical index to define the regional scope of measures
easures.regional_scope = ones(length(entity.assets.Value),n_measures);
 create logical 
easures.regional_scope(:,measure_i) = logical(regional_scope);
 reduced FL duration hazard due to a package of measures
easure_i = 3; 
easures.name{measure_i} = 'final package'; %'FL duration project package';
easures.peril_ID(measure_i) = {'FL_'};
easures.hazard_event_set{measure_i} = [asci_path filesep 'CaseDifferenceDuration_fraction.asc'];
easures.hazard_event_set_operator{measure_i} = 'times';
 TC with no measures so that it runs through the calculation nontheless
easure_i = 4; 
easures.name{measure_i} = 'final package'; %'TC control';
easures.peril_ID(measure_i) = {'TC'};
ave([entities_dir filesep '20151116_measure_project_package' filesep 'measures_project_package.mat'],'measures')
 measures = climada_measures_check(measures,entity.assets);
 entity.measures = measures;
% measures impact calc for today, 2030 and 2050 including climate change
 calculate measures_impact for each peril in different scenarios specified below. 
================
eril_IDs   = {'FL_depth_monsoon' 'FL_duration_monsoon' 'FL_depth_cyclone' 'FL_duration_cyclone' 'TC'};
 peril_IDs   = {'TC'};
co_scen    = 1; %[1 2 3];
c_scen     = 'moderate'; %{'moderate' 'extreme'}; %
ear_i      = 2014;
ear_f      = [2030 2050];
ilent_mode = 0;
anity_check = 1;
init
lear measures_impact1 measures_impact3 measures_impact5 measures_impact2 measures_impact4
or scenario_eco_i = 1:numel(eco_scen)
   for p_i = 1:numel(peril_IDs); %peril_IDs(1) %peril_ID = peril_IDs %
       peril_ID = peril_IDs{p_i};
       if strcmp(peril_ID,'TC')
           peril = 'cyclone';
       else
           peril = 'flood';
       end
       ed_i = p_i; % counter for EDS entries
       year_f = 2030;
       climada_global.future_reference_year = year_f;
       % EDS1 for scenario hazard and entity in present reference year
       [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files); 
       [entity,e_i] = barisal_get_entity(year_i,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = 'no change';
       %entity.assets.region = sprintf('BCC %s', peril_ID);
       %fprintf('\n***** Scenario %d, EDS1 for %s | %s *****\n', scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact1(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact1(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_i) '.mat'];
       %for i = 1:length(measures_impact1(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact1(ed_i).EDS(i).assets.X,measures_impact1(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact1(ed_i).EDS(i).assets.lat,measures_impact1(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact1(ed_i).filename,'measures_impact1')   
       
       % ----2030-----
       % EDS2 for no change hazard and entity in future reference year
       [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files); 
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = 'no change';
       %fprintf('\n***** Scenario %d, EDS1 for %s | %s *****\n', scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact2(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact2(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_f) '.mat'];
       %for i = 1:length(measures_impact2(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact1(ed_i).EDS(i).assets.X,measures_impact1(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact2(ed_i).EDS(i).assets.lat,measures_impact1(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact2(ed_i).filename,'measures_impact2')   
       
       % EDS3 for climate change scenario: future entity 2030, future hazard 2030
       if scenario_eco_i == 2
           cc_scen = 'extreme';
       else 
           cc_scen = 'moderate';
       end
       [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = sprintf('%s change',cc_scen);
       %entity.assets.region = sprintf('BCC %s', peril_ID);
       %fprintf('\n***** Scenario %d, EDS3 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name3 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact3(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact3(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_f) '_cc_' cc_scen '_' num2str(year_f) '.mat'];
       %for i = 1:length(measures_impact3(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact3(ed_i).EDS(i).assets.X,measures_impact3(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact3(ed_i).EDS(i).assets.lat,measures_impact3(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact3(ed_i).filename,'measures_impact3')
       
       % ----2050-----
       year_f = 2050;
       climada_global.future_reference_year = year_f;
       
       % EDS4 for future entity 2050, no climate change scenario
       [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = 'no change';
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact4(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact4(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_f) '.mat'];
       %for i = 1:length(measures_impact4(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact4(ed_i).EDS(i).assets.X,measures_impact4(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact4(ed_i).EDS(i).assets.lat,measures_impact4(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact4(ed_i).filename,'measures_impact4')
       
       % EDS5 for climate change scenario: future entity 2050, future hazard 2050
       if scenario_eco_i == 2
           cc_scen = 'extreme';
       else 
           cc_scen = 'moderate';
       end
       [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       hazard.scenario = sprintf('%s change',cc_scen);
       %entity.assets.region = sprintf('BCC %s', peril_ID);
       %fprintf('\n***** Scenario %d, EDS5 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name5 = ['Increase; from ' cc_scen '; climate change; ' num2str(year_f)];
       %scen_name5 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
       scenario = climada_scenario_name(entity,hazard); fprintf('\n***** %s: %s *****\n', scenario.name_simple, peril_ID)
       measures_impact5(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
       measures_impact5(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_f) '_cc_' cc_scen '_' num2str(year_f) '.mat'];
       %for i = 1:length(measures_impact5(ed_i).EDS)
       %    % convert back to UTM
       %    [measures_impact5(ed_i).EDS(i).assets.X,measures_impact5(ed_i).EDS(i).assets.Y] = ...
       %        ll2utm_shift(measures_impact5(ed_i).EDS(i).assets.lat,measures_impact5(ed_i).EDS(i).assets.lon);
       %end
       save(measures_impact5(ed_i).filename,'measures_impact5')
   end
nd %scenario_eco_i
% add baseline results to measures_impact
oad(['\\CHRB1065.CORP.GWPNET.COM\homes\X\S3BXXW\Documents\lea\climada_git\climada_data_barisal\results\20150916_baseline' filesep 'EDS_scenario_1'])
 load([results_dir filesep 'EDS_scenario_1'])
easures_impact1_baseline = climada_measures_impact_add(measures_impact1,EDS1,entity);
easures_impact2_baseline = climada_measures_impact_add(measures_impact2,EDS2,entity);
easures_impact3_baseline = climada_measures_impact_add(measures_impact3,EDS3,entity);
easures_impact4_baseline = climada_measures_impact_add(measures_impact4,EDS4,entity);
easures_impact5_baseline = climada_measures_impact_add(measures_impact5,EDS5,entity);
d_i = 1;
ave(measures_impact1_baseline(ed_i).filename,'measures_impact1_baseline')
ave(measures_impact2_baseline(ed_i).filename,'measures_impact2_baseline')
ave(measures_impact3_baseline(ed_i).filename,'measures_impact3_baseline')
ave(measures_impact4_baseline(ed_i).filename,'measures_impact4_baseline')
ave(measures_impact5_baseline(ed_i).filename,'measures_impact5_baseline')
easures_impact = measures_impact1_baseline;
easures_impact(6:10) = measures_impact2_baseline;
easures_impact(11:15) = measures_impact3_baseline;
 measures_impact(16:20) = measures_impact4_baseline;
 measures_impact(21:25) = measures_impact5_baseline;
 measures_impact(1).filename = [results_dir filesep 'measures_impact_2014_2030_2050_scenario_1']
easures_impact(1).filename = [results_dir filesep 'measures_impact_2014_2030_scenario_1']
ave(measures_impact(1).filename,'measures_impact')
 % maybe add category tables to baseline scenario
 n_scenarios = numel(measures_impact);
 for scenario_i = 1:n_scenarios  
     % change Value_unit to BDT, add asset Categories, remove X, Y
     for m_i = 1:numel(measures_impact(scenario_i).EDS)
         measures_impact(scenario_i).EDS(m_i).assets.Category = entity.assets.Category;
         measures_impact(scenario_i).EDS(m_i).assets.Category_name = entity.assets.Category_name;
         measures_impact(scenario_i).EDS(m_i).assets.Category_ID = entity.assets.Category_ID;
         if isfield(measures_impact(scenario_i).EDS(m_i).assets,'X')
             measures_impact(scenario_i).EDS(m_i).assets = rmfield(measures_impact(scenario_i).EDS(m_i).assets,'X');
             measures_impact(scenario_i).EDS(m_i).assets = rmfield(measures_impact(scenario_i).EDS(m_i).assets,'Y');
         end
     end
 end %scenario_i
 measures_impact(1).filename = [results_dir filesep 'measures_impact_2014_2030_scenario_1']
 save(measures_impact(1).filename,'measures_impact')
 % save(measures_impact(1).filename,'measures_impact','-v7.3')
 
 filename = entity(1).assets.filename;
 category_selected = 'Commercial_buildings_Pucca_ASSETS';
 entity.assets = climada_asset_categories(entity.assets);
 save([results_dir filesep 'entity_test.mat'],'entity')
% combine measures_impact for all perils per scenario (timehorizon)
eril_list = {'FL monsoon' 'FL monsoon duration' 'FL cyclone' 'FL cyclone duration' 'TC'};
easures_impact_combined = climada_measures_impact_combine_scenario(measures_impact,'','',peril_list);
% create some benefit plots
easure_no = 1; fieldname_to_plot = {'ED_at_centroid' 'benefit'}; plot_method= 'plotclr'; 
imehorizon = 1;% time horizon
 category_criterium = '';
easures_impact_to_plot = measures_impact_combined(timehorizon);
~, fig] = climada_map_plot(measures_impact_to_plot,fieldname_to_plot,plot_method,measure_no,category_criterium);
easure_no = 4;
ieldname_to_plot = {'ED_at_centroid'};
truct_no = 1;% peril type
ategory_criterium = '';
~, fig] = climada_map_plot(measures_impact1_baseline,fieldname_to_plot,plot_method,measure_no,struct_no,category_criterium);
ategory_criterium = {'industry_buildings_Semi_Pucca_ASSETS_30_cm_elevation_' 'Residential_buildings_Pucca_ASSETS'};
ategory_criterium = 'Residential_buildings_Pucca_ASSETS';
ategory_criterium = categories(3:4);
ntity.assets.Category = unique(entity.assets.Category);
easure_no = 1;
ieldname_to_plot = 'Value'; plot_method= 'plotclr'; 
truct_no = 1;% peril type
~, fig] = climada_map_plot(entity,fieldname_to_plot,plot_method,measure_no,struct_no,category_criterium);
vent_no = 1721;
ieldname_to_plot = 'intensity'; plot_method= 'plotclr'; 
truct_no = 1;% peril type
~, fig] = climada_map_plot(hazard,fieldname_to_plot,plot_method,event_no,struct_no);
vent_no = 1;
ieldname_to_plot = 'intensity'; plot_method= 'plotclr'; 
truct_no = 1;% peril type
~, fig] = climada_map_plot('Barisal_BCC_hazard_FL_depth_cyclone_2014',fieldname_to_plot,plot_method,event_no,struct_no);
vent_no = 1721;
ieldname_to_plot = 'intensity'; plot_method= 'contourf'; 
truct_no = 1;% peril type
~, fig] = climada_map_plot('Barisal_BCC_hazard_TC_2014',fieldname_to_plot,plot_method,event_no,struct_no);
% write ED output for measures_impact
lear EDS_project_package_1 EDS_project_package_3 EDS_project_package_5 EDS_project_package
 collect EDS for all perils (FL depth, FL duration, FL depth cyclone, FL duration cyclone, TC)
DS_project_package_1 = [measures_impact1(1).EDS measures_impact1(2).EDS measures_impact1(3).EDS...
                       measures_impact1(4).EDS measures_impact1(5).EDS(1)];
 EDS_project_package_1 = [measures_impact1(3).EDS measures_impact1(4).EDS];    
DS_project_package_3 = [measures_impact3(1).EDS measures_impact3(2).EDS measures_impact3(3).EDS...
                       measures_impact3(4).EDS measures_impact3(5).EDS(1)];
DS_project_package_5 = [measures_impact5(1).EDS measures_impact5(2).EDS measures_impact5(3).EDS...
                       measures_impact5(4).EDS measures_impact5(5).EDS(1)];
 convert back to UTM
or ed_i = 1:length(EDS_project_package_1)
   [EDS_project_package_1(ed_i).assets.X,EDS_project_package_1(ed_i).assets.Y] = ...
                  ll2utm_shift(EDS_project_package_1(ed_i).assets.lat, EDS_project_package_1(ed_i).assets.lon);
   [EDS_project_package_3(ed_i).assets.X,EDS_project_package_3(ed_i).assets.Y] = ...
                  ll2utm_shift(EDS_project_package_3(ed_i).assets.lat, EDS_project_package_3(ed_i).assets.lon);
   [EDS_project_package_5(ed_i).assets.X,EDS_project_package_5(ed_i).assets.Y] = ...
                  ll2utm_shift(EDS_project_package_5(ed_i).assets.lat, EDS_project_package_5(ed_i).assets.lon);           
   EDS_project_package_1(ed_i).peril_ID = '';
   EDS_project_package_3(ed_i).peril_ID = '';
   EDS_project_package_5(ed_i).peril_ID = '';
nd                    
               
 loop over three time horizons
imehorizons = [2014 2030 2050];                    
or t_i = 1%:3
   % fill variable with a specific time horizon
   switch t_i
       case 1
           EDS_project_package = EDS_project_package_1;
       case 2 
           EDS_project_package = EDS_project_package_3;
       case 3
           EDS_project_package = EDS_project_package_5;
   end
   
   % write ED per category report
   EDS_report_xls = [results_dir filesep sprintf('BCC_ED_report_scenario_%d_project_package_%s.xls',eco_scen(scenario_eco_i),datestr(now,'yyyymmdd'))];
   %if exist(EDS_report_xls,'file'), delete(EDS_report_xls); end
   benefit_flag = 0;
   assets_flag = 1;
   sheetname = sprintf('ED_per_category_%d',timehorizons(t_i));
   output_report = climada_EDS_ED_per_category_report(entity, EDS_project_package, EDS_report_xls,sheetname,benefit_flag,0,assets_flag);
   
   % write ED at centroid to excel
   EDS_report_xls = [results_dir filesep sprintf('BCC_ED_report_scenario_%d_project_package_at_centroid_%s.xls',eco_scen(scenario_eco_i),datestr(now,'yyyymmdd'))];
   sheetname = sprintf('ED_at_centroid_%d',timehorizons(t_i));
   climada_EDS_ED_at_centroid_report_xls(EDS_project_package,EDS_report_xls,sheetname);
nd
%
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Pucca_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), AED_rel(assets_indx),'','',1,0.01,5)
itle('AED relative, Residential_buildings_Pucca_ASSETS')
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Pucca_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), AED_rel(assets_indx),'','',1)
itle('AED relative, Residential_buildings_Pucca_ASSETS')
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Katcha_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), AED_rel(assets_indx),'','',1,0.01,5)
itle('AED relative, Residential_buildings_Katcha_ASSETS')
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Pucca_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), entity.assets.income(assets_indx),'','',1)
itle('Income, Residential_buildings_Pucca_ASSETS')
igure
ssets_indx = strcmp(entity.assets.Category,'Residential_buildings_Pucca_ASSETS');
lotclr(entity.assets.lon(assets_indx), entity.assets.lat(assets_indx), measures_impact3(1).EDS(1).ED_at_centroid(assets_indx),'','',1)
itle('ED, Residential_buildings_Pucca_ASSETS')
eturn
% measures construction
 structure measures, assign measures.hazard_event_set by searching through
 barisal entities folder and finding measure folders starting with the
 substring &quotMeasures&quot
_dir_ = dir(entities_dir);
init
lear measures; measures = climada_measures_construct([],0);
 hazard modifying measures
or e_dir_i = 1:length(e_dir_)
   if e_dir_(e_dir_i).isdir &amp&amp ...
           ~isempty(strfind(upper(e_dir_(e_dir_i).name),'MEASURES'))
       
       e_subdir_ = dir([entities_dir filesep e_dir_(e_dir_i).name]);
       
       for m_i = 1:length(e_subdir_)
           if e_subdir_(m_i).name(1) == '.', continue; end
           asci_file = [entities_dir filesep e_dir_(e_dir_i).name filesep e_subdir_(m_i).name];
           % construct name from folder and file
           name    = strrep([e_dir_(e_dir_i).name],'Measures_','');
           name(1) = upper(name(1)); name = strrep(name,'_',' ');
           
           measures = climada_measures_construct(measures,1);
           
           measures.name{end}              = name;
           measures.hazard_event_set{end}  =  asci_file;
           % operator required for call to climada_distributed_measures in
           % climada_measures_impact_advanced. Make sure it is correct by
           % checking peril ID =&ampgt multiplication for flood duration and
           % addition for flood depth
           if ~isempty(strfind(e_subdir_(m_i).name,'Duration'))
               measures.peril_ID{end} = 'FL_';
               measures.hazard_event_set_operator{end} = 'times';
           else
               measures.peril_ID{end} = 'FL';
               measures.hazard_event_set_operator{end} = 'plus';
           end
           % fprintf('%s \t%s\n',name,measures.peril_ID{end})
       end
   end
nd
 % assign measures struct to entities and save each one again
easures                              = climada_measures_construct(measures,4);
easures.name{end-3}                  = 'Flood resilient crops';
easures.damagefunctions_map{end-3}   = '1320to1321';
easures.peril_ID{end-3}              = 'FL_';
 save measures struct (before adding entity file)
easures.filename = [entities_dir filesep 'BCC_measures_' datestr(now,'ddmmyy') '.mat'];
printf('saving measures as %s\n',measures.filename)
ave(measures.filename,'measures')
easures_ori = measures; % for ponds retain routine
or e_i = 1:length(entity_files)
   
   measures = measures_ori;
   
   load(entity_files{e_i})
   
   % remove old measures, just in case
   if isfield(entity,'measures'),entity = rmfield(entity,'measures'); end
   
   measures.name{end-2}        = 'Spatial planning';
   measures.entity_file{end-2} = [fileparts(entity_files{e_i}) filesep...
       'Measure_Spatial_planning_290615_se_1_' lower(strrep(entity.assets.comment,' ','_')) '.mat'];
   if ~exist(measures.entity_file{end-2},'file')
       cprintf([ 1 0.5 0],'WARNING: entity file for measure %s does not exist\n',measures.name{end-2})
   end
   
   measures.name{end-1}        = 'Early warning system';
   measures.entity_file{end-1} = [fileparts(entity_files{e_i}) filesep...
       'Measure_Early_warning_system_290615_se_1_' lower(strrep(entity.assets.comment,' ','_')) '.mat'];
   measures.damagefunctions_map{end-1}   = '1210to1211;1220to1221';
   if ~exist(measures.entity_file{end-1},'file')
       cprintf([ 1 0.5 0],'WARNING: entity file for measure %s does not exist\n',measures.name{end-1})
   end
   measures.name{end}          = 'Flood proof road infrastructure';
   measures.entity_file{end}   = [fileparts(entity_files{e_i}) filesep...
       'Measure_Flood_proof_road_infrastructure_290615_se_1_' lower(strrep(entity.assets.comment,' ','_')) '.mat'];

   if ~exist(measures.entity_file{end},'file')
       cprintf([ 1 0.5 0],'WARNING: entity file for measure %s does not exist\n',measures.name{end})
   end   
   % drainage for correct refence year
   rm_ndx = [];
   for m_i = 1:length(measures.name)
       if ~isempty(strfind(measures.name{m_i},'Ponds retain'))
           if isempty(strfind(measures.name{m_i},num2str(entity.assets.reference_year)))
               rm_ndx = [rm_ndx m_i];
           end
           measures.name{m_i} = 'Ponds retain';
       end
   end
   
   entity.measures = climada_measures_construct(measures,-rm_ndx);
     entity.measures = measures;
   fprintf('measures assigned to entity %s:\n',entity.assets.comment)
   for measure_i = 1:length(entity.measures.name)
       cprintf(entity.measures.color_RGB(measure_i,:),'\t%s\n',entity.measures.name{measure_i});
   end
   
   fprintf('saving entity with measures to %s\n',entity.assets.filename)
   
   save(entity.assets.filename,'entity')
nd
 display measures in their respective colours
 for measure_i = 1:length(measures.name),cprintf(measures.color_RGB(measure_i,:),'%s\n',measures.name{measure_i}); end
lear e_i e_dir_i e_dir_ e_subdir_ e_subdir_ m_i m_i measure_i rm_ndx name
% measures package construction
init
lear measures; measures = climada_measures_construct([],3);
 hazard modifying measures
sci_path = [barisal_data_dir filesep 'entities' filesep 'Measures_package'];
 flood depth
easures.name{1}                =   'Measure package';
easures.hazard_event_set{1}    =   [asci_path filesep 'CaseDifferenceDepth_m.asc'];
easures.peril_ID{1}            =   'FL';
easures.hazard_event_set_operator{1} = 'plus';
easures.damagefunctions_map{1}   = '1210to1211;1220to1221'; % vehicles
 flood duration
easures.name{2}                =   'Measure package';
easures.hazard_event_set{2}    =   [asci_path filesep 'CaseDifferenceDuration_fraction.asc'];
easures.peril_ID{2}            =   'FL_';
easures.hazard_event_set_operator{2} = 'times';
easures.damagefunctions_map{2} = '1320to1321'; % Flood resilient crops (only for duration)
 cyclone wind
easures.name{3}                =   'Measure package';
easures.peril_ID{3}            =   'TC';
 save measures struct (before adding entity file)
easures.filename = [entities_dir filesep 'BCC_measure_package' datestr(now,'ddmmyy') '.mat'];
printf('saving measures as %s\n',measures.filename)
ave(measures.filename,'measures')
or y_i = [2014 2030 2050]
   % set correct measure entity file
   measures.entity_file{1} = [entities_dir filesep...
       'Measure_package_070715_se_1_floods_' num2str(y_i) '.mat'];
   measures.entity_file{2} = [entities_dir filesep...
       'Measure_package_070715_se_1_floods_' num2str(y_i) '.mat'];
   measures.entity_file{3} = [entities_dir filesep...
       'Measure_package_070715_se_1_cyclones_' num2str(y_i) '.mat'];
   
   % assign measures to baseline entity struct
   % for both flood depth and duration
   [entity, e_i] = barisal_get_entity(y_i,'floods',entity_files);
   % remove old measures, just in case
   if isfield(entity,'measures'),entity = rmfield(entity,'measures'); end
   entity.measures = measures;
   fprintf('saving entity with measures to %s\n',entity.assets.filename)
   save(entity.assets.filename,'entity')
   
   % for TC
   [entity, e_i] = barisal_get_entity(y_i,'cyclones',entity_files);
   % remove old measures, just in case
   if isfield(entity,'measures'),entity = rmfield(entity,'measures'); end
   entity.measures = measures;
   fprintf('saving entity with measures to %s\n',entity.assets.filename)
   save(entity.assets.filename,'entity')
nd
 display measures in their respective colours
or measure_i = 1:length(measures.name),cprintf(measures.color_RGB(measure_i,:),'%s\n',measures.name{measure_i}); end
lear e_i e_dir_i e_dir_ e_subdir_ e_subdir_ m_i m_i measure_i rm_ndx name
% population entity &amp casualties [uncomment, but be careful]
 
 Entity excel file from Ecorys (unstructured)
ntity_file_xls = [entities_dir filesep 'BCC_entity_210615_scenario 1_population.xls'];
 Entity template file from global data dir
ntity_temp_xls = [climada_global.data_dir filesep 'entities' filesep 'entity_template.xls'];
heets          = {'2014' '2030' '2050'}; % for population entity
 load damagefunctions
oad([entities_dir filesep 'BCC_population_entity_090615.mat'])
amagefunctions = entity.damagefunctions;
orce_assets_re_read   = 1;% Whether to re-read entity from xls (1) or load matfiles (0)
or s_i = 1:length(sheets)
   clear entity
   
   % mat file name - separate mat file for each sheet in entity xls
   entity_file_mat     = strrep(entity_file_xls,'.xls',['_' lower(sheets{s_i}) '.mat']);
   
   if exist(entity_file_mat,'file') &amp&amp ~force_assets_re_read
       % Load mat file
       fprintf('entity %s .mat file already exists, skipping\n',lower(sheets{s_i}))
       entity_files{s_i} = entity_file_mat;
       load(entity_file_mat)
       % append filename for consistency
       entity.assets.filename = entity_file_mat;
       % save corrected entity
       save(entity.assets.filename,'entity')
   else
       % read in entity from xls
       entity = climada_entity_read(entity_temp_xls);
       %entity = climada_entity_read_wo_assets(entity_temp_xls);
       entity.assets = climada_xlsread('no',entity_file_xls,sheets{s_i},1);
       entity.assets.comment = ['Population entity ' sheets{s_i}];
       entity.assets.reference_year = str2num(sheets{s_i});
       % coord transformation from UTM to lat lon
       [entity.assets.lon, entity.assets.lat] = utm2ll_shift(entity.assets.lon, entity.assets.lat);
       entity.assets.filename          = entity_file_mat; % for filename consistency
       % use people damagefunctions
       entity.damagefunctions = damagefunctions;
       fprintf('saving entity as %s\n',entity.assets.filename)
       save(entity.assets.filename,'entity')
       entity_files{s_i} = entity.assets.filename;
   end
   
nd
lear entity_file_xls sheets s_i entity_temp_xls entity_file_mat force_assets_re_read
%
limada_global.Value_unit = 'people';
ear_i = 2014; climada_global.present_reference_year = year_i;
ear_f = 2030; climada_global.future_reference_year  = year_f;
c_scen = 'moderate'; ed_i = 0; clear EDS1 EDS2 EDS3 % init
or peril_ID = {'FL_depth_monsoon' 'FL_depth_cyclone'}
   ed_i = ed_i +1;
   % EDS1 for scenario hazard and entity in present reference year
   [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
   [entity,e_i] = barisal_get_entity(year_i,'population',entity_files);
   fprintf('***** EDS1 for %s | %s *****\n',char(entity.assets.comment),char(strtok(hazard.comment,',')))
   EDS1(ed_i)    = climada_EDS_calc(entity,hazard,'',1,'',1);
   scen_name1 = ['Today''s; expected casualties; ' num2str(year_i)];
   fprintf('Annual expected casualties: %2.2f mn\n',EDS1(ed_i).ED)
   
   % EDS2 economic growth, no climate change
   [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
   [entity,e_i] = barisal_get_entity(year_f,'population',entity_files);
   fprintf('***** EDS2 for %s | %s *****\n',char(entity.assets.comment),char(strtok(hazard.comment,',')))
   EDS2(ed_i)    = climada_EDS_calc(entity,hazard,'',1);
   scen_name2 = ['Increase; from population; growth ' num2str(year_f)];
   fprintf('Annual expected casualties: %2.2f mn\n',EDS2(ed_i).ED)
   
   % EDS3 climate change + economic growth
   [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
   [entity,e_i] = barisal_get_entity(year_f,'population',entity_files);
   fprintf('***** EDS3 for %s | %s *****\n',char(entity.assets.comment),char(strtok(hazard.comment,',')))
   EDS3(ed_i)    = climada_EDS_calc(entity,hazard,'',1);
   scen_name3 = ['Increase; from ' cc_scen '; climate change; ' num2str(year_f)];
   fprintf('Annual expected casualties: %2.2f mn\n',EDS3(ed_i).ED)
nd
 figure; climada_ED_plot(EDS1, 0,'people',0,0)
 figure; climada_ED_plot(EDS2, 0,'people',0,0)
 figure; climada_ED_plot(EDS3, 0,'people',0,0)
limada_waterfall_graph_multi_peril(0,'people',EDS1,scen_name1,EDS2,scen_name2,EDS3,scen_name3)
 print(gcf,'-dpng',[results_dir filesep 'BCC_Barisal_population_waterfall_2030.png'])
 
 
ave([results_dir filesep 'Barisal_EDS_people_2014_2030_FL_monsoon_cyclone.mat'],'EDS1', 'EDS2', 'EDS3')
 EDS(1) = climada_EDS_combine(EDS1(1),EDS1(2));
DS(1) = EDS1(1);
DS(1).ED = sum([EDS1.ED]);
DS(2) = EDS2(1);
DS(2).ED = sum([EDS2.ED]);
DS(3) = EDS3(1);
DS(3).ED = sum([EDS3.ED]);
DS(1).hazard.comment = 'FL (monsoon and cyclone)';
DS(2).hazard.comment = 'FL (monsoon and cyclone)';
DS(3).hazard.comment = 'FL (monsoon and cyclone)';
DS(1).assets.filename = 'BCC population 2014';
DS(2).assets.filename = 'BCC population 2030';
DS(3).assets.filename = 'BCC population 2030';
limada_waterfall_graph(EDS(1), EDS(2), EDS(3),'AED');
ave([results_dir filesep 'Barisal_EDS_people_2014_2030.mat'],'EDS')
avefig([results_dir filesep 'Barisal_EDS_people_2014_2030.fig'])
% Multi scenario EDS calc for waterfall
================
 This section is key for measure impact calculations
================
 calculate EDS for each peril in different scenarios specified below. Each
 EDSn corresponds to one bar in the waterfall graph. They should have the
 same length, and each entry in each EDSn corresponds to a peril_ID
 measure impact is also calculated, unless EDS_only is set to 1
eril_IDs   = {'FL_depth_monsoon' 'FL_duration_monsoon' 'FL_depth_cyclone' 'FL_duration_cyclone' 'TC'};
 peril_IDs   = {'TC'};
co_scen    = 1; %[1 2 3];
c_scen     = 'moderate'; %{'moderate' 'extreme'}; %
ear_i      = 2014;
ear_f      = [2030 2050];
DS_only    = 0; %1; %EDS_only    = 0;
ilent_mode = 0;
anity_check = 1;
init
 clear EDS1 EDS2 EDS3 EDS4 EDS5 
 clear measures_impact1 measures_impact3 measures_impact5
or scenario_eco_i = 1:numel(eco_scen)
   % for year_f = [2050 2030]
   %ed_i = 0;
   for p_i = 4%1:numel(peril_IDs); %peril_IDs(1) %peril_ID = peril_IDs %
       peril_ID = peril_IDs{p_i};
       if strcmp(peril_ID,'TC')
           peril = 'cyclone';
       else
           peril = 'flood';
       end
       %ed_i = ed_i+1; % counter for EDS entries
       ed_i = p_i; % counter for EDS entries
       year_f = 2030;
       climada_global.future_reference_year = year_f;
       % EDS1 for scenario hazard and entity in present reference year
       [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_i,peril,entity_files,eco_scen(scenario_eco_i));
       %EDS1    = barisal_get_EDS(EDS,entity_files{e_i},hazard_files{h_i});
       fprintf('\n***** Scenario %d, EDS1 for %s | %s *****\n', scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       scen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
       %fprintf('Annual expected damage: %2.2f mn\n',EDS1(ed_i).ED/1000000)
       if ~EDS_only
           measures_impact1(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           measures_impact1(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_' num2str(year_i) '.mat'];
           for i = 1:length(measures_impact1(ed_i).EDS)
               % convert back to UTM
               [measures_impact1(ed_i).EDS(i).assets.X,measures_impact1(ed_i).EDS(i).assets.Y] = ...
                   ll2utm_shift(measures_impact1(ed_i).EDS(i).assets.lat,measures_impact1(ed_i).EDS(i).assets.lon);
           end
           save(measures_impact1(ed_i).filename,'measures_impact1')
       else
           EDS1(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
       end        
       if EDS_only
           % EDS2 for socio-economic growth scenario: present hazard, future entity 2030
           [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
           [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
           %EDS2    = barisal_get_EDS(EDS,entity_files{e_i},hazard_files{h_i});
           fprintf('\n***** Scenario %d, EDS2 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
           EDS2(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
           scen_name2 = sprintf('Increase;from economic;growth %d;scenario %d',num2str(year_f),eco_scen(scenario_eco_i));
           fprintf('Annual expected damage: %2.2f mn\n',EDS2(ed_i).ED/1000000)
           %entity.measures = climada_measures_construct([],1);
           %entity.measures.name{1} = 'control';
           %measures_impact2(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           %for i = 1:length(measures_impact2(ed_i).EDS)
           %    % convert back to UTM
           %    [measures_impact2(ed_i).EDS(i).assets.X,measures_impact2(ed_i).EDS(i).assets.Y] = ...
           %        ll2utm_shift(measures_impact2(ed_i).EDS(i).assets.lat,measures_impact2(ed_i).EDS(i).assets.lon);
           %end
       end
       % EDS3 for climate change scenario: future entity 2030, future hazard 2030
       if scenario_eco_i == 2
           cc_scen = 'extreme';
       else 
           cc_scen = 'moderate';
       end
       [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       fprintf('\n***** Scenario %d, EDS3 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name3 = ['Increase; from ' cc_scen '; climate change; ' num2str(year_f)];
       scen_name3 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
       %fprintf('Annual expected damage: %2.2f mn\n',EDS3(ed_i).ED/1000000)
       if ~EDS_only
           measures_impact3(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           measures_impact3(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_cc_' cc_scen '_' num2str(year_f) '.mat'];
           for i = 1:length(measures_impact3(ed_i).EDS)
               % convert back to UTM
               [measures_impact3(ed_i).EDS(i).assets.X,measures_impact3(ed_i).EDS(i).assets.Y] = ...
                   ll2utm_shift(measures_impact3(ed_i).EDS(i).assets.lat,measures_impact3(ed_i).EDS(i).assets.lon);
           end
           save(measures_impact3(ed_i).filename,'measures_impact3')
       else
           EDS3(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
       end
       year_f = 2050;
       climada_global.future_reference_year = year_f;
       if EDS_only
           % EDS4 for socio-economic growth scenario: present hazard, future entity 2050
           [hazard,h_i] = barisal_get_hazard(year_i,'',peril_ID,hazard_files);
           [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
           fprintf('\n***** Scenario %d, EDS4 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
           EDS4(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
           %scen_name4 = ['Increase; from economic; growth ' num2str(year_f)];
           scen_name4 = sprintf('Increase;from economic; growth %d;scenario %d',num2str(year_f),eco_scen(scenario_eco_i));
           fprintf('Annual expected damage: %2.2f mn\n',EDS4(ed_i).ED/1000000)
           %entity.measures = climada_measures_construct([],1);
           %entity.measures.name{1} = 'control';
           %measures_impact4(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           %for i = 1:length(measures_impact4(ed_i).EDS)
           %    % convert back to UTM
           %    [measures_impact4(ed_i).EDS(i).assets.X,measures_impact4(ed_i).EDS(i).assets.Y] = ...
           %        ll2utm_shift(measures_impact4(ed_i).EDS(i).assets.lat,measures_impact4(ed_i).EDS(i).assets.lon);
           %end
       end
       % EDS5 for climate change scenario: future entity 2050, future hazard 2050
       if scenario_eco_i == 2
           cc_scen = 'extreme';
       else 
           cc_scen = 'moderate';
       end
       [hazard,h_i] = barisal_get_hazard(year_f,cc_scen,peril_ID,hazard_files);
       [entity,e_i] = barisal_get_entity(year_f,peril,entity_files,eco_scen(scenario_eco_i));
       fprintf('\n***** Scenario %d, EDS5 for %s | %s *****\n',scenario_eco_i,char(entity.assets.comment),char(strtok(hazard.comment,',')))
       %scen_name5 = ['Increase; from ' cc_scen '; climate change; ' num2str(year_f)];
       scen_name5 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
       if ~EDS_only
           measures_impact5(ed_i) = climada_measures_impact_advanced(entity,hazard,'no');
           measures_impact5(ed_i).filename = [results_dir filesep 'BCC_measure_package_impact_cc_' cc_scen '_' num2str(year_f) '.mat'];
           for i = 1:length(measures_impact5(ed_i).EDS)
               % convert back to UTM
               [measures_impact5(ed_i).EDS(i).assets.X,measures_impact5(ed_i).EDS(i).assets.Y] = ...
                   ll2utm_shift(measures_impact5(ed_i).EDS(i).assets.lat,measures_impact5(ed_i).EDS(i).assets.lon);
           end
           save(measures_impact5(ed_i).filename,'measures_impact5')
       else
           EDS5(ed_i)    = climada_EDS_calc(entity,hazard,'',1,silent_mode,sanity_check);
           fprintf('Annual expected damage: %2.2f mn\n',EDS5(ed_i).ED/1000000)
       end
   end
   %save([results_dir filesep sprintf('EDS_scenario_%d.mat',scenario_eco_i)], 'EDS1', 'EDS2', 'EDS3', 'EDS4', 'EDS5')
   clear EDS1 EDS2 EDS3 EDS4 EDS5
nd %scenario_eco_i
%
I_EDS_report_xls = [results_dir filesep 'BCC_ED_report_Measure_package_' datestr(now,'ddmmyy') '.xls'];
f ~EDS_only
   for m = [1 3 5]
       measures_impact = eval(['measures_impact' num2str(m)]);
         eval(['MI_EDS_combined' num2str(m) ' = climada_measures_impact_report(measures_impact,''NO_SAVE''); '])
       eval(['MI_EDS_combined' num2str(m) ' = climada_measures_impact_report(measures_impact,MI_EDS_report_xls); '])
   end
nd
%
 plotting frenzy
 for ed_i = 1:length(EDS1)
     climada_ED_plot(EDS1(ed_i), 0,'BDT',0,0)
     print(gcf,'-dpng',[results_dir filesep 'BCC_dmg_slums_' strrep(strtok(EDS1(ed_i).hazard.comment,','),' ','_') '.png'])
     climada_shapeplotter(BCC_wards_ll,'','linewidth',1,'color',[81 81 81]/255);
     close
     climada_ED_plot(EDS3(ed_i), 0,'BDT',0,0)
     print(gcf,'-dpng',[results_dir filesep 'BCC_dmg_slums_' strrep(strtok(EDS3(ed_i).hazard.comment,','),' ','_') '.png'])
     climada_shapeplotter(BCC_wards_ll,'','linewidth',1,'color',[81 81 81]/255);
     close
     climada_ED_plot(EDS5(ed_i), 0,'BDT',0,0)
     print(gcf,'-dpng',[results_dir filesep 'BCC_dmg_slums_' strrep(strtok(EDS5(ed_i).hazard.comment,','),' ','_') '.png'])
     climada_shapeplotter(BCC_wards_ll,'','linewidth',1,'color',[81 81 81]/255);
     close
 end
% measures impact (benefits) report per peril
arisal_MI_per_peril(measures_impact5,measures,peril_IDs)
% multi peril waterfall graph
ear_i = 2014;
cen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
ear_f = 2030;
co_scen    = [1 2 3];scenario_eco_i = 2;
cen_name2 = sprintf('Increase;from economic;growth %d;scenario %d',num2str(year_f),eco_scen(scenario_eco_i));
c_scen = 'moderate';
cen_name3 = sprintf('Increase;from %s;climate change;%d',cc_scen,num2str(year_f));
f exist('EDS1','var') &amp&amp exist('EDS2','var') &amp&amp exist('EDS3','var') &amp&amp exist('EDS4','var') &amp&amp exist('EDS5','var')
   % multi peril waterfall 2030
   fig = climada_waterfall_graph_multi_peril(0,'BDT',EDS1,scen_name1,EDS2,scen_name2,EDS3,scen_name3);
   print(fig,'-dpng',[results_dir filesep 'BCC_waterfall_multi_peril_2030_' char(cc_scen) '.png'])
   % multi peril waterfall 2050
   fig = climada_waterfall_graph_multi_peril(0,'BDT',EDS1,scen_name1,EDS4,scen_name4,EDS5,scen_name5);
   print(fig,'-dpng',[results_dir filesep 'BCC_waterfall_multi_peril_2050_' char(cc_scen) '.png'])
   
   % multi horizon waterfall (watch out! may be a bit dodgy...)
   %fig = climada_waterfall_graph_2timehorizons('AED',0,'BDT',...
   %    MI_EDS_combined1(end),   ...
   %    MI_EDS_combined2(end),   ...
   %    MI_EDS_combined3(end),   ...
   %    MI_EDS_combined4(end),   ...
   %    MI_EDS_combined5(end)          );
   %print(fig,'-dpng',[results_dir filesep 'BCC_waterfall_multi_horizon_' char(cc_scen) '.png'])
nd
or s_i = [1 3 5]
   MI_EDS_combined = eval(['MI_EDS_combined' num2str(s_i)]);
   for ed_i = 1:length(MI_EDS_combined)
       % use UTM X/Y instead of lat/lon, temporarily overwrite lat/lon
       MI_EDS_combined(ed_i).assets.lon = MI_EDS_combined(ed_i).assets.X;
       MI_EDS_combined(ed_i).assets.lat = MI_EDS_combined(ed_i).assets.Y;
       climada_MI_plot(MI_EDS_combined(ed_i), 0,'BDT',0,0,1)
       climada_shapeplotter(BCC_wards_ll,'','x','y','linewidth',1,'color',[81 81 81]/255);
       print(gcf,'-dpng',[results_dir filesep 'BCC_measure_benefit_' ...
           strrep(MI_EDS_combined(ed_i).annotation_name,' ','_') '_' ...
           num2str(MI_EDS_combined(1).reference_year) '.png'])
       close
   end
nd
lear -regexp ^scen_name\d{1}$
lear m measures_impact cc_scen ed_i s_i 
% baseline EDS for ED report for Ecorys
 EDS_baseline = [EDS1 EDS2 EDS3 EDS4 EDS5]; save([results_dir filesep 'EDS_baseline.mat'],'EDS_baseline')
limada_global.present_reference_year = 2014;
co_scen    = [1 2 3];
c_scen     = 'moderate';
or scenario_eco_i = 1:numel(eco_scen)
   clear EDS_baseline 
   
   load([results_dir filesep sprintf('EDS_scenario_%d.mat',eco_scen(scenario_eco_i))])
   
   if scenario_eco_i == 2
       cc_scen = 'extreme';
   else 
       cc_scen = 'moderate';
   end
   % annotation 
   year_i = 2014;
   scen_name1 = ['Today''s; expected damage; ' num2str(year_i)];
   year_f = 2030;
   scen_name2 = sprintf('Increase\nfrom economic\ngrowth %d,\nscenario %d',year_f,eco_scen(scenario_eco_i));
   scen_name3 = sprintf('Increase\nfrom %s\nclimate change\n%d',cc_scen,year_f);
   year_f = 2050;
   scen_name4 = sprintf('Increase\nfrom economic\ngrowth %d,\nscenario %d',year_f,eco_scen(scenario_eco_i));
   scen_name5 = sprintf('Increase\nfrom %s\nclimate change\n%d',cc_scen,year_f);
   
   % multi peril waterfall 2030
   fig = climada_waterfall_graph_multi_peril(0,'BDT',EDS1,scen_name1,EDS2,scen_name2,EDS3,scen_name3);
   print(fig,'-dpdf',[results_dir filesep sprintf('BCC_waterfall_multi_peril_scenario_%d_2030_%s.pdf',eco_scen(scenario_eco_i),char(cc_scen))])
   % multi peril waterfall 2050
   fig = climada_waterfall_graph_multi_peril(0,'BDT',EDS1,scen_name1,EDS4,scen_name4,EDS5,scen_name5);
   print(fig,'-dpdf',[results_dir filesep sprintf('BCC_waterfall_multi_peril_scenario_%d_2050_%s.pdf',eco_scen(scenario_eco_i),char(cc_scen))])
     EDS_baseline = [EDS1 EDS3 EDS5]; %save([results_dir filesep 'EDS_baseline.mat'],'EDS_baseline')
     EDS_report_xls = [results_dir filesep sprintf('BCC_ED_report_scenario_%d_%s.xls',eco_scen(scenario_eco_i),datestr(now,'yyyymmdd'))];
     EDS_report_csv = [results_dir filesep sprintf('BCC_ED_report_scenario_%d_%s.csv',eco_scen(scenario_eco_i),datestr(now,'yyyymmdd'))];
 
     if exist(EDS_report_xls,'file'), delete(EDS_report_xls); end
     % convert back to UTM
     for ed_i = 1:length(EDS_baseline)
         [EDS_baseline(ed_i).assets.X,EDS_baseline(ed_i).assets.Y] = ...
             ll2utm_shift(EDS_baseline(ed_i).assets.lat,EDS_baseline(ed_i).assets.lon);
         EDS_baseline(ed_i).peril_ID = '';
     end
 
     % write to csv
     % climada_EDS_ED_at_centroid_report(EDS_baseline,EDS_report_csv);
 
     % write to excel
     climada_EDS_ED_at_centroid_report_xls(EDS_baseline,EDS_report_xls,'ED_at_centroid');
     
     % write ED per category report
     benefit_flag = 0;
     assets_flag = 1;
     output_report = climada_EDS_ED_per_category_report(entity, EDS_baseline, EDS_report_xls,'ED_per_category',benefit_flag,0,assets_flag);
nd
lear peril_ID peril year_i year_f EDS_only EDS_report_xls h_i e_i peril_IDs CC_SCEN YEAR_F EDS_report_csv
% damage calc
 This section has become somewhat redundant.
 calculate EDS for each entity-hazard pair, where they have coinciding
 reference years and the correct peril_ID matching. Store as struct array
 and save as EDS_save_file
DS_save_file = [results_dir filesep 'BCC_EDS_' datestr(now,'ddmmyy') '.mat'];
DS_load_file = [results_dir filesep 'BCC_EDS_090615.mat'];
DS_force_recalc = 0;
f exist(EDS_load_file,'file') &amp&amp ~EDS_force_recalc
   load(EDS_load_file)
lse
   EDS        = climada_EDS_multi_calc(entity_files,hazard_files,EDS_save_file,1,0);
nd
 But this may still be useful to get the total asset base into the EDS
 struct for climada_ED_plot
 total value from max of flood entity and cyclone entity at each point
or i = 1:5
   EDS = eval(['EDS' num2str(i)]);
   for ed_i = 1:length(EDS)
       ndx = find([EDS.reference_year] == EDS(ed_i).reference_year);
       max_val = [];
       for ndx_i = ndx
           max_val = max([max_val EDS(ndx_i).assets.Value],[],2);
       end
       
       EDS(ed_i).Value_total = sum(max_val);
   end
   eval(['EDS' num2str(i) '=EDS;']);
nd
lear max_val ndx EDS_force_recalc ed_i EDS_load_file EDS_save_file ndx_i
% multi peril adaptation cost curve
 set parameters to key scenario 2030, moderate climate change, so far
 measures for flood only (TC wind excluded)
azard_ref_year = 2030;
ntity_ref_year = 2030;
c_scen         = 'extreme'; %{'moderate' 'extreme'};
eril_IDs       = {'FL_depth_monsoon' 'FL_duration_monsoon' 'FL_depth_cyclone' 'FL_duration_cyclone'};
 init
easures_impact = [];
 load flood entity, is always the same and does not need to be reloaded in
 the loop
ntity = barisal_get_entity(entity_ref_year,'flood',entity_files);
ntity.measures.cost = (entity.measures.cost)*0 + 10^4;
 loop over the four different flood perils
or peril_i = 1:length(peril_IDs)
   
   % load hazard
   hazard = barisal_get_hazard(hazard_ref_year,cc_scen,peril_IDs(peril_i),hazard_files);
   
   % calculate measures impact
   measures_impact_peril = climada_measures_impact_advanced(entity,hazard,'no');
   
   % combine measures_impact with measures_impact, that will contain the
   % added up benefits and cost_benefit_ratio
   if isempty(measures_impact)
       fprintf('\t-Start with measures impact from %s. \n', peril_IDs{peril_i})
       measures_impact = measures_impact_peril;
   else
       fprintf('\t-Add measures impact from %s. \n', peril_IDs{peril_i})
       measures_impact = climada_measures_impact_combine(measures_impact,measures_impact_peril);
   end
nd
 finally create figure (multi peril adaptation cost curve)
igure
arisal_adaptation_cost_curve(measures_impact,[],[],[],0,0,1,0)
itlestr = sprintf('Barisal, %d, %s climate change', hazard_ref_year, CC_SCEN);
itle({titlestr;'All perils combined (FL depth, duration, monsoon and cyclone, except TC wind)'})
azard_name = 'all_perils';
ntity_name = '2030_moderate_cc';
rint(gcf,'-dpng',[results_dir filesep 'CBA_Barisal_BCC_' hazard_name '_' entity_name '.png']) % save as png
% measures impact for specific scenario
 calculate the impact of measures for 1 scenario specified below
azard_ref_year = 2014;
ntity_ref_year = 2030;
eril_ID        = 'FL_depth_monsoon'; % Should be found in hazard filename
eril           = 'floods';           % Should be found in entity filename
c_scen         = '';                 % Should be found in hazard filename
 retrieve relevant hazard and entity. The index (h_i/e_i) is for the cell
 arrays containing respective filenames
hazard,h_i] = barisal_get_hazard(hazard_ref_year,cc_scen,peril_ID,hazard_files);
entity,e_i] = barisal_get_entity(entity_ref_year,peril,entity_files);
 get name of entity/hazard
~,hazard_name] = fileparts(hazard_files{h_i});
~,entity_name] = fileparts(entity_files{e_i});
 calculate impact
printf('%s | %s | %d\n',entity.assets.comment,hazard.comment,hazard.reference_year) % to monitor
ntity.measures.cost = (entity.measures.cost)*0 + 10^4;
easures_impact = climada_measures_impact_advanced(entity,hazard,'no');
 plot cost curve (barisal_adaptation_cost_curve is identical to climada_adaptation_cost_curve
 but sets currency to BDT)
 measures_impact.measures.cost = zeros(size(measures_impact.measures.cost))+10^4;
igure
arisal_adaptation_cost_curve(measures_impact,[],[],[],0,0,1,0)
rint(gcf,'-dpng',[results_dir filesep 'CBA_' hazard_name '_' entity_name '.png']) % save as png
lear hazard_ref_year entity_ref_year peril_ID peril cc_scen hazard_name entity_name
% stats for Gerbrand v Bork
ard_ndx = [32 34 27 28 33 29 30]; %shape index for wards 1-7
or ward_i = ward_ndx
   [POI.lon(find(ward_ndx == ward_i)),POI.lat(find(ward_ndx == ward_i))] ...
       = utm2ll_shift(mean(BCC_wards(ward_i).BoundingBox(:,1)),...
       mean(BCC_wards(ward_i).BoundingBox(:,2)));
   POI.name{find(ward_ndx == ward_i)}= BCC_wards(ward_i).UNION_NAME;
nd
azard = barisal_get_hazard(2030,'extreme','FL_duration_monsoon',hazard_files);
FC = climada_hazard2IFC(hazard,POI,1);
lear POI ward_i ward_ndx
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_risk_calculations.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="barisal_tc_hazard_prob">
<H2>barisal_tc_hazard_prob</H2></A>
amplt&amplt&amplt&amplt&amplt&amplt&amplt HEAD
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
% plot historical tc tracks
c_track_file = [climada_global.data_dir filesep 'tc_tracks' filesep 'tracks_n_indian_proc'];
oad(tc_track_file)
ig = climada_figuresize(0.5,0.7);
heck_country = 'Bangladesh';
eep_boundary = 0;
limada_plot_world_borders(1,check_country,'',keep_boundary,'');
rack_count = numel(tc_track);
or track_i = 1:track_count
   h = climada_plot_tc_track_stormcategory(tc_track(track_i),5,[]);
nd
add legend, makes it quite slow
limada_plot_tc_track_stormcategory(0,8,1);
xis equal
xis([79 98 14 28])
 axis([70 110 06 32])   
ilename = [filesep 'results' filesep 'TC_tracks_NIO_hist.pdf'];
rint(fig,'-dpdf',[climada_global.data_dir filename])
printf('figure saved in %s \n', filename) 
atestr(tc_track(1).datenum(1))
atestr(tc_track(end).datenum(end))
% create tc track probabilistic for barisal
c_track_file = [climada_global.data_dir filesep 'tc_tracks' filesep 'tracks_n_indian_proc'];
oad(tc_track_file)
c_track_save = [tc_track_file '_prob.mat'];
ns_size      = 9;
ns_amp       = 0.2; %degree
axangle      = pi/4;
c_track      = climada_tc_random_walk_position_windspeed(tc_track,tc_track_save,ens_size,ens_amp,maxangle,1, 0);
 ens_amp  = [];
 Maxangle = [];
 tc_track_out  = climada_tc_random_walk(tc_track,ens_size,ens_amp,Maxangle,0);
ave(tc_track_save, 'tc_track')
oad(tc_track_save)
% create tc track figure
 load BCC boundaries file
hp_mat_file = [climada_global.data_dir filesep 'results' filesep 'BCC_boundary_shp.mat'];
oad(shp_mat_file)
ig = climada_figuresize(0.5,0.7);
vent_i = 173;
heck_country = 'Bangladesh';
eep_boundary = 0;
limada_plot_world_borders(1,check_country,'',keep_boundary,'');
or t_i = (event_i-1)*(ens_size+1)+1:1:(event_i+0)*(ens_size+1)  %1:numel(tc_track)
   if tc_track(t_i).orig_event_flag == 1
       plot(tc_track(t_i).lon, tc_track(t_i).lat,'.-r','markersize',3)
       hold on
   else
       plot(tc_track(t_i).lon, tc_track(t_i).lat,'.-b','markersize',3)
       hold on
   end
nd
or s_i = 1:numel(BCC_boundary)
   plot(BCC_boundary(s_i).X, BCC_boundary(s_i).Y,'-k');
nd
xis([82 97 17 28])
xis equal
 axis([82 97 17 28])
xis([70 110 06 32])
label('Longitude'); ylabel('Latitude')
oldername  = [filesep 'results' filesep 'Sidr_probabilistic_daughters.pdf'];
rint(fig,'-dpdf',[climada_global.data_dir foldername])
 datestr(hazard.datenum(172*4+1:173*4))
 datestr(hazard.datenum((event_i-1)*(ens_size+1)+1:1:event_i*(ens_size+1)))
limada_plot_probabilistic_wind_speed_map(tc_track, (event_i-1)*(ens_size+1)+1)
% footprint figure
 climada_plot_tc_footprint(hazard,tc_track((event_i-1)*(ens_size+1)+1))
 caxis_range = '';
 res=climada_hazard_plot(hazard,(event_i-1)*(ens_size+1)+1);
 
 load([climada_global.modules_dir filesep 'barisal_demo' filesep 'data' filesep 'entities' filesep 'Barisal_BCC_1km_100.mat'])
 focus_region = [70 110 06 32];
 check_mode = '';
 tc_track_1 = tc_track((event_i-1)*(ens_size+1)+1);
 hazard = climada_event_damage_data_tc(tc_track_1,entity,'',0,check_mode,focus_region);
 climada_event_damage_animation
% create probabilistic tc hazard set
entroids_file  = [climada_global.centroids_dir filesep 'Barisal_BCC_centroids'];
oad(centroids_file)
azard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_prob'];
azard = climada_tc_hazard_set(tc_track, hazard_set_file, centroids);
 tweek the frequencies
azard.frequency_ori = hazard.frequency;
azard.frequency     = hazard.frequency_ori*6;
 ori_flag          = logical(hazard.orig_event_flag);
 hazard.frequency(ori_flag) = hazard.frequency_ori(ori_flag);
ave(hazard_set_file,'hazard')
 add tc track category manually
 hazard.category = [tc_track.category];
 hazard.category(hazard.category&amplt0) = 0;
 just loading not calculating
azard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'Barisal_BCC_hazard_TC_prob'];
oad(hazard_set_file)
% view wind results in Barisal (centroid ID 30)
entroid_ID = [30];
FC = climada_hazard2IFC(hazard, centroid_ID);
lose all
limada_IFC_plot(IFC,0)
oldername  = [filesep 'results' filesep 'TC_wind_intensity_Barisal.pdf'];
rint(gcf,'-dpdf',[climada_global.data_dir foldername])
% was the max event Sidr? (Nov 2007)
rig_event_flag = logical(hazard.orig_event_flag);
int_max indx]  = max(full(hazard.intensity(orig_event_flag,centroid_ID)));
ndx = (indx-1)*(ens_size+1)+1;
azard.name{indx}
atestr(hazard.datenum(indx))
 yes, this is Sidr: 46.8 m/s at centroid_ID 30, 10 Nov 2007
 datestr(hazard.datenum(172*4+1:173*4))
 int_Sidr = full(hazard.intensity(172*10+1,centroid_ID))
 event_i = 172*4+1;
 figure
 res=climada_hazard_plot(hazard,event_i,'','','');
 res=climada_hazard_plot(hazard,event_i+1,'','','');
 figure
 res=climada_hazard_plot(hazard,event_i+2,'','','');
 figure
 res=climada_hazard_plot(hazard,event_i+3,'','','');
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/barisal_tc_hazard_prob.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_ED_at_centroid_report_xls">
<H2>climada_EDS_ED_at_centroid_report_xls</H2></A>
<font color="blue">function climada_EDS_ED_at_centroid_report_xls(EDS,xls_file,sheet,varargin) </font>
 climada
 NAME:
   climada_EDS_ED_at_centroid_report
 PURPOSE:
   Write out ED at centroids for one or multiple EDS structures into .csv
   file
   previous call: climada_EDS_calc
 CALLING SEQUENCE:
   climada_EDS_ED_at_centroid_report(EDS,entity,xls_file)
 EXAMPLE:
   climada_EDS_ED_at_centroid_report(climada_EDS_calc(climada_entity_read), climada_entity_read)
 INPUTS:
   EDS: either an event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       SPECIAL: we also accept a structure which contains an EDS, like
       measures_impact.EDS
       if EDS has the field annotation_name, the legend will show this
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   xls_file: filename (and path) to save the report to (as .xls), if
       empty, prompted for
 OUTPUTS:
   none, report file written as .xls
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150430, init
 Gilles Stassen, gillesstassen@hotmail.com, 20150625, generalisation with varargin
 Lea Mueller, muellele@gmail.com, 20150730, check that category iscell, otherwise convert to cell from numeric
 Lea Mueller, muellele@gmail.com, 20150805, check if data is on lat/lon or X/Y basis
 Lea Mueller, muellele@gmail.com, 20150910, check first lat/lon, then additionally X/Y can be added
 Lea Mueller, muellele@gmail.com, 20150930, ignore EDS that contains different length of centroids
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/climada_EDS_ED_at_centroid_report_xls.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_multi_calc">
<H2>climada_EDS_multi_calc</H2></A>
<font color="blue">function [EDS, hazards, entities] = climada_EDS_multi_calc(entities,hazards,EDS_save_file,sync_check,check_plots) </font>
 damage calc for combination of hazards and entities
lobal climada_global
f ~climada_init_vars, return; end
f ~exist('entities',       'var'), entities        = '';   end
f ~exist('hazards',        'var'), hazards         = '';   end
f ~exist('EDS_save_file',  'var'), EDS_save_file   = '';   end
f ~exist('sync_check',     'var'), sync_check      = 1;    end
f ~exist('check_plots',    'var'), check_plots 	= 0;    end
odule_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
 prompt for entity
f isempty(entities)
   entities=[module_data_dir filesep 'entities' filesep '*.mat'];
   [fN, fP] = uigetfile(entities, 'Select entities:','MultiSelect','on');
lse
   if ischar(entities) % only one filename passed
       [fP, fN] = fileparts(entities);
       if ~climada_check_matfile(entities)
           climada_entity_read(entities,'NOENCODE')
       end
       fN = [fN '.mat'];
   elseif iscellstr(entities) % multiple filenames passed in 
       for e_i = 1:length(entities)
           [fP, fN{e_i}] = fileparts(entities{e_i});
           fN{e_i} = [fN{e_i} '.mat'];
       end   
   end
nd
lear entities
f isequal(fN,0) || isequal(fP,0)
   return; % cancel
lse
   if iscell(fN)
       fmt_str = '%s';
       for e_i = 1 : length(fN)
           msg_str = sprintf('loading entity file: %s',fN{e_i});
           fprintf(fmt_str,msg_str)
           fmt_str = [repmat('\b',size(msg_str)) '%s'];
           load(fullfile(fP,fN{e_i}));
           if ~exist('entity','var'), cprintf([1 0 0],'ERROR: invalid entity file \n'); return; end
           entities(e_i) = entity;
           % for consistency
           entities(e_i).assets.filename = fullfile(fP,fN{e_i});
       end
       fprintf(fmt_str,'entity files loaded \n')
   else
       fprintf('loading entity file: %s... ',fN);
       load(fullfile(fP,fN));
       if ~exist('entity','var'), cprintf([1 0 0],'ERROR: invalid entity file \n'); return; end
       entities = entity;
       % for consistency
       entities(e_i).assets.filename = fullfile(fP,fN{e_i});
       fprintf('done \n')
   end
   clear entity
nd
or e_i = 1:length(entities)
   if ~isfield(entities(e_i).assets,'reference_year')
       entities(e_i).assets.reference_year = climada_global.present_reference_year;
   end
   
   flds = fieldnames(entities(e_i).assets);
   rm_flds = {};
   for fld_i = 1:length(flds)
       if strfind(flds{fld_i},'Value_')
           rm_flds(end+1) = flds(fld_i);
           
           tmp_assets          = entities(e_i).assets;
           %             tmp_assets          = rmfield(entity(e_i).assets,flds{fld_i});
           
           tmp_assets.Value    = entities(e_i).assets.(flds{fld_i});
           C = strsplit(flds{fld_i},'_');
           tmp_assets.reference_year = str2double(C{2});
           
           entities(end+1).damagefunctions   = entities(e_i).damagefunctions;
           entities(end).measures            = entities(e_i).measures;
           entities(end).discount            = entities(e_i).discount;
           entities(end).assets              = tmp_assets;
           
       end
       clear tmp_assets
   end
nd
or e_i = 1:length(entities)
   a_flds = fieldnames(entities(e_i).assets);
   for a_fld_i = 1:length(a_flds)
       if ismember(a_flds{a_fld_i},rm_flds)
           entities(e_i).assets  = rmfield(entities(e_i).assets,a_flds{a_fld_i});
       end
   end
nd
lear e_i a_flds a_fld_i flds fld_i rm_flds
 fields necessary for damage calc
 prompt for hazard set
f isempty(hazards)
   hazards=[module_data_dir filesep 'hazards' filesep '*.mat'];
   [fN, fP] = uigetfile(hazards, 'Select hazard:','MultiSelect','on');
lse
   if ischar(hazards) % only one filename passed
       [fP, fN] = fileparts(hazards);
       fN = [fN '.mat'];
   elseif iscellstr(hazards) % multiple filenames passed in 
       for h_i = 1:length(hazards)
           [fP, fN{h_i}] = fileparts(hazards{h_i});
           fN{h_i} = [fN{h_i} '.mat'];
       end
   end
nd
lear hazards
f isequal(fN,0) || isequal(fP,0)
   return; % cancel
lse
   if iscell(fN)
       fmt_str = '%s'; hazards = {};
       for h_i = 1 : length(fN)
           msg_str = sprintf('loading hazard file: %s',fN{h_i});
           fprintf(fmt_str,msg_str)
           fmt_str = [repmat('\b',size(msg_str)) '%s'];
           load(fullfile(fP,fN{h_i}));
           if ~exist('hazard','var'), cprintf([1 0 0],'ERROR: invalid hazard file \n'); return; end
           
           if ~isfield(hazard,'reference_year')
               cprintf([1 0.5 0],sprintf('WARNING: no reference year for %s - using default %4.0f\n',...
                   fN{h_i},climada_global.present_reference_year));
               hazard.reference_year = climada_global.present_reference_year;
           end
           
           % for consistency
           hazard.filename = fullfile(fP,fN{h_i});
           hazard.comment = strrep(strtok(fN{h_i},'.'),'_',' ');
           hazards{h_i}=hazard;
           
       end
       fprintf(fmt_str,'hazard files loaded \n');
   else
       fprintf('loading hazard file: %s... ',fN);
       load(fullfile(fP,fN));
       if ~exist('hazard','var'), cprintf([1 0 0],'ERROR: invalid hazard file \n'); return; end
       
       if ~isfield(hazard,'reference_year')
           cprintf([1 0.5 0],sprintf('WARNING: no reference year for %s - using default %4.0f\n',...
               fN{h_i},climada_global.present_reference_year));
           hazard.reference_year = climada_global.present_reference_year;
       end
       
       % for consistency
       hazard.filename = fullfile(fP,fN);
       hazard.comment = strrep(strtok(fN{h_i},'.'),'_',' ');
       hazards={hazard};
       fprintf('done \n')
   end
   clear hazard
nd
d_i = 0;
or e_i = 1: length(entities)
   for h_i = 1: length(hazards)
       hazard_i = hazards{h_i};
       
       if sync_check &amp&amp (hazard_i.reference_year ~= entities(e_i).assets.reference_year) ...
               &amp&amp (~(~isempty(strfind(entities(e_i).assets.comment,'Flood')) &amp&amp strcmp(hazard_i.peril_ID,'FL')) ...
               || ~(~isempty(strfind(entities(e_i).assets.comment,'Cyclone')) &amp&amp strcmp(hazard_i.peril_ID,'TC')))
           continue;
       end
       
       ed_i = ed_i +1;
         fprintf('hazard.comment = ''%s'' \n- would you like to use this for the EDS annotation?\n',hazard(h_i).comment)
         h_str = input('to continue press ''y'', otherwise type a new hazard title:\n','s');

         if strcmp(h_str,'y'),   h_str = hazard(h_i).comment;        end

        	fprintf('entity.assets.comment = ''%s'' \n- would you like to use this for the EDS annotation?\n',entity(e_i).assets.comment)
         e_str = input('to continue press ''y'', otherwise type a new entity title:\n','s');

         if strcmp(e_str,'y'),   e_str = entity(e_i).assets.comment; end
       
       h_str = hazard_i.comment;
       e_str = entities(e_i).assets.comment;
       
         annotation  = sprintf('%s | %s (%d)',h_str,e_str,entities(e_i).assets.reference_year);
       annotation  = sprintf(h_str);
       EDS(ed_i)   = climada_EDS_calc(entities(e_i),hazard_i,annotation);
       if EDS(ed_i).ED == 0
           msg = sprintf('WARNING: expected damage equals zero for entity %s and hazard %s, removing from EDS structure\n',...
               e_str,h_str);
           cprintf([1 0.5 0],msg)
           EDS(ed_i) = [];
           ed_i = ed_i - 1;
       end
   end
nd
f ~isempty(EDS_save_file) &amp&amp ischar(EDS_save_file) &amp&amp ~strcmp(EDS_save_file,'NO_SAVE')
   save(EDS_save_file,'EDS')
lseif isempty(EDS_save_file)
   uisave('EDS',[module_data_dir filesep 'results' filesep 'multi_EDS.mat']);
nd
f check_plots
   figure('color','w','name',annotation)
   climada_ED_plot(EDS,0);
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/climada_EDS_multi_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ED_plot_per_point">
<H2>climada_ED_plot_per_point</H2></A>
<font color="blue">function fig = climada_ED_plot_per_point(EDS, BCC_wards, timehorizon, hazard_name) </font>
 create figure to plot expected damage per ward in barisal
 MODULE: 
   barisal_demo
 NAME:
   climada_ED_plot_per_ward
 PURPOSE:
   plot annual expected damage per ward on a map
 CALLING SEQUENCE:
   fig = climada_ED_plot_per_ward(EDS,entity, BCC_wards, timehorizon, hazard_name)
 EXAMPLE:
   fig = climada_ED_plot_per_ward(EDS,entity, BCC_wards, timehorizon, hazard_name)
 INPUTS:
   EDS: event damage set, as e.g. returned by climada_EDS_calc or
       a file containing such a structure
       EDS can contain multiple EDS, however default is that first EDS
       will be used.
   entity: an entity (see climada_entity_read)
       &ampgt promted for if not given
   BCC_wards: structure with shape file (polygons for all 30 wards in
       Barisal)
 OPTIONAL INPUT PARAMETERS:
   timehorizon: just for figure title, empty if not specified
   hazard_name: just for figure title, empty if not specified
 OUTPUTS:
   figure with damage per ward on a map 
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150429, init
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/climada_ED_plot_per_point.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_MI_plot">
<H2>climada_MI_plot</H2></A>
<font color="blue">function climada_MI_plot(EDS, percentage_of_value_flag,currency,unit_exp,logscale_check,schematic_check) </font>
 visualize Annual Expected Damage per centroid as a map
 NAME:
   climada_MI_plot
 PURPOSE:
   plot annual expected measure impact
 CALLING SEQUENCE:
   climada_MI_plot(EDS, percentage_of_value_flag)
 EXAMPLE:
   climada_MI_plot(EDS, percentage_of_value_flag)
 INPUTS:
   EDS output from climada_measures_impact_report (which has field
   .MI_at_centroid)
 OPTIONAL INPUT PARAMETERS:
   percentage_of_value_flag: Set to 1 if you wish to plot damages as
                             percentage of asset values
 OUTPUTS:
   figure
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150625 init
 Gilles Stassen, gillesstassen@hotmail.com, 20150628 - schematic_check added
 Lea Mueller, muellele@gmail.com, 20150706, add switch for UTM instead of lat/lon coordinates, inhibit limiting latitude values to -60 and +80
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/climada_MI_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measures_impact_advanced">
<H2>climada_measures_impact_advanced</H2></A>
<font color="blue">function measures_impact=climada_measures_impact_advanced(entity,hazard,measures_impact_reference,measures,map_risk_premium,sanity_check) </font>
 special measures impact function for Barisal
 MODULE:
   barisal_demo
 NAME:
   climada_measures_impact_advanced
 PURPOSE:
   special measures impact function for barisal, that includes hazard
   modification files (i.e. absolute or percentage reduction of flood
   depths and duration)
   see climada_measures_impact for more information
 CALLING SEQUENCE:
   measures_impact = climada_measures_impact_advanced(entity,hazard,measures_impact_reference,measures,map_risk_premium,sanity_check)
 EXAMPLE:
   measures_impact = climada_measures_impact_advanced % all prompted for
   hazard_set_file='...\climada\data\hazards\TCNA_A_Probabilistic.mat';
   measures_impact=climada_measures_impact(climada_entity_read('',hazard_set_file),hazard_set_file,'no')
   measures_impact=climada_measures_impact('','','','',1) % all interactive, show risk premium map
 INPUTS:
   entity: a read and encoded assets and damagefunctions file, see climada_assets_encode(climada_assets_read)
       &ampgt promted for if not given
   hazard: either a hazard set (struct) or a hazard set file (.mat with a struct)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   measures_impact: a structure with
       EDS(measure_i): the event damage set for each measure, last one EDS(end) for no measures
       ED(measure_i): the annual expected damage to the assets under measure_i,
           last one ED(end) for no measures
       benefit(measure_i): the benefit of measure_i
       cb_ratio(measure_i): the cost/benefit ratio of measure_i
       measures: just a copy of measures, so we have all we need together
       title_str: a meaningful title, of the format: measures @ assets | hazard
       NOTE: currently measures_impact is also stored (with a lengthy filename)
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150611, created from
               original climada_measures_impact; added functionality for
               hazard_event_set_operator &amp measures_distributed
 Gilles Stassen, gillesstassen@hotmail.com, 20150616, entity switch added
 Lea Mueller, muellele@gmail.com, 20150902, rename to hazard_intensity_impact_b from hazard_intensity_impact
 Lea Mueller, muellele@gmail.com, 20151116, add regional scope, add documentation
 Lea Mueller, muellele@gmail.com, 20151127, add measures_impact.scenario
 Lea Mueller, muellele@gmail.com, 20151202, invoke climada_measures_impact_discount
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/climada_measures_impact_advanced.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_waterfall_graph_multi_peril">
<H2>climada_waterfall_graph_multi_peril</H2></A>
<font color="blue">function  fig = climada_waterfall_graph_multi_peril(check_printplot,currency,varargin) </font>
 waterfall figure, expected damage for specified return period for
 - today,
 - increase from economic growth,
 - increase from high climate change, total expected damage 2030
 for multiple hazard types (flood, cyclone, etc). Hardwired for Barisal,
 see event_selection, which lists the index of today's damage for
 different hazard types.
 NAME:
   climada_waterfall_graph_barisal_combined
 PURPOSE:
   plot waterfall graph based on annual expected damage for different hazard types
 CALLING SEQUENCE:
   fig = climada_waterfall_graph_barisal_combined(EDS, check_printplot)
 EXAMPLE:
   climada_waterfall_graph_barisal_combined
 INPUTS:
   none
 OPTIONAL INPUT PARAMETERS:
   EDS: multiple event damage sets that contain scenarios on today,
   economic growth, climate change for a future time horizon, for
   different hazard types. The vector event_selection points to today's
   damage fordifferent hazard types.
 OUTPUTS:
   waterfall graph
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150610, init
 Lea Mueller, muellele@gmail.com, 20150917, add special colours for Barisal
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/barisal_demo/code/climada_waterfall_graph_multi_peril.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="GeoDistance">
<H2>GeoDistance</H2></A>
<font color="blue">function d=GeoDistance(xx,yy,Lon,Lat) </font>
   % HAVERSINE FORMULA FOR DISTANCES; 
   % distance in lon lat 
   R = 6378.135; % earth radius in km 
   Dlat  = (yy - Lat).*pi/180;
   Dlong = (xx - Lon).*pi/180;
   a = (sin(Dlat./2)).^2 + cos(Lat.*pi/180).*cos(yy.*pi/180).*(sin(Dlong./2)).^2;
   c = 2.*atan2( sqrt(a), sqrt((1-a)) );
   d = R.*c;  % distance in km 
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/GeoDistance.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="TEST_sea_level_components_MEX">
<H2>TEST_sea_level_components_MEX</H2></A>
 first run startup.m from climada and then startup_coastal.m
 
 invoke climada 
 % % disp('loading climada') 
 % % run([dir_climada,filesep,'startup.m'])
 % % 
 % % % invoke climada coastal 
 % % disp('loading climada - coastal modules ') 
 % % run([dir_climada_coastal,filesep,'startup_coastal.m'])
 
lobal climada_global
% 
 SIMULATION OF SEA LEVEL COMPONENTS: 
       TIDES, HISTORICAL SEA LEVEL, SEA LEVEL RISE 

% LOAD COORDINATES 
oad([climada_global.data_coastal_dir,filesep,'test_coastal_hazards_centroids.mat'])
% SEA LEVEL RISE 
 sea level rise projections for Representative Concentration Pathways 
 Values correspond to mean value of projection (central estimate), and total sea level rise.
 Values correspond to SLR for &quot2081-2100 20-yr mean minus 1986-2005 20-yr mean&quot
 Units: &quotm&quot
LRprojections  = climada_get_SLRProjection(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude); % Values correspond to SLR for &quot2081-2100 20-yr mean minus 1986-2005 20-yr mean&quot, in meters (m)
ea_levels.SLRprojections=SLRprojections; 
igure, scatter(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude,50,SLRprojections.RCP45.SLR_m,'fill'), colorbar 
% SUBSIDENCE 
ubsidence      = climada_get_LandSubsidence(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude);  % change in sea level between 1986-2005 and 2081-2100, in meters (m)
ea_levels.subsidence=subsidence; 
igure, scatter(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude,50,subsidence.subs,'fill'), colorbar 
% HISTORICAL SEA LEVEL 
LRhistorical   = climada_get_SLRhistorical(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude);
ea_levels.SLRhistorical=SLRhistorical; 
eries = SLRhistorical.SLR(1,:); 
output]=climada_calculate_LTtrend(SLRhistorical.Time,series)
p=numel(coastal_hazard_centroids.Longitude);
 plot historical sea level rise and trend 
i = 1 
eries = SLRhistorical.SLR(ii,:); 
trend]=climada_calculate_LTtrend(SLRhistorical.Time,series)
igure ('visible','on','position',[680 617 643 361]) 
lot(SLRhistorical.Time, SLRhistorical.SLR(ii,:),'-k'), hold on 
lot(SLRhistorical.Time, output(SLRhistorical.Time),'r','linewidth',2)
rid on, box on, 
atetick('x',10)
itle(['Sea Level Rise'])
label('Mean Sea Level (mm)')
label('Time') 
ave_fig(gcf,[climada_global.root_coastal_dir,filesep,'test_AT.png'],'100') 
% TIDES 
 tide time series for 1 point 
i = 1 
   
0=coastal_hazard_centroids.Longitude(ii); 
0=coastal_hazard_centroids.Latitude(ii); 
   
ide=climada_getTemporalSerie_AT(y0,x0,datenum(2000,1,1),datenum(2016,1,1),'TPXO7.2');  % extract tide time series for one single point 
   
igure('visible','off'), subplot(2,1,1), plot(tide.time,tide.tide,'k'), tlabel, axis tight, ylabel('tide level (m)'), xlabel('time (h)')
ubplot(2,1,2), plot(tide.time(end-2e3:end),tide.tide(end-2e3:end),'k'), axis tight, tlabel,ylabel('tide level (m)')
ave_fig(gcf,[climada_global.root_coastal_dir,filesep,'test_slr.png'],100,[680   595   691   383]) 
   
ea_levels.onetide = tide; 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/TEST_sea_level_components_MEX.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="TEST_surge_module_MEX">
<H2>TEST_surge_module_MEX</H2></A>
lose all; warning off all 
 MODIFICATION HISTORY:
 Borja G. Reguero,borjagreguero@gmail.com,20160322, creation 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/TEST_surge_module_MEX.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="TEST_surge_module_MEX_WithStationarySims">
<H2>TEST_surge_module_MEX_WithStationarySims</H2></A>
lear all, close all; warning off all 
 MODIFICATION HISTORY:
 Borja G. Reguero,borjagreguero@gmail.com,20160322, creation 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/TEST_surge_module_MEX_WithStationarySims.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="TEST_wave_climate_MEX">
<H2>TEST_wave_climate_MEX</H2></A>
 first run startup.m from climada and then startup_coastal.m
 
 invoke climada 
 % % disp('loading climada') 
 % % run([dir_climada,filesep,'startup.m'])
 % % 
 % % % invoke climada coastal 
 % % disp('loading climada - coastal modules ') 
 % % run([dir_climada_coastal,filesep,'startup_coastal.m'])
 
lobal climada_global
% 
 SIMULATION OF SEA LEVEL COMPONENTS: 
       TIDES, HISTORICAL SEA LEVEL, SEA LEVEL RISE 

% LOAD COORDINATES 
oad([climada_global.data_coastal_dir,filesep,'test_coastal_hazards_centroids.mat'])
% GET WAVE CLIMATE PROPERTIES 
 
 sea level rise projections for Representative Concentration Pathways 
 Values correspond to mean value of projection (central estimate), and total sea level rise.
 Values correspond to SLR for &quot2081-2100 20-yr mean minus 1986-2005 20-yr mean&quot
 Units: &quotm&quot
orrect_by_coast = 1; 
output]=climada_get_GlobalWaveClimate(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude, correct_by_coast)
oast = load (climada_global.map_border_file); 
oast.lon = [coast.shapes(:).X]; 
oast.lat = [coast.shapes(:).Y]; 
oxcoord=[min(coastal_hazard_centroids.Longitude(:)) max(coastal_hazard_centroids.Longitude(:)),...
   min(coastal_hazard_centroids.Latitude(:)) max(coastal_hazard_centroids.Latitude(:))]; 
igure, 
ubplot(1,2,1) 
old on, axis tight, axis equal, grid on, axis(boxcoord)
lot(coast.lon,coast.lat,'k','linewidth',2)
catter(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude,30,output.Hsq95,'fill'), colorbar, title('95% sign. wave height (m)') 

ubplot(1,2,2) 
old on, axis tight, axis equal, grid on, axis(boxcoord)
lot(coast.lon,coast.lat,'k','linewidth',2)
catter(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude,30,output.WavePowerMean,'fill'), colorbar, title('Mean Wave Power (kw/m)') 
eturn 
% CREATE MULTIVARIATE PLOT USING CAMUS ET AL 2011 AND REGUERO ET AL 2013 
 requires: SOM toolbox &amp kmeans algorithm 
 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/TEST_wave_climate_MEX.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="aux_historical_storms_MEX">
<H2>aux_historical_storms_MEX</H2></A>
<font color="blue">function tc_track=aux_historical_storms_MEX </font>
 
lobal climada_global
% 
nisys_file         = fullfile(climada_global.data_dir,'tc_tracks','tracks.atl.txt'); 
% read and simulate tropical storms 
heck_plot = 1; 
c_track=climada_tc_read_unisys_database(unisys_file,check_plot);
% add categories of storms 
c_track = climada_tc_season (tc_track) % add the season year 
c_track = climada_tc_stormcategory (tc_track) % clasify by cathegories 
% LANDFALL CORRECTION - 2016 version 
% wind speed decay at track nodes after landfall:
~,p_rel] = climada_tc_track_wind_decay_calculate(tc_track,1);
 add the inland decay correction to all probabilistic nodes:
c_track = climada_tc_track_wind_decay(tc_track, p_rel,1);
% 
 Recalculate nodetime_mat
or track_i = 1:length(tc_track)
   tc_track(track_i).nodetime_mat = datenum(tc_track(track_i).yyyy,...
       tc_track(track_i).mm,...
       tc_track(track_i).dd,...
       tc_track(track_i).hh, 0,0);
nd
 Recalculate timestep
or track_i = 1:length(tc_track)
   timestep = diff(tc_track(track_i).nodetime_mat)*24;
   timestep(end+1) = timestep(end);
   tc_track(track_i).TimeStep = timestep;
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/aux_historical_storms_MEX.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="class_plot_profiles">
<H2>class_plot_profiles</H2></A>
lassdef class_plot_profiles
   properties % values
       transect 
       FigHandle
       dd
   end % properties
   
   methods
<font color="blue">        function obj = class_plot_profiles(transect,dd) % Constructor </font>
       % class constructor 
           if nargin&ampgt0 
               obj.transect=transect; 
           end
           obj.FigHandle = figure('position',[680   167   650   811]);
           obj.dd=dd; 
           %%%%
       end % function constructor
       
<font color="blue">        function plotPosition(obj) </font>
           set(obj.FigHandle) 
           subplot (2,1,1) 
           hold on 
           load coast 
           plot(long,lat,'-k')
           plot([obj.transect.p1(1);obj.transect.p0(1);obj.transect.p2(1)],[obj.transect.p1(2);obj.transect.p0(2);obj.transect.p2(2)],'or'), 
           hold on, plot(obj.transect.x,obj.transect.y,'-b')
           axis equal, grid on 
           
             dd = 7; 
           axis([min(obj.transect.x(:))-obj.dd,max(obj.transect.x(:))+obj.dd,min(obj.transect.y(:))-obj.dd,max(obj.transect.y(:))+obj.dd])
       end
       
<font color="blue">        function plotProfile(obj) </font>
           set(obj.FigHandle) 
           subplot (2,1,2) 
           hold on 
           xaxis = class_plot_profiles.GeoDistance(obj.transect.x,obj.transect.y,obj.transect.x(1),obj.transect.y(1)); 
           yaxis = obj.transect.h; 
           
           hold on, plot(xaxis,yaxis,'.-k')
           plot([xaxis(1) xaxis(end)],[0 0],'r') 
           axis tight, grid on
           xlabel ('Distance (km)') 
           ylabel('Depth (m)') 
           
           if max(obj.transect.h)&amplt0
               set(gca,'ylim',[min(obj.transect.h),10]) 
           end
       end
       
   end
   methods (Static = true) 
       
<font color="blue">        function d=GeoDistance(xx,yy,Lon,Lat) </font>
           % HAVERSINE FORMULA FOR DISTANCES; 
           % distance in lon lat 
           R = 6378.135; % earth radius in km 
           Dlat  = (yy - Lat).*pi/180;
           Dlong = (xx - Lon).*pi/180;
           a = (sin(Dlat./2)).^2 + cos(Lat.*pi/180).*cos(yy.*pi/180).*(sin(Dlong./2)).^2;
           c = 2.*atan2( sqrt(a), sqrt((1-a)) );
           d = R.*c;  % distance in km 
       end
<font color="blue">        function [lon2,lat2]=DestinationCoor(lon1,lat1,azimut,distancekm)  </font>
           R = 6378.135; % earth radius in km 
           deg=180/pi; 
           lat2 = asin( sind(lat1)*cos(distancekm/R) + cosd(lat1)*sin(distancekm/R)*cosd(azimut) ) *deg; 
           lon2 = lon1 + atan2(sind(azimut)*sin(distancekm/R)*cosd(lat1),cos(distancekm/R)-sind(lat1)*sind(lat2))*deg;  
       end
   end
   
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/class_plot_profiles.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_calculate_ACE">
<H2>climada_calculate_ACE</H2></A>
<font color="blue">function [ACE]= climada_calculate_ACE(tc_track, name_tag, check_printplot) </font>
 ---------------------------------------------
% ACCUMULATED CYCLONE ENERGY ACE
 % The ACE of a season is calculated by 
 % summing the squares of the estimated maximum sustained velocity of
 % - every active tropical storm (wind speed 35 knots (65 km/h) or higher),
 % - at six-hour intervals. 
 ---------------------------------------------

 plot histograms of Accumulated Cyclone Energy ACE, No. of storms per
 seasons, No. of hurricanes and No. of major hurricanes per season of
 probabilistic tracks, with historical tracks indicated with dotted black
 lines
 NAME:
   climada_plot_ACE
 PURPOSE:
   given a probabilistic tc_track structure, histograms of ACE, No. storms,
   hurricanes and major hurricanes per season and compare with historical
   histograms (black dotted lines), check distributions
   ACE of a season is calculated by summing the squares of the estimated 
   maximum sustained velocity of
   - every active tropical storm (wind speed 35 knots (65 km/h) or higher),
   - at six-hour intervals. 
 
   previous step:  generation of probabilistic tracks, 
   tc_track_prob = climada_tc_random_walk_position_windspeed;
   next step:      
 CALLING SEQUENCE:
   climada_plot_ACE(tc_track, name_tag, check_printplot)
 EXAMPLE:
   climada_plot_ACE(tc_track_prob, '4480', 1)
 INPUTS:
   tc_track: probabilistic tc track set (random walk of wind speed, 
   longitude and latitude), wind speed in knots, nodes every six hours
 OPTIONAL INPUT PARAMETERS:
   name_tag:        string that will be used for name of printed pdf
   check_printplot: if set to 1 will print (save) figure
 OUTPUTS:
   figure, printout of figure if requested
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110621
 davids.bresch@gmail.com, 20120407
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_calculate_ACE.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_calculate_LTtrend">
<H2>climada_calculate_LTtrend</H2></A>
<font color="blue">function [cf_lineal]=climada_calculate_LTtrend(Time,series,varargin) </font>
 climada
 MODULE:
   climada_coastal 
 NAME:
   climada_get_SLRhistorical
 PURPOSE:
   get Sea Level Rise historical time series at points 
 CALLING SEQUENCE:
   climada_get_SLRhistorical(X,Y);
 EXAMPLE:
   climada_get_SLRhistorical(param1,param2);
 INPUTS:
   Xp,Yp: 
       coordinates where to extract SLR 
 OPTIONAL INPUT PARAMETERS:
 
 OUTPUTS:
 
 MODIFICATION HISTORY:
 	Borja G. Reguero - borjagreguero@gmail.com - 02262016
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_calculate_LTtrend.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_compare_windfields">
<H2>climada_compare_windfields</H2></A>
<font color="blue">function res  = climada_compare_windfields(tc_track, centroids, ... </font>
   equal_timestep, silent_mode, check_plot,unit_)
 generate hazard surge set from 1 tc_track 
 NAME:
   climada_tc_hazard_surge_CENAPRED
 PURPOSE:
   generate tropical cyclone hazard surge set from the CENAPRED formula
   originally for MEXICO coastline 
   calls climada_tc_surgefield which calculates the surge footprint for
   one single TC track
   previous: likely climada_random_walk &amp climada_tc_windfield 
   next: diverse, see manual, since this code generates the tropical
   cyclone surge hazard event set, to be used by climada_EDS_calc etc.
 CALLING SEQUENCE:
   hazard = climada_tc_hazard_surge_CENAPRED(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   hazard = climada_tc_hazard_surge_CENAPRED(tc_track)
 INPUTS:
   region: area of study [x-left x-right y-bottom y-right]
 OPTIONAL INPUT PARAMETERS:
   tc_track: a tc_track structure (see climada_tc_read_unisys_database),
       or a filename of a saved one
       details: see e.g. climada_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file to be created, in
       which all the storm surge footrpints will be stored (in essence a
       sparse matrix with storm surge heit for each event at each centroid)
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes   
           Latitude(1,:): the latitudes   
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       if you select Cancel, a regular default grid is used, see
       hard-wired definition in code (sometimes useful for TEST purposesI
   checkplot: if =1, draw graphics 

 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
           tropical cyclone or 'TS' for tropical cycloes surge... only needed
           later for sanity tests, such that e.g. hazards are not messed up
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon (info only,
           not used in calculation)
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one (this information comes from
           tc_track
       event_ID: a unique ID for each event. Note that in case you'd like
           to combine later say wind and surge damages, make sure you generate
           exactly the same events with matching IDs, as this allows to sum up
           event damage sets (EDS)
       date: the creation date of the set (info only)
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event (annual event
           occurence frequency)
       matrix_density: the density of the sparse array hazard.arr
       surgefield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful, since some code checks for
           consistency by checking whether this field is the same.
 MODIFICATION HISTORY:
 Borja G. Reguero  borjagreguero@gmail.com, 20160323, created from
 climada_tc_surgefield 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_compare_windfields.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_getTemporalSerie_AT">
<H2>climada_getTemporalSerie_AT</H2></A>
<font color="blue">function data=climada_getTemporalSerie_AT(lat,lon,dateIni,dateEnd,varargin) </font>
 climada
 MODULE:
   climada_coastal 
 NAME:
   climada_getTemporalSerie_AT
 PURPOSE:
   get time series of astronomic tides at points - global 
 CALLING SEQUENCE:
   climada_getTemporalSerie_AT(lat,lon,dateIni,dateEnd)
 EXAMPLE:
   climada_getTemporalSerie_AT(y0,x0,datenum(1990,1,1),datenum(2016,1,1),'TPXO7.2')
 
 INPUTS:
   -lat: Latitude of the geopoint
   -lon: Longitude of the geopoint    
   -dateIni: Initial date (julian days)
   -dateEnd: End date (julian days)

 OPTIONAL INPUT PARAMETERS:
   version of the tpxo database 7.1 or 7.2 
 
RETURNS:
   -data: Structure with the following fields
       * time: time positions of the series (julian days).
       * lat:  Latitude of the nearest node to the geopoint
       * lon:  Longitude of the nearest node  to the geopoint
       * tide: Astronomical Tide (m)  
 
 MODIFICATION HISTORY:
 	Borja G. Reguero - borjagreguero@gmail.com - 02262016
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_getTemporalSerie_AT.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_get_GlobalWaveClimate">
<H2>climada_get_GlobalWaveClimate</H2></A>
<font color="blue">function [output]=climada_get_GlobalWaveClimate(Xp,Yp, varargin) </font>
 climada
 MODULE:
   climada_coastal 
 NAME:
   climada_get_GlobalWaveClimate
 PURPOSE:
   get global wave data statistics from Reguero et al (2012)
 CALLING SEQUENCE:
   climada_get_GlobalWaveClimate(X,Y);
 EXAMPLE:
   climada_get_GlobalWaveClimate(param1,param2);
 INPUTS:
   Xp,Yp: 
       coordinates where to extract SLR 
 OPTIONAL INPUT PARAMETERS:
 
 OUTPUTS:
 
 MODIFICATION HISTORY:
 	Borja G. Reguero - borjagreguero@gmail.com - Mar/04/2016
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_get_GlobalWaveClimate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_get_LandSubsidence">
<H2>climada_get_LandSubsidence</H2></A>
<font color="blue">function output=climada_get_LandSubsidence(Xp,Yp) </font>
 climada
 MODULE:
   climada_coastal 
 NAME:
   climada_get_SLRProjection
 PURPOSE:
   get subsidence at points 
 CALLING SEQUENCE:
   climada_get_SLRProjection(X,Y);
 EXAMPLE:
   climada_get_SLRProjection(param1,param2);
 INPUTS:
   Xp,Yp: 
       coordinates where to extract SLR 
 OPTIONAL INPUT PARAMETERS:
   rcps: lis of rcps to extract. Default: rcps ={'RCP26','RCP45','RCP60','RCP85'}
 NOTE: 2.6 for _l is all nans in original file 
 
 Glacial Isostatic Adjustment (GIA) correction for land uplift/subidence.
 GIA_ICE5G change in sea level between 1986-2005 and 2081-2100, in meters (m)
 
 CITE: Chapter 13 paper:\
 Church, J. A., P. Clark, A. Cazenave, J. Gregory, S. Jevrejeva, A. Levermann, M. Merrifield, G. Milne, R.S.Nerem, P. Nunn, A. Payne, W. Pfeffer, D. Stammer, and A. Unnikrishnan (2013), Sea level change, in Climate Change 2013: The Physical Science Basis, edited by T. F. Stocker, D. Qin, G.-K. Plattner, M. Tignor, S. Allen, J. Boschung, A. Nauels, Y. Xia, V. Bex, and P. Midgley, Cambridge University Press, Cambridge, UK and New York, NY. USA.\
 
 Peltier, W. R. (2004), Global glacial isostasy and the surface of the Ice-Age
 Earth: The ICE-5G (VM2) Model and GRACE, Annu. Rev. Earth
 Planet. Sci., 32, 111149, doi:10.1146/annurev.earth.32.082503.144359
 
 OUTPUTS:
 MODIFICATION HISTORY:
 	Borja G. Reguero - borjagreguero@gmail.com - 02262016
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_get_LandSubsidence.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_get_SLRProjection">
<H2>climada_get_SLRProjection</H2></A>
<font color="blue">function output=climada_get_SLRProjection(Xp,Yp) </font>
 climada
 MODULE:
   climada_coastal 
 NAME:
   climada_get_SLRProjection
 PURPOSE:
   get Sea Level Rise projections at points 
 CALLING SEQUENCE:
   climada_get_SLRProjection(X,Y);
 EXAMPLE:
   climada_get_SLRProjection(param1,param2);
 INPUTS:
   Xp,Yp: 
       coordinates where to extract SLR 
 OPTIONAL INPUT PARAMETERS:
   rcps: lis of rcps to extract. Default: rcps ={'RCP26','RCP45','RCP60','RCP85'}
 NOTE: 2.6 for _l is all nans in original file 

 sea level rise projections for Representative Concentration Pathways 
 Values correspond to mean value of projection (central estimate), and total sea level rise.
 Values correspond to SLR for &quot2081-2100 20-yr mean minus 1986-2005 20-yr mean&quot
 Units: &quotm&quot

 OUTPUTS:
 MODIFICATION HISTORY:
 	Borja G. Reguero - borjagreguero@gmail.com - 02262016
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_get_SLRProjection.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_get_SLRhistorical">
<H2>climada_get_SLRhistorical</H2></A>
<font color="blue">function [output]=climada_get_SLRhistorical(Xp,Yp) </font>
 climada
 MODULE:
   climada_coastal 
 NAME:
   climada_get_SLRhistorical
 PURPOSE:
   get Sea Level Rise historical time series at points 
 CALLING SEQUENCE:
   climada_get_SLRhistorical(X,Y);
 EXAMPLE:
   climada_get_SLRhistorical(param1,param2);
 INPUTS:
   Xp,Yp: 
       coordinates where to extract SLR 
 OPTIONAL INPUT PARAMETERS:
 
 OUTPUTS:
 
 MODIFICATION HISTORY:
 	Borja G. Reguero - borjagreguero@gmail.com - 02262016
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_get_SLRhistorical.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_init_vars_coastal">
<H2>climada_init_vars_coastal</H2></A>
<font color="blue">function ok=climada_init_vars_coastal(reset_flag) </font>
 init variables global
 NAME:
	climada_init_vars_coastal
 PURPOSE:
	initialize path and filenames for coastal hazard module 

 CALLING SEQUENCE:
	ok=climada_init_vars_coastal(reset_flag)
 EXAMPLE:
	ok=climada_init_vars_coastal;
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   reset_flag: if set to 1, forced re-init
 OUTPUTS:
	ok: =1 if no troubles, 0 else
 MODIFICATION HISTORY:
 Borja G. Reguero  - modified from original climada_init_vars.m 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_init_vars_coastal.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_ACE_set">
<H2>climada_tc_ACE_set</H2></A>
<font color="blue">function hazard = climada_tc_ACE_set(tc_track, hazard_set_file, centroids) </font>
 climada TC hazard event set generate
 NAME:
   climada_tc_hazard_set
 PURPOSE:
   generate a tc (tropical cyclone) hazard event set

   If centroids.distance2coast_km exists, the hazard intensity is only
   calculated in the coastal_range_km (usually 200km, see PARAMETERS in
   climada_tc_windfield) - this speeds up calculation for large countries
   considerably.

   Special: the hazard event set is stored every 100 tracks in order to
   allow for interruption of the hazard set generation. Just re-start the
   calculation by calling climada_tc_hazard_set with exactly the same
   input parameters (the last track calculated is stored in hazard.track_i
   and the field track_i is removed in the final complete hazard event set).  

   previous: likely climada_random_walk
   next: diverse
 CALLING SEQUENCE:
   res=climada_tc_hazard_set(tc_track,hazard_set_file)
 EXAMPLE:
   res=climada_tc_hazard_set(tc_track)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_tc_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name and path of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes
           Latitude(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       OR: an entity, in which case the entity.assets.lat and
       Longitude are used as centroids.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090729
 David N. Bresch, david.bresch@gmail.com, 20130506, centroids filename handling improved
 David N. Bresch, david.bresch@gmail.com, 20140421, waitbar with secs
 David N. Bresch, david.bresch@gmail.com, 20141226, optional fields in centroids added
 David N. Bresch, david.bresch@gmail.com, 20150103, equal_timestep (much) improved
 Borja G. Reguero, borjagreguero@gmail.com, 20160322, created for
 calculting ACE after modifying climada_tc_hazard_set
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_ACE_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_surge">
<H2>climada_tc_hazard_surge</H2></A>
<font color="blue">function hazard  = climada_tc_hazard_surge(tc_track,hazard_set_file,centroids,... </font>
   wave_models, surge_models, silent_mode,check_plot)
 climada_tc_hazard_surge(boundingbox,bathy,rSLR,tc_track,hazard_set_file,centroids,transects,  ...
                                             dirout, silent_mode, check_plot,storm_vec,keyout_storms)
 generate hazard surge and wave set from tc_tracks for tropical cyclones 
 NAME:
   climada_tc_hazard_surge
 PURPOSE:
   generate tropical cyclone hazard surge set
   calls climada_tc_surgefield which calculates the surge footprint for
   one single TC track
   previous: likely climada_random_walk
   next: diverse, see manual, since this code generates the tropical
   cyclone surge hazard event set, to be used by climada_EDS_calc etc.
 CALLING SEQUENCE:
   hazard = climada_tc_hazard_surge(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   hazard = climada_tc_hazard_surge(tc_track)
 INPUTS:
   type_hazards: [0/1 0/1] = binary for [waves surge]
 OPTIONAL INPUT PARAMETERS:
   tc_track: a tc_track structure (see climada_tc_read_unisys_database),
       or a filename of a saved one
       details: see e.g. climada_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file to be created, in
       which all the storm surge footrpints will be stored (in essence a
       sparse matrix with storm surge heit for each event at each centroid)
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes   
           Latitude(1,:): the latitudes   
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       if you select Cancel, a regular default grid is used, see
       hard-wired definition in code (sometimes useful for TEST purposesI
   checkplot: if =1, draw graphics 

 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
           tropical cyclone or 'TS' for tropical cycloes surge... only needed
           later for sanity tests, such that e.g. hazards are not messed up
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon (info only,
           not used in calculation)
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one (this information comes from
           tc_track
       event_ID: a unique ID for each event. Note that in case you'd like
           to combine later say wind and surge damages, make sure you generate
           exactly the same events with matching IDs, as this allows to sum up
           event damage sets (EDS)
       date: the creation date of the set (info only)
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event (annual event
           occurence frequency)
       matrix_density: the density of the sparse array hazard.arr
       surgefield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful, since some code checks for
           consistency by checking whether this field is the same.
 MODIFICATION HISTORY:
 David Bresch,     david.bresch@gmail.com,  20130719, initial setup for surge
 Borja G. Reguero  borjagreguero@gmail.com, 20130816, wave field and SS 
 Borja G. Reguero  borjagreguero@gmail.com, 20160328, MAJOR MOD. adaptated 
 for new version of module and more models for surge. 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_hazard_surge.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_surge_CENAPRED">
<H2>climada_tc_hazard_surge_CENAPRED</H2></A>
<font color="blue">function res  = climada_tc_hazard_surge_CENAPRED(tc_track, centroids, ... </font>
   equal_timestep, silent_mode, check_plot,unit_)
 generate hazard surge set from 1 tc_track 
 NAME:
   climada_tc_hazard_surge_CENAPRED
 PURPOSE:
   generate tropical cyclone hazard surge set from the CENAPRED formula
   originally for MEXICO coastline 
   calls climada_tc_surgefield which calculates the surge footprint for
   one single TC track
   previous: likely climada_random_walk &amp climada_tc_windfield 
   next: diverse, see manual, since this code generates the tropical
   cyclone surge hazard event set, to be used by climada_EDS_calc etc.
 CALLING SEQUENCE:
   hazard = climada_tc_hazard_surge_CENAPRED(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   hazard = climada_tc_hazard_surge_CENAPRED(tc_track)
 INPUTS:
   region: area of study [x-left x-right y-bottom y-right]
 OPTIONAL INPUT PARAMETERS:
   tc_track: a tc_track structure (see climada_tc_read_unisys_database),
       or a filename of a saved one
       details: see e.g. climada_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file to be created, in
       which all the storm surge footrpints will be stored (in essence a
       sparse matrix with storm surge heit for each event at each centroid)
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes   
           Latitude(1,:): the latitudes   
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       if you select Cancel, a regular default grid is used, see
       hard-wired definition in code (sometimes useful for TEST purposesI
   checkplot: if =1, draw graphics 

 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
           tropical cyclone or 'TS' for tropical cycloes surge... only needed
           later for sanity tests, such that e.g. hazards are not messed up
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon (info only,
           not used in calculation)
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one (this information comes from
           tc_track
       event_ID: a unique ID for each event. Note that in case you'd like
           to combine later say wind and surge damages, make sure you generate
           exactly the same events with matching IDs, as this allows to sum up
           event damage sets (EDS)
       date: the creation date of the set (info only)
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event (annual event
           occurence frequency)
       matrix_density: the density of the sparse array hazard.arr
       surgefield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful, since some code checks for
           consistency by checking whether this field is the same.
 MODIFICATION HISTORY:
 Borja G. Reguero  borjagreguero@gmail.com, 20160323, created from
 climada_tc_surgefield 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_hazard_surge_CENAPRED.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_surge_CENAPRED_field">
<H2>climada_tc_hazard_surge_CENAPRED_field</H2></A>
<font color="blue">function res  = climada_tc_hazard_surge_CENAPRED(tc_track, centroids, ... </font>
   equal_timestep, silent_mode, check_plot)
 generate hazard surge set from 1 tc_track 
 NAME:
   climada_tc_hazard_surge_CENAPRED
 PURPOSE:
   generate tropical cyclone hazard surge set from the CENAPRED formula
   originally for MEXICO coastline 
   calls climada_tc_surgefield which calculates the surge footprint for
   one single TC track
   previous: likely climada_random_walk &amp climada_tc_windfield 
   next: diverse, see manual, since this code generates the tropical
   cyclone surge hazard event set, to be used by climada_EDS_calc etc.
 CALLING SEQUENCE:
   hazard = climada_tc_hazard_surge_CENAPRED(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   hazard = climada_tc_hazard_surge_CENAPRED(tc_track)
 INPUTS:
   tc_track - cyclone track to calculate 
   centroids - centroids with lon lat coordinates and ID 
 
 OPTIONAL INPUT PARAMETERS:
   tc_track: a tc_track structure (see climada_tc_read_unisys_database),
       or a filename of a saved one
       details: see e.g. climada_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file to be created, in
       which all the storm surge footrpints will be stored (in essence a
       sparse matrix with storm surge heit for each event at each centroid)
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes   
           Latitude(1,:): the latitudes   
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       if you select Cancel, a regular default grid is used, see
       hard-wired definition in code (sometimes useful for TEST purposesI
   checkplot: if =1, draw graphics 

 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
           tropical cyclone or 'TS' for tropical cycloes surge... only needed
           later for sanity tests, such that e.g. hazards are not messed up
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon (info only,
           not used in calculation)
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one (this information comes from
           tc_track
       event_ID: a unique ID for each event. Note that in case you'd like
           to combine later say wind and surge damages, make sure you generate
           exactly the same events with matching IDs, as this allows to sum up
           event damage sets (EDS)
       date: the creation date of the set (info only)
       surge(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event (annual event
           occurence frequency)
       matrix_density: the density of the sparse array hazard.surge
       surgefield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful, since some code checks for
           consistency by checking whether this field is the same.
 MODIFICATION HISTORY:
 Borja G. Reguero  borjagreguero@gmail.com, 20160323, created from
 climada_tc_surgefield 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_hazard_surge_CENAPRED_field.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_surge_DD92_mslope">
<H2>climada_tc_hazard_surge_DD92_mslope</H2></A>
<font color="blue">function res  = climada_tc_hazard_surge_DD92_mslope(tc_track, centroids, ... </font>
   silent_mode, check_plot)
 generate hazard surge set from 1 tc_track 
 NAME:
   climada_tc_hazard_surge_DD92_mslope
 PURPOSE:
   generate tropical cyclone hazard surge set from the CENAPRED formula
   originally for MEXICO coastline 
   calls climada_tc_surgefield which calculates the surge footprint for
   one single TC track
   previous: likely climada_random_walk &amp climada_tc_windfield 
   next: diverse, see manual, since this code generates the tropical
   cyclone surge hazard event set, to be used by climada_EDS_calc etc.
 CALLING SEQUENCE:
   hazard = climada_tc_hazard_surge_DD92_mslope(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   hazard = climada_tc_hazard_surge_DD92_mslope(tc_track)
 INPUTS:
   tc_track: a tc_track structure (see climada_tc_read_unisys_database),
       or a filename of a saved one
       details: see e.g. climada_random_walk
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           lon(1,:): the longitudes   
           lat(1,:): the latitudes   
           ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
   
 OPTIONAL INPUT PARAMETERS:
   silent_mode: activate to check code and add additional plots 
   check_plot: additional plots / if =1, draw graphics 

 OUTPUTS:
   res: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
           tropical cyclone or 'TS' for tropical cycloes surge... only needed
           later for sanity tests, such that e.g. hazards are not messed up
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon (info only,
           not used in calculation)
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one (this information comes from
           tc_track
       event_ID: a unique ID for each event. Note that in case you'd like
           to combine later say wind and surge damages, make sure you generate
           exactly the same events with matching IDs, as this allows to sum up
           event damage sets (EDS)
       date: the creation date of the set (info only)
       surge(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event (annual event
           occurence frequency)
       matrix_density: the density of the sparse array hazard.surge
       surgefield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful, since some code checks for
           consistency by checking whether this field is the same.
 MODIFICATION HISTORY:
 Borja G. Reguero  borjagreguero@gmail.com, 20160323, created from
 climada_tc_surgefield 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_hazard_surge_DD92_mslope.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_surge_SLOSH">
<H2>climada_tc_hazard_surge_SLOSH</H2></A>
<font color="blue">function res=climada_tc_hazard_surge_SLOSH(tc_track,centroids,equal_timestep,silent_mode,check_plot) </font>
 climada storm surge TS hazard event set
 NAME:
   climada_tc_hazard_surge_SLOSH
 PURPOSE:
   create a storm surge (TS) hazard event, based on an existing
   tropical cyclone (TC) hazard event set from Liming Xu, 2010 / SLOSH
   SIMULATIONS IN THE US 

 TC windfield calculation and calculate Surge from SLOSH regression 
 NAME:
   climada_tc_hazard_surge_SLOSH
 PURPOSE:
   given a TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the wind field at locations (=centroids) and Surges 

   If centroids.distance2coast_km exists, the hazard intensity is only
   calculated in the coastal_range_km (usually 300km, see PARAMETERS) -
   this speeds up calculation for large countries considerably. To switch
   this feature off, just centroids=rmfield(centroids,'distance2coast_km')
   prior to passing centroids to climada_tc_windfield

   mainly called from: see climada_tc_hazard_set
 CALLING SEQUENCE:
   climada_tc_hazard_surge_SLOSH(tc_track,centroids,equal_timestep,silent_mode)
 EXAMPLE:
   climada_tc_hazard_surge_SLOSH
   plot windfield:
   climada_tc_hazard_surge_SLOSH(tc_track(1411), centroids,1,1,1)
 INPUTS:
   tc_track: a structure with the track information:
       tc_track.lat
       tc_track.lon
       tc_track.MaxSustainedWind: maximum sustained wind speed (one-minute)
       tc_track.MaxSustainedWindUnit as 'kn', 'mph', 'm/s' or 'km/h'
       tc_track.CentralPressure: optional
       tc_track.Celerity: translational (forward speed) of the hurricane.
           optional, calculated from lat/lon if missing
       tc_track.TimeStep: optional, only needed if Celerity needs to be
           calculated, 6h assumed as default
       tc_track.Azimuth: the forward moving angle, calculated if not given
           to ensure consistency, it is even suggested not to pass Azimuth
       tc_track.yyyy: 4-digit year, optional
       tc_track.mm: month, optional
       tc_track.dd: day, optional
       tc_track.ID_no: unique ID, optional
       tc_track.name: name, optional
       tc_track.SaffSimp: Saffir-Simpson intensity, optional
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
       If centroids.distance2coast_km exists, the hazard intensity is only
       calculated in the coastal_range_km (usually 300km, see PARAMETERS) -
       this speeds up calculation for large countries considerably. To switch
       this feature off, just centroids=rmfield(centroids,'distance2coast_km')
       prior to passing centroids to climada_tc_windfield.
       Some other fields of centroids are also appended to res struct
 OPTIONAL INPUT PARAMETERS:
   equal_timestep: if set=1 (default), first interpolate the track to a common
       timestep, if set=0, no equalization of TC track data (not recommended)
       BUT: for speedup, run climada_tc_equal_timestep for ALL tracks
       prior to calling climada_tc_windfield (see e.g. climada_tc_hazard_set) 
       and then set equal_timestep=0 in calling climada_tc_windfield 
   silent_mode: if =1, do not write to stdout unless severe warning
   check_plot: disabled, see code, commented out for speedup
 OUTPUTS:
   res: the output strcuture, with fields
       gust(i): the windfield [m/s] at all centroids i
       lat(i): the latitude of the centroids i
       lon(i): the longitude of the centroids i
       Some other fields of centroids are also appended to res struct
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Borja G. Reguero  borjagreguero@gmail.com, 20160404, created from
 windfield original climada code 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_hazard_surge_SLOSH.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_surgefield_barotropic">
<H2>climada_tc_surgefield_barotropic</H2></A>
<font color="blue">function [res centroids] = climada_tc_surgefield_barotropic(tc_track, centroids, ... </font>
   equal_timestep, silent_mode, check_plot,unit_)
 TC surge field for pressure component 
 NAME:
   climada_tc_surgefield_barotropic
 PURPOSE:
   given a TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the surge field (footprint) at locations (=centroids)
   mainly called from: see climada_tc_hazard_surge

   DEVELOPERS NOTE:
   edit the code especially where indicated by INSERT/EDIT CODE HERE
 CALLING SEQUENCE:
   climada_tc_surgefield_barotropic(tc_track,centroids,equal_timestep,silent_mode,check_plot)
 EXAMPLE:
   res =
   climada_tc_surgefield_barotropic(tc_track(track_i),centroids) % one track
 INPUTS:
   tc_track: a structure with the track information:
       tc_track.lat
       tc_track.lon
       tc_track.MaxSustainedWind: maximum sustained wind speed (one-minute)
       tc_track.MaxSustainedWindUnit as 'kn', 'mph', 'm/s' or 'km/h'
       tc_track.CentralPressure: optional
       tc_track.Celerity: translational (forward speed) of the hurricane.
           optional, calculated from lat/lon if missing
       tc_track.TimeStep: optional, only needed if Celerity needs to be
           calculated, 6h assumed as default
       tc_track.Azimuth: the forward moving angle, calculated if not given
           to ensure consistency, it is even suggested not to pass Azimuth
       tc_track.yyyy: 4-digit year, optional
       tc_track.mm: month, optional
       tc_track.dd: day, optional
       tc_track.ID_no: unique ID, optional
       tc_track.name: name, optional
       tc_track.SaffSimp: Saffir-Simpson intensity, optional
   centroids: a structure with the centroids information
       centroids.Latitude: the latitude of the centroids
       centroids.Longitude: the longitude of the centroids
       centroids.transects: bathymetry profiles where to calculate the SS
       / see SS code or documentation for further information / 
   bathy: a structure with x, y , h(depth) / 3 matrices 
   res:   a structure to store the results 
 OPTIONAL INPUT PARAMETERS:
   equal_timestep: if set=1 (default), first interpolate the track to a common
       timestep, if set=0, no equalization of TC track data (not recommended)
   silent_mode: if =1, do not write to stdout unless severe warning
   checkplot: if =1, draw graphics 
   unit_: units of the SS: ['mm','cm','m'], default: 'mm'
 OUTPUTS:
   res.arr: the surge height [mm per storm] at all centroids
   res.lat: the latitude of the centroids
   res.lon: the longitude of the centroids
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Borja G. Reguero, borjagreguero@gmail.com, 20160328, created 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_surgefield_barotropic.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_tracks_clim_scen">
<H2>climada_tc_tracks_clim_scen</H2></A>
<font color="blue">function tc_track_out=climada_tc_tracks_clim_scen(tc_track,screw,comment,check_plot) </font>
 TC event set for future storms 
 NAME:
   climada_tc_tracks_clim_scen
 PURPOSE:
   given a tc_track structure, create future storm tracks derived tracks based on
   storms previously generated 

   NOTE see PARAMETER section to change parameters
   (e.g. ens_amp0,ens_amp,Maxangle)

   previous step: see climada_tc_random_walk
   next step: see climada_tc_hazard_set
 CALLING SEQUENCE:
   tc_track=climada_tc_random_walk(tc_track,ens_size);
 EXAMPLE:
   tc_track=climada_read_unisys_database;
   tc_track=climada_tc_random_walk(tc_track);
   tc_track=climada_tc_tracks_clim_scen(tc_track);

 INPUTS:
   tc_track: a structure with the track information for each cyclone i at
       each node j, see climada_read_unisys_database for a detailed
       description
   screw: 
 OPTIONAL INPUT PARAMETERS:
   ens_size: create ens_size varied derived tracks, default 9 
       (means for each original track, 9 daughter tracks are generated)
   ens_amp: amplitude of random walk wiggles in degree longitude for
       'directed', default 0.35. Be careful when changing, test with one track and plot, e.g.
       climada_tc_random_walk(tc_track(1),9,ens_amp,[],1)
   Maxangle: the angle the track direction can change for one timestep
       default=pi/7. Be careful when changing, test with one track and plot, e.g.
       climada_tc_random_walk(tc_track(1),9,[],Maxangle,1)
   check_plot: whether we show a check plot (=1) or not (=0), default=0
 OUTPUTS:
   same structure now including the ens_size times number of tracks
   all the info from the original tracks is copied, only the lat, lon
   differs
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Borja G. Reguero  borjagreguero@gmail.com, 20160321 
 init global variables
lobal climada_global
f ~climada_init_vars,return;end
 check inputs
f ~exist('tc_track'  , 'var'), tc_track   = []; end
f ~exist('check_plot', 'var'), check_plot = []; end
f ~exist('screw','var'),
   screw.intensity_factor  = [0.11 0.11 0.11 0.11 0.11 0.11];   % percentage
   screw.frequency_screw   = [-0.28 -0.28 -0.28 -0.28 0.8 0.8]; % percentage
   screw.time_horizon      = [2100]
   screw.target_year       = [climada_global.future_reference_year]
   screw.cat               = [0 1 2 3 4 5];
nd
f ~exist('comment'  , 'var'), comment   = ['climate change scenario based on previous storms'];end
 prompt for tc_track if not given
f isempty(tc_track)
   tc_track             = [climada_global.data_dir filesep 'tc_tracks' filesep '*.mat'];
   tc_track_default     = [climada_global.data_dir filesep 'tc_tracks' filesep 'Select HISTORICAL tc track .mat'];
   [filename, pathname] = uigetfile(tc_track, 'Select HISTORICAL tc track:',tc_track_default);
   if isequal(filename,0) || isequal(pathname,0)
       return; % cancel
   else
       tc_track = fullfile(pathname,filename);
   end
nd
% check wind speed record in knots
or track_i = 1:length(tc_track)
   if strcmp(tc_track(track_i).MaxSustainedWindUnit,'kn') ~= 1
       fprintf('Wind not recorded in kn, conversion to kn needed')
       return
   end
nd
% apply factors for future storms 
 categories of storms 
 v_categories = [34 64 83 96 113 135 1000]; %Saffir-Simpson Scale in kn
  
   hurricane scale
   -1 tropical depression
    0 tropical storm
    1 Hurrican category 1
    2 Hurrican category 2
    3 Hurrican category 3
    4 Hurrican category 4
    5 Hurrican category 5
 
ypes_categories =[-1 0:5 ]; 
_categories = [0 83 96 113 137]; %(unit kn)
       cats   &amplt83 C1 / &ampgt=83 C2 / &ampgt=96 C3 / &ampgt=113 C4 / &ampgt=137 C5
_categories2 = [34 64 83 96 113 135 1000];
int  = ones(1,numel(tc_track)).*nan; 
freq = ones(1,numel(tc_track)).*nan; 
c_track_out = tc_track; 
or st=1:numel(tc_track) 
   disp(num2str(st))
   v     = max(tc_track(st).MaxSustainedWind);
   if 1-isnan(v) 
       if strcmp(tc_track(st).MaxSustainedWindUnit,'kn') 
           v_cat = find (v &ampgt= v_categories); 
           v_cat=v_cat(end); 
           fint(st)  = 1 + (screw.intensity_factor(v_cat)) .* (screw.target_year-climada_global.present_reference_year)./(screw.time_horizon - climada_global.present_reference_year) ; 
           ffreq(st) = 1 + (screw.frequency_screw (v_cat)) .* (screw.target_year-climada_global.present_reference_year)./(screw.time_horizon - climada_global.present_reference_year) ; 
           tc_track_out(st).MaxSustainedWind = tc_track(st). MaxSustainedWind .* fint(st) ;
           tc_track_out(st).fint=fint(st);
           tc_track_out(st).ffreq=ffreq(st);
       else 
           error ('Units wind speed wrong') 
       end
   end
   season_storm(st) = tc_track(st).season;
   cat_storms  (st) = tc_track(st).category;
   max_wind    (st)    = max(tc_track(st).MaxSustainedWind);
   max_wind_out(st)    = max(tc_track_out(st).MaxSustainedWind);
   
   v_cat    = find (max_wind_out(st)  &amplt v_categories2)-2;
   tc_track_out(st).category_new = v_cat(1);
   
   tc_track_out(st).comment_clim_scen       = comment;
   tc_track_out(st).target_year             = screw.target_year;
   tc_track_out(st).date                    = datestr(now);
nd
eason_storm = [tc_track(:).season];
easons      = unique(season_storm); 
eason_count = length(seasons);
easons_plot = seasons;
easons_plot(seasons_plot&ampgt2012) = seasons_plot(seasons_plot&ampgt2012) - 17768;
% save 
 save(hazard_clim_file,'tc_track_out')
 fprintf('\n***Climate change scenario *** \n  intensity screw = %10.2f \n  frequency_screw = %10.2f \nsaved in \n%s \n\n', intensity_screw, frequency_screw,[climada_global.data_dir hazard_clim_file])
% 
ypes_=zeros(numel(tc_track),numel(types_categories)); 
ypes_new=zeros(numel(tc_track),numel(types_categories)); 
or st=1:numel(tc_track_out) 
   ind = find(types_categories==tc_track_out(st).category_new);  
   types_(st,ind) = 1; 
   ind = find(types_categories==tc_track_out(st).category); 
   types_new(st,ind) = 1; 
nd    
ypes_=nansum(types_,1)./numel(tc_track_out).*100; 
ypes_new=nansum(types_new,1)./numel(tc_track_out).*100; 
% check_plot
f check_plot
   fprintf('preparing check plot ...\n');
   figure, 
   subplot(2,1,1)
   [count_, bin_] = hist(max_wind,[0:20:300]);
   h = plot([0 bin_], [0 count_/sum(count_)],'-k'); hold on
   [count_, bin_] = hist(max_wind_out,[0:20:300]);
   h2 = plot([0 bin_], [0 count_/sum(count_)],'-r'); hold on
   xlabel('Wind (kn)')
   ylabel(['Relative count in ' int2str(season_count) ' seasons'])
   
   subplot(2,1,2)   
   bar([types_categories],[types_],.7,'r')
   hold on 
   bar([types_categories],[types_new],.5),colormap('gray') 
   legend('Present','Future')
   xlabel('Storm category')
   ylabel('% of storms')
   set(gca,'ylim',[0 50]) 
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_tracks_clim_scen.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_wavefield">
<H2>climada_tc_wavefield</H2></A>
<font color="blue">function [res tc_track_ori centroids] = climada_tc_wavefield(tc_track, centroids, .... </font>
   bathy, models_waves,equal_timestep, silent_mode, check_plot,unit_,dirout)
 TC wave field calculation
 NAME:
   climada_tc_wavefield
 PURPOSE:
   given a TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the wave field (footprint) at locations (=centroids)
   mainly called from: see climada_tc_hazard_surge
   This code only resolves 1 storm! Loop over at the upper level. 

   DEVELOPERS NOTE:
   edit the code especially where indicated by INSERT/EDIT CODE HERE
 CALLING SEQUENCE:
   climada_tc_wavefield(tc_track,centroids,equal_timestep,silent_mode,check_plot)
 EXAMPLE:
   res =
   climada_tc_wavefield(tc_track(track_i),centroids) % one track
 INPUTS:
   tc_track: a structure with the track information:
       tc_track.lat
       tc_track.lon
       tc_track.MaxSustainedWind: maximum sustained wind speed (one-minute)
       tc_track.MaxSustainedWindUnit as 'kn', 'mph', 'm/s' or 'km/h'
       tc_track.CentralPressure: optional
       tc_track.Celerity: translational (forward speed) of the hurricane.
           optional, calculated from lat/lon if missing
       tc_track.TimeStep: optional, only needed if Celerity needs to be
           calculated, 6h assumed as default
       tc_track.Azimuth: the forward moving angle, calculated if not given
           to ensure consistency, it is even suggested not to pass Azimuth
       tc_track.yyyy: 4-digit year, optional
       tc_track.mm: month, optional
       tc_track.dd: day, optional
       tc_track.ID_no: unique ID, optional
       tc_track.name: name, optional
       tc_track.SaffSimp: Saffir-Simpson intensity, optional
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
       centroids.transects: bathymetry profiles where to calculate the SS
       / see SS code or documentation for further information / 
   bathy: a structure with x, y , h(depth) / 3 matrices 
   res:   a structure to store the results 
 OPTIONAL INPUT PARAMETERS:
   equal_timestep: if set=1 (default), first interpolate the track to a common
       timestep, if set=0, no equalization of TC track data (not recommended)
   silent_mode: if =1, do not write to stdout unless severe warning
   checkplot: if =1, draw graphics 
   unit_: units of the SS: ['mm','cm','m'], default: 'mm'
   model_waves = flags 1/0 for [ Bretschneider (1990) / Young / SPM REVISED]
 OUTPUTS:
   res.waves: the wave heights [mm per storm] at all centroids
   res.lat: the latitude of the centroids
   res.lon: the longitude of the centroids
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David Bresch, david.bresch@gmail.com, 20130719, initial setup for surge
 Borja G. Reguero, borjagreguero@gmail.com, 20130814, minor mods on setup
 Borja G. Reguero, borjagreguero@gmail.com, 20160329, for new module and
 major refinement 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_wavefield.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield_ACE">
<H2>climada_tc_windfield_ACE</H2></A>
<font color="blue">function res=climada_tc_windfield_ACE(tc_track,centroids,equal_timestep,silent_mode,check_plot) </font>
 TC windfield calculation
 NAME:
   climada_tc_windfield
 PURPOSE:
   given a TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the wind field at locations (=centroids)

   If centroids.distance2coast_km exists, the hazard intensity is only
   calculated in the coastal_range_km (usually 300km, see PARAMETERS) -
   this speeds up calculation for large countries considerably. To switch
   this feature off, just centroids=rmfield(centroids,'distance2coast_km')
   prior to passing centroids to climada_tc_windfield

   mainly called from: see climada_tc_hazard_set
 CALLING SEQUENCE:
   climada_tc_windfield(tc_track,centroids,equal_timestep,silent_mode)
 EXAMPLE:
   climada_tc_windfield
   plot windfield:
   climada_tc_windfield(tc_track(1411), centroids,1,1,1)
 INPUTS:
   tc_track: a structure with the track information:
       tc_track.lat
       tc_track.lon
       tc_track.MaxSustainedWind: maximum sustained wind speed (one-minute)
       tc_track.MaxSustainedWindUnit as 'kn', 'mph', 'm/s' or 'km/h'
       tc_track.CentralPressure: optional
       tc_track.Celerity: translational (forward speed) of the hurricane.
           optional, calculated from lat/lon if missing
       tc_track.TimeStep: optional, only needed if Celerity needs to be
           calculated, 6h assumed as default
       tc_track.Azimuth: the forward moving angle, calculated if not given
           to ensure consistency, it is even suggested not to pass Azimuth
       tc_track.yyyy: 4-digit year, optional
       tc_track.mm: month, optional
       tc_track.dd: day, optional
       tc_track.ID_no: unique ID, optional
       tc_track.name: name, optional
       tc_track.SaffSimp: Saffir-Simpson intensity, optional
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
       If centroids.distance2coast_km exists, the hazard intensity is only
       calculated in the coastal_range_km (usually 300km, see PARAMETERS) -
       this speeds up calculation for large countries considerably. To switch
       this feature off, just centroids=rmfield(centroids,'distance2coast_km')
       prior to passing centroids to climada_tc_windfield.
       Some other fields of centroids are also appended to res struct
 OPTIONAL INPUT PARAMETERS:
   equal_timestep: if set=1 (default), first interpolate the track to a common
       timestep, if set=0, no equalization of TC track data (not recommended)
       BUT: for speedup, run climada_tc_equal_timestep for ALL tracks
       prior to calling climada_tc_windfield (see e.g. climada_tc_hazard_set) 
       and then set equal_timestep=0 in calling climada_tc_windfield 
   silent_mode: if =1, do not write to stdout unless severe warning
   check_plot: disabled, see code, commented out for speedup
 OUTPUTS:
   res: the output strcuture, with fields
       gust(i): the windfield [m/s] at all centroids i
       lat(i): the latitude of the centroids i
       lon(i): the longitude of the centroids i
       Some other fields of centroids are also appended to res struct
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 David N. Bresch, david.bresch@gmail.com, 20141227, centroids.distance2coast_km treatment added
 David N. Bresch, david.bresch@gmail.com, 20150124, wind_threshold=15 (was 0), coastal_range_km=375 (was 300)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_windfield_ACE.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield_HURAC">
<H2>climada_tc_windfield_HURAC</H2></A>
<font color="blue">function wind  = climada_tc_windfield_HURAC(tc_track,track_node_i, LL) </font>
 generates windfield in a grid 
 NAME:
   climada_tc_windfield_HURAC
 PURPOSE:
 generates windfield in a grid, just for 1 position --&ampgt only generates 1
 unique wind field 
 based on Hydromet-Rankin Vortex de Holland (1980) &amp Bretschneider (1990) 
 following Ruiz-Martinez (2009) with minor modifications 
 CALLING SEQUENCE:
   wind = climada_tc_windfield_HURAC(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   wind = climada_tc_windfield_HURAC(tc_track)
 INPUTS:
 tc_track: a tc_track structure (see climada_tc_read_unisys_database),
       or a filename of a saved one
       details: see e.g. climada_random_walk
 track_node_i = position of track to simulate 
 OPTIONAL INPUT PARAMETERS:
   LL: grid size is 2*LLx2*LL 
 
 OUTPUTS:
   wind: wind speed and coordinates in a grid 
 
 MODIFICATION HISTORY:
 Borja G. Reguero  borjagreguero@gmail.com, 20160330, created for being
 called from surge and wave fields scripts 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/climada_tc_windfield_HURAC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="create_bathymetry">
<H2>create_bathymetry</H2></A>
<font color="blue">function [bathy]=create_bathymetry(coords,bathy_source,check_plot) </font>

 coords = : An array defining the corner points of the grid       
|                    coord(1) = Longitude (x) of lower left hand corner  
|                    coord(2) = Longitude (x) of upper right hand corner  
|                    coord(3) = Latitude (y) of lower left hand corner  
|                    coord(2) = Latitude (x) of upper right hand corner  
 dir_data = folder with the bathy_source 
 bathy_source= file root to 'etopo2' or 'etopo1' / FULL DIRECTORY 

 MODIFICATION HISTORY:
 Borja G. Reguero borjagreguero@gmail.com  20160222 created for coastal
 module 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/create_bathymetry.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="deg2utm">
<H2>deg2utm</H2></A>
<font color="blue">function  [x,y,utmzone] = deg2utm(Lat,Lon) </font>
 -------------------------------------------------------------------------
 [x,y,utmzone] = deg2utm(Lat,Lon)

 Description: Function to convert lat/lon vectors into UTM coordinates (WGS84).
 Some code has been extracted from UTM.m function by Gabriel Ruiz Martinez.

 Inputs:
    Lat: Latitude vector.   Degrees.  +ddd.ddddd  WGS84
    Lon: Longitude vector.  Degrees.  +ddd.ddddd  WGS84

 Outputs:
    x, y , utmzone.   See example

 Example 1:
    Lat=[40.3154333; 46.283900; 37.577833; 28.645650; 38.855550; 25.061783];
    Lon=[-3.4857166; 7.8012333; -119.95525; -17.759533; -94.7990166; 121.640266];
    [x,y,utmzone] = deg2utm(Lat,Lon);
    fprintf('%7.0f ',x)
       458731  407653  239027  230253  343898  362850
    fprintf('%7.0f ',y)
      4462881 5126290 4163083 3171843 4302285 2772478
    utmzone =
       30 T
       32 T
       11 S
       28 R
       15 S
       51 R

 Example 2: If you have Lat/Lon coordinates in Degrees, Minutes and Seconds
    LatDMS=[40 18 55.56; 46 17 2.04];
    LonDMS=[-3 29  8.58;  7 48 4.44];
    Lat=dms2deg(mat2dms(LatDMS)); %convert into degrees
    Lon=dms2deg(mat2dms(LonDMS)); %convert into degrees
    [x,y,utmzone] = deg2utm(Lat,Lon)

 Author: 
   Rafael Palacios
   Universidad Pontificia Comillas
   Madrid, Spain
 Version: Apr/06, Jun/06, Aug/06, Aug/06
 Aug/06: fixed a problem (found by Rodolphe Dewarrat) related to southern 
    hemisphere coordinates. 
 Aug/06: corrected m-Lint warnings
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/deg2utm.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="disk_kernel">
<H2>disk_kernel</H2></A>
<font color="blue">function kernel=disk_kernel(p2)  </font>
    rad   = p2;
    crad  = ceil(rad-0.5);
    [x,y] = meshgrid(-crad:crad,-crad:crad);
    maxxy = max(abs(x),abs(y));
    minxy = min(abs(x),abs(y));
    m1 = (rad^2 &amplt  (maxxy+0.5).^2 + (minxy-0.5).^2).*(minxy-0.5) + ...
         (rad^2 &ampgt= (maxxy+0.5).^2 + (minxy-0.5).^2).* ...
        sqrt(rad^2 - (maxxy + 0.5).^2);
    m2 = (rad^2 &ampgt  (maxxy-0.5).^2 + (minxy+0.5).^2).*(minxy+0.5) + ...
         (rad^2 &amplt= (maxxy-0.5).^2 + (minxy+0.5).^2).* ...
          sqrt(rad^2 - (maxxy - 0.5).^2);
    sgrid = (rad^2*(0.5*(asin(m2/rad) - asin(m1/rad)) + ...
            0.25*(sin(2*asin(m2/rad)) - sin(2*asin(m1/rad)))) - ...
            (maxxy-0.5).*(m2-m1) + (m1-minxy+0.5)) ... 
          .*((((rad^2 &amplt (maxxy+0.5).^2 + (minxy+0.5).^2) &amp ...
            (rad^2 &ampgt (maxxy-0.5).^2 + (minxy-0.5).^2)) | ...
          ((minxy==0)&amp(maxxy-0.5 &amplt rad)&amp(maxxy+0.5&ampgt=rad))));
    sgrid = sgrid + ((maxxy+0.5).^2 + (minxy+0.5).^2 &amplt rad^2);
    sgrid(crad+1,crad+1) = min(pi*rad^2,pi/2);
    if ((crad&ampgt0) &amp&amp (rad &ampgt crad-0.5) &amp&amp (rad^2 &amplt (crad-0.5)^2+0.25)) 
       m1  = sqrt(rad^2 - (crad - 0.5).^2);
     m1n = m1/rad;
       sg0 = 2*(rad^2*(0.5*asin(m1n) + 0.25*sin(2*asin(m1n)))-m1*(crad-0.5));
       sgrid(2*crad+1,crad+1) = sg0;
       sgrid(crad+1,2*crad+1) = sg0;
       sgrid(crad+1,1)        = sg0;
       sgrid(1,crad+1)        = sg0;
       sgrid(2*crad,crad+1)   = sgrid(2*crad,crad+1) - sg0;
       sgrid(crad+1,2*crad)   = sgrid(crad+1,2*crad) - sg0;
       sgrid(crad+1,2)        = sgrid(crad+1,2)      - sg0;
       sgrid(2,crad+1)        = sgrid(2,crad+1)      - sg0;
    end
    sgrid(crad+1,crad+1) = min(sgrid(crad+1,crad+1),1);
    kernel = sgrid/sum(sgrid(:));
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/disk_kernel.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="filter2">
<H2>filter2</H2></A>
 ## Copyright (C) 2001 Paul Kienzle
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 ## Y = filter2 (B, X)
 ##	Apply the 2-D FIR filter B to the matrix X.
 ## Y = filter2 (B, X, 'shape')
 ##      Apply the 2-D FIR filter B to the matrix X, returning the
 ##      desired shape:
 ##          full  - pad X with zeros on all sides before filtering
 ##          same  - unpadded X (default)
 ##          valid - trim X after filtering so edge effects are no included
 ##
 ## Note this is just a variation on convolution, with the parameters
 ## reversed and B rotated 180 degrees.
 
 ## Author: Paul Kienzle &ampltpkienzle@kienzle.powernet.co.uk&ampgt
 ## 2001-02-08 
 ##    * initial release
<font color="blue">function Y = filter2 (B, X, shape) </font>
   if (nargin &amplt 2 || nargin &ampgt 3)
     usage (['Y = filter2 (B, X [, 'shape'])]);
   end
 if nargin &amplt 3
   shape = 'same';
 end
 [nr, nc] = size(B);
 Y = conv2 (X, B(nr:-1:1, nc:-1:1), shape);
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/filter2.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="fun_SurgeHeightFun">
<H2>fun_SurgeHeightFun</H2></A>
<font color="blue">function [surgeheight]=fun_SurgeHeightFun(h0,u10,m,check_plot) </font>
  
 Code to estimate storm surge by using one dimensional sureg model       %
 The storm surge model explained in the book titled:                     %
 &quotwater wave mechanics for engineers and scientists&quot                     %
 by Dean Dalrymple method 1992                                           %
 Ver 1                                                                   %
                                                     by: Arash Karimpour %
                                                   www.arashkarimpour.com%
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++%
INPUT---------------------------------------------------------------------
 Modeling the storm surge using Dean Dalrymple method 1992
 
 h0=40;               % deep water depth in (m), It was 42 m for Katrina
 u10=40;              % wind velocity 10 meter above the ground in (m/s), It was 40 m/s for Katrina 
 m=0.00084;           % bed slope = h0/l; 
 
OUTPUT--------------------------------------------------------------------
 surgeheight         : Surge Height in (m)
 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/fun_SurgeHeightFun.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="fun_calculate_mean_slope">
<H2>fun_calculate_mean_slope</H2></A>
<font color="blue">function mslope = fun_calculate_mean_slope(centroids, check_plot)  </font>
 requires field &quotprofiles&quot in centroids
 interpolates bathymetry at centroids lon and lat coordinates and
 calculates mean slope for surge formulation 
 bathy - struct with bathymetry info 
   .x .y .z 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/fun_calculate_mean_slope.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="fun_clean_track">
<H2>fun_clean_track</H2></A>
<font color="blue">function tc_track_clean = fun_clean_track(onetrack,ind) </font>
c_track_clean = onetrack; 
c_track_clean.TimeStep = tc_track_clean.TimeStep(ind); 
c_track_clean.lon = tc_track_clean.lon(ind); 
c_track_clean.lat = tc_track_clean.lat(ind); 
c_track_clean.MaxSustainedWind = tc_track_clean.MaxSustainedWind(ind); 
c_track_clean.CentralPressure = tc_track_clean.CentralPressure(ind); 
c_track_clean.yyyy = tc_track_clean.yyyy(ind); 
c_track_clean.mm = tc_track_clean.mm(ind); 
c_track_clean.dd = tc_track_clean.dd(ind); 
c_track_clean.hh = tc_track_clean.hh(ind); 
c_track_clean.datenum = tc_track_clean.datenum(ind); 
c_track_clean.nodetime_mat = tc_track_clean.nodetime_mat(ind); 
c_track_clean.onLand = tc_track_clean.onLand(ind); 
eturn 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/fun_clean_track.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="fun_writeshp_contour_lines">
<H2>fun_writeshp_contour_lines</H2></A>
<font color="blue">function [S] = fun_writeshp_contour_lines(C,nameout)  </font>
 = getcontourlines(C);
or ii = 1: numel(s) 
   
   xmin= min(s(ii).x(:)); xmax = max(s(ii).x(:)); 
   ymin= min(s(ii).y(:)); ymax = max(s(ii).y(:)); 
   
   S(ii).Geometry= 'Line';
   S(ii).BoundingBox = [xmin ymin ; xmax ymax ]; 
   S(ii).Lon=s(ii).x(:); 
   S(ii).Lat=s(ii).y(:); 
   S(ii).contour = s(ii).v; 
   S(ii).Name=num2str(ii); 
nd
 write structure to shapefile 
hapewrite(S,[nameout,'.shp'])
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/fun_writeshp_contour_lines.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="getcontourlines">
<H2>getcontourlines</H2></A>
<font color="blue">function s = getcontourlines(c) </font>
   sz = size(c,2);     % Size of the contour matrix c
   ii = 1;             % Index to keep track of current location
   jj = 1;             % Counter to keep track of % of contour lines
   while ii &amplt sz       % While we haven't exhausted the array
       n = c(2,ii);    % How many points in this contour?
       s(jj).v = c(1,ii);        % Value of the contour
       s(jj).x = c(1,ii+1:ii+n); % X coordinates
       s(jj).y = c(2,ii+1:ii+n); % Y coordinates
       ii = ii + n + 1;          % Skip ahead to next contour line
       jj = jj + 1;              % Increment number of contours
   end
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/getcontourlines.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="harmonics">
<H2>harmonics</H2></A>
Magic numbers for TPXO (Name, Solar Doodson Numbers, Ref. Phase, Speed degrees/hour)
PXOharmonics={ 'MM'     '0'   '1'   '0'  '-1'   '0'   '0'    '0'    '0.5443747'
                          'MF'     '0'   '2'   '0'   '0'   '0'   '0'    '0'    '1.0980331'
                          'Q1'     '1'  '-3'   '1'   '1'  '0'   '0'  '270'   '13.3986607'
                          'O1'     '1'  '-2'   '1'   '0'   '0'   '0'  '270'   '13.9430351'
                          'P1'     '1'   '0'  '-1'   '0'   '0'   '0'  '270'   '14.9589310'
                          'K1'     '1'   '0'   '1'   '0'   '0'   '0'   '90'   '15.0410690'
                          'N2'     '2'  '-3'   '2'   '1'   '0'   '0'    '0'   '28.4397297'
                          'M2'     '2'  '-2'   '2'   '0'   '0'   '0'    '0'   '28.9841042'
                          'S2'     '2'   '0'   '0'  '0'   '0'   '0'    '0'   '30.0000000'
                          'K2'     '2'   '0'   '2'   '0'   '0'   '0'    '0'   '30.0821381'
                          'MN4'     '4'  '-5'   '4'   '1'   '0'   '0'    '0'   '57.4238319'
                          'M4'     '4'  '-4'   '4'   '0'   '0'   '0'    '0'   '57.9682083'
                          'MS4'     '4'  '-2'   '2'   '0'   '0'   '0'    '0'   '58.9841042'};
PXOnames={'M2' 'S2' 'N2' 'K2' 'K1' 'O1' 'P1' 'Q1' 'MF' 'MM' 'M4' 'MS4' 'MN4'};
PXOperiods=[   28.9841042; 30.; 28.4397297; 30.0821381; 15.0410690; 13.9430351; 14.9589310; 13.3986607; 
               1.0980331; 0.5443747; ...
               57.9682083; 57.9682083 ; 57.4238319]; 
 TPXOnames={'M2' 'S2' 'N2' 'K2' 'K1' 'O1' 'P1' 'Q1' 'MF' 'MM' 'M4' 'MS4' 'MN4'};
 % % namesConst_roms={'MM' 'MF' 'Q1' 'O1' 'P1' 'K1' 'N2' 'M2' 'S2' 'K2' 'MN4' 'M4' 'MS4'};  %to use all
 % % TPXOperiods_roms=[0.5443747 1.0980331 13.3986607 13.9430351 14.9589310 15.0410690 28.4397297 28.9841042 30.0 30.0821381 57.4238319 57.9682083 58.9841042]
Magic numbers 
eriods=360./TPXOperiods(:);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/harmonics.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="pol2cart">
<H2>pol2cart</H2></A>
<font color="blue">function [x,y,z] = pol2cart(th,r,z) </font>
POL2CART Transform polar to Cartesian coordinates.
   [X,Y] = POL2CART(TH,R) transforms corresponding elements of data
   stored in polar coordinates (angle TH, radius R) to Cartesian
   coordinates X,Y.  The arrays TH and R must the same size (or
   either can be scalar).  TH must be in radians.

   [X,Y,Z] = POL2CART(TH,R,Z) transforms corresponding elements of
   data stored in cylindrical coordinates (angle TH, radius R, height
   Z) to Cartesian coordinates X,Y,Z. The arrays TH, R, and Z must be
   the same size (or any of them can be scalar).  TH must be in radians.

   Class support for inputs TH,R,Z:
      float: double, single

   See also CART2SPH, CART2POL, SPH2CART.
   L. Shure, 4-20-92.
   Copyright 1984-2004 The MathWorks, Inc. 
   $Revision: 5.9.4.2 $  $Date: 2004/07/05 17:02:08 $
 = r.*cos(th);
 = r.*sin(th);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/pol2cart.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="save_fig">
<H2>save_fig</H2></A>
<font color="blue">function save_fig(handle,file,res, varargin) </font>
   if 1 - isempty(varargin)
       set(gcf,'position',varargin{1}) 
   end
   set(handle,'PaperPositionMode','auto')
   print(handle,'-dpng',[file],['-r',num2str(res)]); 
   close(handle) 
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/save_fig.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="tlabel">
<H2>tlabel</H2></A>
<font color="blue">function tlabel(varargin) </font>
TLABEL   Full date formatted tick labels with ZOOM, PAN and LINKAXES.

   SYNTAX:
     tlabel
     tlabel(...,TICKAXIS)
     tlabel(...,DATEFORM)
     tlabel(...,'keeplimits') vs 'freelimits'
     tlabel(...,'keepticks')  vs 'freeticks'
     tlabel(...,PRO,VAL,...)
     tlabel(AX,...)
     tlabel(...);

   INPUT: (all optionals)
     TICKAXIS     - Date axis. One of 'x', 'y' or 'z'.
                    DEFAULT: 'x'
     DATEFORM     - Numerical or string date format to be used on the
                    ticks. See DATESTR for details. 
                    DEFAULT: (as DATETICK, see NOTE below)
     'keeplimits' - Preserves the axis limits or 'freelimits' to not.
                    DEFAULT: (does it if axis limit mode is 'manual')
     'keepticks'  - Preserves the ticks locations or 'freeticks' to not.
                    DEFAULT: (does it if axis tick mode is 'manual')
     PRO,VAL      - Property/value extra inputs.
                    DEFAULT: (see TABLE below for details)  
     AX           - Uses the specified axis, rather than the current axis.
                    Axes are automatically linked if more than one were
                    specified. May include figure handles see NOTE below
                    for details.
                    DEFAULT: gca

   DESCRIPTION:
     This program works as DATETICK but with ZOOM, PAN and LINK
     functionalities.
      
     It's a mayor modification of DATETICKZOOM function by Lauwerys, by
     including the LINK functionality and includes in the date axis Label
     the part of the date that was left out by the TickLabels, allowing
     the user to know the full date no matter the zooming in.

     Besides, it includes some extra functionalities that the user may use
     as usual Property/Value pair inputs, which are:

      PROPERTY        POSSIBLE VALUES            DESCRIPTION
     ---------------------------------------------------------------------
      'Language'      'local' or 'en_us'         Sets months language.
                      DEFAULT: 'local'          

      'LinkOthers'    false, true, or            Links other axes besides
                      the specified ones         time?
                      ('yz' for example)
                      DEFAULT: false

      'WhichAxes'     'all', 'none', 'first',    Specifies on which axes
                      'last', or the             to display the dates.
                      specified axes handles
                      DEFAULT: 'all'

      'FixLow'        An integer or zero.        Indicates if more ticks
                      DEFAULT: 4                 should be included when
                                                 when less than 4 are
                                                 displayed.

      'FixHigh'       An integer or zero.        Indicates if less ticks
                      DEFAULT: 11                should be used when more
                                                 than 11 are displayed.

      'NumFmtNN'      User custom (see NOTE      Change the MATLAB
                      below for details)         default numeric date
                      DEFAULT: by DATETICK       format: 'NN' by the 
                                                 specified one.

      'Reference'     'middle', 'first',         Specifies the date on
                      'last' or 'none'           the time axis to be used
                      DEFAULT: 'middle'          as reference for the
                                                 whole date.

      'LabelY'        DEFAULT: 'yyyy'            Numeric or string format
                                                 on axis label when only
                                                 year is displayed.

      'LabelYM'       DEFAULT: 'mmm yyyy'        Numeric or string format
                                                 on axis label when year
                                                 and month are displayed.

      'LabelYMD'      DEFAULT: 'dd/mmm/yyyy'     Numeric or string format
                                                 on axis label when only
                                                 year is displayed.
     ---------------------------------------------------------------------
    
   NOTE:
     * Optional inputs use its DEFAULT value when not given or [].
     * For example, by default pairwise options: ('NumFmt6','dd/mmm') and
       ('NumFmt17',12) are used. See DATETICK for details on the numeric
       formats.
     * Except from the optional AX input which must be the first one,
       all other inputs arguments may be entered in any other position
       (keeping the pairs always toghether, of course).
     * The string inputs may be as short as posible, except for its value.
       Besides, upper cases are ignored (try 'keepl' instead of
       'KeepLimits').
     * If DATEFORMAT is used, it will be used even after any ZOOM.
     * 'keepticks' and 'keeplimits' are used by default if the TICKAXIS
       ticks and limits mode is 'manual'. So, limits are preserved if
       before TLABEL, axis tight was used.
     * Use 'Reference','none' to avoid the using of the label axis.
     * ADDITIONAL NOTES are included inside this file.

   EXAMPLE:
     tini = datenum([2009 05 29 12 00 00]);
     dt   = 20/60/24;
     N    = 100;
     t    = (0:N-1)'*dt + tini;
     figure(1), clf
      subplot(311)
       plot(t,3*cos(2*pi*t/12*24))
      subplot(312)
       plot(t,5*cos(2*pi*t/6*24))
      subplot(313)
       plot(t,8*cos(2*pi*t/3*24))
      axis(findobj(gcf,'Type','axes'),'tight')
     tlabel(gcf,'keepl','W','last')   % Dates printed only on last plot!
     zoom on

   SEE ALSO:
     DATETICK, DATESTR, DATENUM
     and
     DATETICKZOOM by Christophe Lauwerys and LINKZOOM by Carlos Vargas
     at http://www.mathworks.com/matlabcentral/fileexchange


   ---
   MFILE:   tlabel.m
   VERSION: 2.6 (Sep 07, 2009) (&amplta href=&quotmatlab:web('http://www.mathworks.com/matlabcentral/fileexchange/authors/11258')&quot&ampgtdownload&amplt/a&ampgt) 
   MATLAB:  7.7.0.471 (R2008b)
   AUTHOR:  Carlos Adrian Vargas Aguilera (MEXICO)
   CONTACT: nubeobscura@hotmail.com
   ADDITIONAL NOTES:
     * The extra option 'WhichAxes' is helpful when the user wants to link
       all the subplots in a figure, but with the date displayed only on
       the lower ones, to avoid repetition.
     * The program creates an application data (see SETAPPDATA) on each
       axes called 'tlabeldata' (besides of 'axeslink', 'labelalink' and
       'labelslink' when linking axes) with some stuff used by the program
       after zooming or panning. For example, to retrieve the date format
       used on the current axes after TLABEL was used, do the following:
         &ampgt&ampgt data = getappdata(gca,'tlabeldata');
         &ampgt&ampgt data.TicksFmt
   REVISIONS:
   1.0      Released. (Apr 24, 2008)
   2.0      Rewritten code. Mayor changes with inputs and link axes. No
            more outputs allowed. (Jun 08, 2009) 
   2.1      When 'keepticks' are used, now they are revised by the
            fixTicks subfunction. If the user changes manually the axes
            limits or ticks of the first axes handle, the 'keepticks' and
            'keeplimits' are changed accordingly. (Jun 30, 2009).
   2.1.1    Fixed small BUG with this new 'keep's options thanks to Ayal
            Anis. (Jul 03, 2009)
   2.1.2    Fixed another smaller BUG with this new 'keep's options. (Jul
            14, 2009)
   2.2      Finally fixed BUG with 'keep's options. Fixed bugs with
            temporal figure creation. New 'none' option for 'Reference'.
            Fixed BUG with Double-Click. Changed application data name
            from 'tlabeldata' to 'tlabel'. (Jul 29, 2009)
   2.3      Fixed BUG when using PLOTYY. Fixed BUG with 'WhichAxes' and
            'Reference' parse inputs, besides this latter option now moves
            the label to the selected reference (as observed and suggested
            by Giles Lesser). (Aug 20, 2009)
   2.4      Fixed BUG when displaying years. Fixed BUG with numeric format
            (thanks to Roger Parkyn). Added 'freeticks' and 'freelimits'
            options. (Aug 21, 2009)
   2.5      Fixed BUG with year ticks and not empty label. Fixed BUG with
            a unique DATETICK tick (thanks to Kelly Kearney). (Aug 21,
            2009)
   2.6      Fixed bugs with a unique tick (thanks to Mary-Louise
            Timmermans). (Sep 07, 2009)
   DISCLAIMER:
   tlabel.m is provided &quotas is&quot without warranty of any kind, under the
   revised BSD license.
   Copyright (c) 2008,2009 Carlos Adrian Vargas Aguilera
 -------------------------------------------------------------------------
 MAIN
 -------------------------------------------------------------------------
 Parameters.
yAppName   = 'tlabel';
oomAppName = 'zoom_zoomOrigAxesLimits';
ecPause    = 0.25; % Pauses for this seconds to check double-click
f ~((nargin==2) &amp&amp isstruct(varargin{2}))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TLABEL called from command window or a M-file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sets defaults.
data.AX         = gca;             % Gets axis handle.
data.TICKAXIS   = 'x';             % Sets date axis.
data.DATEFORM   = [];              % Fixed date format.
data.FixLow     = 4;               % Adds ticks if there are &amplt it.
data.FixHigh    = 11;              % Delets ticks if there are &ampgt it.
data.Which      = true;            % Writes Labels on date axis?
data.KeepTicks  = false;           % Keeps original date axis ticks?
data.KeepLimits = false;           % Keeps original ticks?
data.LabelFmt   = [];              % Sets date label format.
data.LabelY     = 'yyyy';          % Sets date format for years.
data.LabelYM    = 'mmm yyyy';      %   ... for years and months.
data.LabelYMD   = 'dd/mmm/yyyy';   %   ... for years, months and days.
data.Language   = 'local';         % Sets laguage for string months.
data.LinkOthers = false;           % Links other axes besides date?
data.NumFmt     = ...
 mat2cell([1:31 0]',ones(1,32),1); % Change the 32 MATLAB date formats?
data.NumFmt{6}  = 'dd/mmm';        %   Note: {32} is format 0. 
data.NumFmt{17} = 12;
data.Reference  = 'middle';        % Sets date label reference.
data.TicksFmt   = [];              % Sets date ticks format.
data.WhichAxes  = 'all';           % Sets where to write the ticks.

% Gets inputs and/or defaults.
data = parseInputs(data,varargin{:});

% Checks the axes to be printed.
data.Which = getWhichAxes(data.Which,data.WhichAxes,data.AX);

% Writes labels and saves application data.
writeLabels(data.AX(1),data,false,myAppName,zoomAppName)

% Links the axes and labels and resets the ZOOM.
linkAxes(data)

% Sets the ZOOM and PAN functionality.
for k = 1:length(data.AX)
 xa = data.AX(k);
 zh = zoom(xa);
 ph = pan(ancestor(xa,{'figure','uipanel'}));
 set(zh,'ActionPostCallback',@tlabel) 
 set(ph,'ActionPostCallback',@tlabel)
end

lse

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TLABEL called after ZOOM or PAN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

try
 
 % Gets input axes handle and check it. Fixed BUG, Aug 2009
 if ~isfield(varargin{2},'Axes'), return, end
 AX = varargin{2}.Axes(1); % In case it is a group.
 if ~ishandle(AX) || ~strcmp(get(AX,'Type'),'axes'), return, end
 if ~isappdata(AX,myAppName), return, end
  
 % Retrieves application data.
 data = getappdata(AX,myAppName);   
 
 % Eliminates closed axes.
 ind = false(1,length(data.AX));
 for k = 1:length(data.AX)
  if ~ishandle(data.AX(k))
   ind(k) = true;
  end
 end
 data.AX(ind)    = [];
 data.Which(ind) = [];
 
 % Check double-click. Fixed BUG, Jul 2009
 pause(secPause)
 drawnow
 doubleClick = strcmp('open',...
                  get(ancestor(AX,{'figure','uipanel'}),'SelectionType'));
 
 % Writes labels and saves application data.
 writeLabels(AX,data,doubleClick,myAppName,zoomAppName);
 
 % Checks if double-click or zoom out on current axes.
 if doubleClick || all(axis(AX)==getappdata(AX,zoomAppName))
  % Zooms out all axes.
  for k = 1:length(data.AX)
   axis(data.AX(k),getappdata(data.AX(k),zoomAppName))
  end
 end
 
catch
 % Do not sets an error during execution, only displays it as a warning.
 warning('CVARGAS:tlabel:errorDuringZoomOrPanExecution',lasterr)
end
nd 
 =========================================================================
 SUBFUNCTIONS
 -------------------------------------------------------------------------
<font color="blue">function writeLabels(AX,data,doubleClick,myAppName,zoomAppName) </font>
 Writes ticks to be used.
 Get axis limits, ticks and number of ticks within.
data,ticks,tlim] = useDatetick(AX,data,doubleClick,zoomAppName);
 Fixes ticks.
f ~isempty(data.TicksFmt) % Fixed BUG, Jun 2009
[ticks,data] = fixTicks(ticks,tlim,data);
nd
 Change numerical date format?
f isempty(data.DATEFORM) &amp&amp ~isempty(data.TicksFmt)
if data.TicksFmt==0, data.TicksFmt = 32; end
data.TicksFmt = data.NumFmt{data.TicksFmt};
nd
 Generates the labels.
f     ~isempty(data.DATEFORM)
% Fixed formatted date.
STicks = datestr(ticks,data.DATEFORM,data.Language);
[SLabel,RLabel] = dateLabel(tlim,...
         data.LabelFmt,data.Reference,data.Language);
lseif ~isempty(data.TicksFmt)
% Default formmated date.
STicks = datestr(ticks,data.TicksFmt,data.Language);
[SLabel,RLabel] = dateLabel(tlim,...
         data.LabelFmt,data.Reference,data.Language);
lse
% No date at all.
STicks = num2str(ticks);
SLabel = '';
RLabel = [];
nd
        
 Write new ticks and label.
or k = 1:length(data.AX)
xa = data.AX(k);
lh = get(xa,[data.TICKAXIS 'Label']);
 set(xa,[data.TICKAXIS 'Lim' ],tlim);
 set(xa,[data.TICKAXIS 'Tick'],ticks);
if data.Which(k)
 set(xa,[data.TICKAXIS 'TickLabel'],STicks);
 set(lh,'String',SLabel) % Fixed bug, Aug 2009 (thanks to Kelly Kearney)
 if ~isempty(RLabel) % New feature, Aug 2009 (suggested by Giles Lesser)
  PLabel = get(lh,'Position');
  PLabel(1*(strcmp(data.TICKAXIS,'x')) + ...
         2*(strcmp(data.TICKAXIS,'y')) + ...
         3*(strcmp(data.TICKAXIS,'z'))) = RLabel;
  temp = get(lh,'Units');
  set(lh,'Units','data','Position',PLabel)
  set(lh,'Units',temp)
 end
else
 set(xa,[data.TICKAXIS 'TickLabel'],[]);
end
% Saves data on each axes.
setappdata(xa,myAppName,data);
nd
<font color="blue">function [data,ticks,tlim] = useDatetick(AX,data,doubleClick,zoomAppName) </font>
 Gets ticks by using MATLAB's DATETICK.
 Gets date limits.
lim = get(AX,[data.TICKAXIS 'Lim']);
 Generate a temporal invisible axes.
f    = ancestor(AX,{'figure','uipanel'});
empF = get(0    ,'CurrentFigure');
empA = get(tempF,'CurrentAxes');
f = figure(...
'Visible'             ,'off',...
'Units'               ,get(hf,'Units'),...
'Position'            ,get(hf,'Position'));
a = axes(...
'Parent'              ,tf,...
'Units'               ,get(AX,'Units'),...
'Position'            ,get(AX,'Position'),...
[data.TICKAXIS 'Lim'] ,tlim,...
[data.TICKAXIS 'Tick'],get(AX,[data.TICKAXIS 'Tick']));
et(0    ,'CurrentFigure',tempF);
et(tempF,'CurrentAxes'  ,tempA);
 Optional DATETICK arguments.
pt = {};
f data.KeepLimits, opt{end+1} = 'keeplimits'; end
f data.KeepTicks,  opt{end+1} = 'keepticks'; end
 Generates new TickLabels with DATETICK.
f ~isempty(data.DATEFORM)
% Manual DATEFORM.
try
 datetick(xa,data.TICKAXIS,data.DATEFORM,opt{:})  
catch
 % Unknown DATEFORM. Uses DATESTR latter.
 if isequal(data.LabelFmt,data.LabelY)
  datetick(xa,data.TICKAXIS,3,opt{:}) % 'mmm'
 elseif isequal(data.LabelFmt,data.LabelYM)
  datetick(xa,data.TICKAXIS,7,opt{:}) % 'dd'
 elseif isequal(data.LabelFmt,data.LabelYMD)
  datetick(xa,data.TICKAXIS,15,opt{:}) % 'HH:MM'
 elseif isnumeric(data.DATEFORM)
  datetick(xa,data.TICKAXIS,10,opt{:}) % 'yyyy'
 else
  datetick(xa,data.TICKAXIS,opt{:})
 end
end
lse
% Auto DATEFORM.
datetick(xa,data.TICKAXIS,opt{:})
nd
 Checks if Double-Click.
f doubleClick &amp&amp isappdata(AX,zoomAppName)
axis(xa,getappdata(AX,zoomAppName))
tlim = get(xa,[data.TICKAXIS 'Lim']);
set(hf,'SelectionType','normal')
nd
 Gets new date limits.
f ~data.KeepLimits
tlim            = get(xa,[data.TICKAXIS 'Lim']);
data.KeepLimits = true; % All zooms preserves the new limits.
nd
 Gets parameter from date axis.
icks   = get(xa,[data.TICKAXIS 'Tick']);
nticks = (ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2));
f ~data.KeepTicks &amp&amp sum(inticks(inticks))&amplt2
% Try again. Maybe something wrong with DATEFORM.
datetick(xa,data.TICKAXIS,opt{:})
ticks  = get(xa,[data.TICKAXIS 'Tick']);
inticks = (ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2));
if sum(inticks(inticks))&amplt2
 % Try again. Maybe is the axes size. Use defaut size.
 close(tf)
 tf = figure(...
  'Visible'             ,'off');
 xa = axes(...
  'Parent'              ,tf,...
  [data.TICKAXIS 'Lim'] ,tlim,...
  [data.TICKAXIS 'Tick'],get(AX,[data.TICKAXIS 'Tick']));
 set(0    ,'CurrentFigure',tempF);
 set(tempF,'CurrentAxes'  ,tempA);
 datetick(xa,data.TICKAXIS,opt{:})
 ticks  = get(xa,[data.TICKAXIS 'Tick']);
 inticks = (ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2));
end
nd
 Checks ticks (seems to solve a problem with Double-Click).
f length(ticks)&ampgt1 &amp&amp ~data.KeepTicks
inticks = find(inticks);
dticks  = diff(ticks([1 2]));
if (dticks &amplt (ticks(inticks(1))-tlim(1)))   || ...
   (dticks &amplt (tlim(2)-ticks(inticks(end)))) 
 datetick(xa,data.TICKAXIS,'keeplimits')
 ticks = get(xa,[data.TICKAXIS 'Tick']);
 tlim  = get(xa,[data.TICKAXIS 'Lim']);
end
nd
 Finds datetick and label format.
lab = get(xa,[data.TICKAXIS 'TickLabel']);
ata = findFormat(ticks(1),tlab(1,:),data);
 Clear temporal axes and figure
elete(tf)
<font color="blue">function [labeltext,labelref] = dateLabel(tlim,LabelFmt,Reference,Language) </font>
 Set label text.
abelref = [];
f isempty(LabelFmt)
labeltext = '';
lse
switch lower(Reference(1))
 case 'm'
  date0 = mean(tlim);
 case 'f'
  date0 = tlim(1);
  labelref = date0;
 case 'l'
  date0 = tlim(2);
  labelref = date0;
 case 'n'
  labeltext = ''; return
end
labeltext = datestr(date0,LabelFmt,Language); 
nd
<font color="blue">function Which = getWhichAxes(Which,WhichAxes,AX) </font>
 Finds out the axes to be printed.
f ischar(WhichAxes)
% Specifyed as a char.
switch lower(WhichAxes)
 case 'all'
  % continue
 case 'none'
  Which(:)       = false;
 case 'first'
  Which(2:end)   = false;
 case 'last'
  Which(1:end-1) = false;
end
lse
% Specifyed from axes handle.
Which(:) = false;
for k = 1:length(WhichAxes)
 [a,b] = ismember(WhichAxes(k),AX);
 if a
  Which(b) = true; 
 end
end
nd
<font color="blue">function linkAxes(data) </font>
 Links the time axes.
 Gets labels handles.
H = get(data.AX,[data.TICKAXIS 'Label']);
f iscell(LH)
LH = cell2mat(LH);
nd
 Links Limits.
xesLimAndTickLink = linkprop(data.AX,...
{[data.TICKAXIS 'Lim'],...
 [data.TICKAXIS 'Tick']});
 Links labels.
f any(data.Which)
axesTickLabelLink = linkprop(data.AX(data.Which),...
 [data.TICKAXIS 'TickLabel']);
labelStringLink = linkprop(LH(data.Which),'String');
lse
axesTickLabelLink = [];
labelStringLink   = [];
nd
 Links other axes Limits?
f (islogical(data.LinkOthers) &amp&amp data.LinkOthers) || ...
(isnumeric(data.LinkOthers) &amp&amp data.LinkOthers)
xyz = 'xyz';
lseif ischar(data.LinkOthers)
xyz = data.LinkOthers;
lse
xyz = '';
nd
yz = xyz(xyz~=data.TICKAXIS);
hile ~isempty(xyz)
addprop(axesLimAndTickLink,[xyz(1) 'Lim'])
xyz(1) = [];
nd
 Saves Link on axes and resets its zoom.
or k = 1:length(data.AX)
zoom(      data.AX(k),'reset')
setappdata(data.AX(k),'axesLimAndTickLink',axesLimAndTickLink);
setappdata(data.AX(k),'axesTickLabelLink' ,axesTickLabelLink);
setappdata(     LH(k),'labelStringLink'   ,labelStringLink);
nd
 Clears specified axes.
clear = find(~data.Which);
f ~isempty(iclear)
for h = data.AX(iclear).'
 set(    h,[data.TICKAXIS 'TickLabelMode'],'manual')
 set(    h,[data.TICKAXIS 'TickLabel'],[])
 set(get(h,[data.TICKAXIS 'Label']),'String','')
end
nd
<font color="blue">function data = findFormat(tick,tlab,data) </font>
 Gets date format from DATETICK ticks and sets the format for ticks and
 label of TLABEL. If date.TicksFmt is empty, then if date.DATEFORM is
 empty then DATETICKS won't be used, else the latter DATEFORM is used, by
 Carlos Vargas.
 Get dateformats that not include year (and months (and days)).
    0 'dd-mmm-yyyy HH:MM:SS'    15 'HH:MM'               
    1 'dd-mmm-yyyy'             16 'HH:MM PM'            
    2 'mm/dd/yy'                17 'QQ-YY'               
    3 'mmm'                     18 'QQ'                  
    4 'm'                       19 'dd/mm'               
    5 'mm'                      20 'dd/mm/yy'            
    6 'mm/dd'                   21 'mmm.dd,yyyy HH:MM:SS'
    7 'dd'                      22 'mmm.dd,yyyy'         
    8 'ddd'                     23 'mm/dd/yyyy'          
    9 'd'                       24 'dd/mm/yyyy'          
   10 'yyyy'                    25 'yy/mm/dd'            
   11 'yy'                      26 'yyyy/mm/dd'          
   12 'mmmyy'                   27 'QQ-YYYY'             
   13 'HH:MM:SS'                28 'mmmyyyy'             
   14 'HH:MM:SS PM'             29 'yyyy-mm-dd'
                                30 'yyyymmddTHHMMSS'
                                31 'yyyy-mm-dd HH:MM:SS'
{1} = [3:6 18:19];          % not years
{2} = 7:9;                  % not (years +) month
{3} = 13:16;                % not ((years +) month +) days
{4} = [0:2 10:12 17 20:31]; % includes years
 Gets label length.
lab = length(tlab);
 Gets DATETICK format and sets label format.
or k = 1:length(f) % Fixed bug, Aug 2009
% Searches in null, -y, -y-m or -y-m-d format.
for m = f{k}
 nlab = datestr(tick,m);
 if (Nlab==length(nlab)) &amp&amp strcmp(tlab,nlab)
  % Sets the DateFormat given by datetick.
  data.TicksFmt = m;
  % Search and write the DateFormat for Labels (if any). 
  if     k==1   % puts year
   data.LabelFmt = data.LabelY;
  elseif k==2   % puts year and month
   data.LabelFmt = data.LabelYM;
  elseif k==3   % puts year, month and day
   data.LabelFmt = data.LabelYMD;
  else
   data.LabelFmt = [];  % Fixed bug, Aug 2009
  end
  break
 end
end
nd

 Gets given DATEFORM and sets label format.
f isempty(data.DATEFORM) 
% continue
lseif ischar(data.DATEFORM)  
% Date format given as a string.
% Checks if is some default format.
switch data.DATEFORM
 case 'dd-mmm-yyyy HH:MM:SS', data.DATEFORM = 0;
 case 'dd-mmm-yyyy'         , data.DATEFORM = 1;
 case 'mm/dd/yy'            , data.DATEFORM = 2;
 case 'mmm'                 , data.DATEFORM = 3;
 case 'm'                   , data.DATEFORM = 4;
 case 'mm'                  , data.DATEFORM = 5;
 case 'mm/dd'               , data.DATEFORM = 6;
 case 'dd'                  , data.DATEFORM = 7;
 case 'ddd'                 , data.DATEFORM = 8;
 case 'd'                   , data.DATEFORM = 9;
 case 'yyyy'                , data.DATEFORM = 10;
 case 'yy'                  , data.DATEFORM = 11;
 case 'mmmyy'               , data.DATEFORM = 12;
 case 'HH:MM:SS'            , data.DATEFORM = 13;
 case 'HH:MM:SS PM'         , data.DATEFORM = 14;
 case 'HH:MM'               , data.DATEFORM = 15;
 case 'HH:MM PM'            , data.DATEFORM = 16;
 case 'QQ-YY'               , data.DATEFORM = 17;
 case 'QQ'                  , data.DATEFORM = 18;
 case 'dd/mm'               , data.DATEFORM = 19;
 case 'dd/mm/yy'            , data.DATEFORM = 20;
 case 'mmm.dd,yyyy HH:MM:SS', data.DATEFORM = 21;
 case 'mmm.dd,yyyy'         , data.DATEFORM = 22;
 case 'mm/dd/yyyy'          , data.DATEFORM = 23;
 case 'dd/mm/yyyy'          , data.DATEFORM = 24;
 case 'yy/mm/dd'            , data.DATEFORM = 25;
 case 'yyyy/mm/dd'          , data.DATEFORM = 26;
 case 'QQ-YYYY'             , data.DATEFORM = 27;
 case 'mmmyyyy'             , data.DATEFORM = 28;
 case 'yyyy-mm-dd'          , data.DATEFORM = 29;
 case 'yyyymmddTHHMMSS'     , data.DATEFORM = 30;
 case 'yyyy-mm-dd HH:MM:SS' , data.DATEFORM = 31;
 otherwise
  %continue
end
% Now sets the label format.
if isnumeric(data.DATEFORM)
 % Search and write the DateFormat for Labels (if any). 
 if     ismember(data.DATEFORM,f{1})   % puts year
  data.LabelFmt = data.LabelY;
 elseif ismember(data.DATEFORM,f{2})   % puts year and month
  data.LabelFmt = data.LabelYM;
 elseif ismember(data.DATEFORM,f{3})   % puts year, month and day
  data.LabelFmt = data.LabelYMD;
 else
  data.LabelFmt = []; % Just clears the label
 end
else
 % Searches for label format from the string DATEFORM.
 if     ~isempty(strfind(data.DATEFORM,'yy'))
  data.LabelFmt = [];
 elseif ~isempty(strfind(data.DATEFORM,'mm'))
  data.LabelFmt = data.LabelY;
 elseif ~isempty(strfind(data.DATEFORM,'dd'))
  data.LabelFmt = data.LabelYM;
 elseif ~isempty(strfind(data.DATEFORM,'HH'))
  data.LabelFmt = data.LabelYMD;
 elseif ~isempty(strfind(data.DATEFORM,'MM'))
  data.LabelFmt = [data.LabelYMD ' HH'];
 elseif ~isempty(strfind(data.DATEFORM,'SS'))
  data.LabelFmt = [data.LabelYMD ' HH:MM'];
 else
  data.LabelFmt = []; % Just clears the label
 end
end
lse % isnumeric(data.DATEFORM)
% DateFormat given in numeric form.
% Search and write the DateFormat for Labels (if any). 
if     ismember(data.DATEFORM,f{1})   % puts year
 data.LabelFmt = data.LabelY;
elseif ismember(data.DATEFORM,f{2})   % puts year and month
 data.LabelFmt = data.LabelYM;
elseif ismember(data.DATEFORM,f{3})   % puts year, month and day
 data.LabelFmt = data.LabelYMD;
else
 data.LabelFmt = []; % Just clears the label
end
nd
<font color="blue">function [ticks,data] = fixTicks(ticks,tlim,data) </font>
   Adds some ticks when DATETICKS puts just a few or deletes some if it
   puts too many. The quantities are specified by data.FixLow and
   data.FixHigh. Use 0 quantity if adjust is not required. By Carlos
   Vargas
 Sets minimum and maximum number of ticks.
inDayTicks = 4;
f data.KeepTicks
MinDayTicks = length(ticks);
lseif (data.FixLow==0)
MinDayTicks = -Inf;
lseif data.FixLow&ampgt1
MinDayTicks = data.FixLow;
nd
axDayTicks = 11;
f data.KeepTicks
MaxDayTicks = length(ticks);
lseif (data.FixHigh==0)
MaxDayTicks = Inf;
lseif data.FixHigh&ampgt1
MaxDayTicks = data.FixHigh;
nd
f MaxDayTicks &amplt= MinDayTicks
MaxDayTicks = MinDayTicks;
nd
 Checks maximum number of ticks.
nticks = sum((ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2)));
f (data.FixHigh~=0)
ticks2   = ticks;
inticks2 = inticks;
k        = 0;
while (inticks2&ampgtmax(MaxDayTicks,1)) &amp&amp (k&amplt3) % Fixed bug, Aug 2009
 k        = k+1;
 ticks2   = ticks2(1:2:end);
 inticks2 = sum((ticks2&ampgt=tlim(1)) &amp (ticks2&amplt=tlim(2)));
end
ticks   = ticks2;
inticks = inticks2;
nd
 Checks minimum number of ticks and its format.
f data.FixLow~=0
kmax = 4;
k    = 0;
if data.KeepTicks
 tickskeep = ticks;
end
if ~isempty(data.DATEFORM)
 LabelFmt = data.LabelFmt;
end
% Tries to increase the number of ticks after some trials.
while (k&ampltkmax) &amp&amp ((inticks&ampltMinDayTicks) || data.KeepTicks)
 k = k+1;
 
 %    0 'dd-mmm-yyyy HH:MM:SS'    15 'HH:MM'               
 %    1 'dd-mmm-yyyy'             16 'HH:MM PM'            
 %    2 'mm/dd/yy'                17 'QQ-YY'               
 %    3 'mmm'                     18 'QQ'                  
 %    4 'm'                       19 'dd/mm'               
 %    5 'mm'                      20 'dd/mm/yy'            
 %    6 'mm/dd'                   21 'mmm.dd,yyyy HH:MM:SS'
 %    7 'dd'                      22 'mmm.dd,yyyy'         
 %    8 'ddd'                     23 'mm/dd/yyyy'          
 %    9 'd'                       24 'dd/mm/yyyy'          
 %   10 'yyyy'                    25 'yy/mm/dd'            
 %   11 'yy'                      26 'yyyy/mm/dd'          
 %   12 'mmmyy'                   27 'QQ-YYYY'             
 %   13 'HH:MM:SS'                28 'mmmyyyy'             
 %   14 'HH:MM:SS PM'             29 'yyyy-mm-dd'
 %                                30 'yyyymmddTHHMMSS'
 %                                31 'yyyy-mm-dd HH:MM:SS'  
 
 % Checks the date part icluded in the format.
 isformat = [0 0 0 0 0 0];
 if     ismember(data.TicksFmt,[0 13:14 21 30:31]) % Seconds
  isformat(6) = 1;
 elseif ismember(data.TicksFmt,15:16)            % Hours and minutes
  isformat(4) = 1;
 elseif ismember(data.TicksFmt,[1:2 6:9 19:26 29]) % Days
   isformat(3) = 1;
 elseif ismember(data.TicksFmt,[3:5 12 28])     % Months
  isformat(2) = 1;
 elseif ismember(data.TicksFmt,10:11)           % Years
  isformat(1) = 1;
 end
 
 % Now adds ticks corresponding to the format.

 % SECONDS ===============================================================
 if isformat(6)
  % Checks size.
  if length(ticks)&amplt2, continue, end
  % Changes serial date to vector.
  ticks = datevec(ticks+0.1/86400); ticks(:,6) = round(ticks(:,6));
  % Gets date interval in seconds.
  dt = round((datenum(ticks(2,1:6))-datenum(ticks(1,1:6)))*86400);
  % Gets increase factor from factorization.
  dtf = factor(dt); dtf = dtf(1);
  % Gets new date interval.
  dt = dt/dtf; 
  % Gets new number of ticks. 
  nticks = (size(ticks,1)+1)*dtf;
  % Generates new ticks.
  yyt   = repmat(ticks(1,1),nticks,1);
  mmt   = repmat(ticks(1,2),nticks,1);
  ddt   = repmat(ticks(1,3),nticks,1);
  HHt   = repmat(ticks(1,4),nticks,1);
  MMt   = repmat(ticks(1,5),nticks,1);
  SSt   = ((0:nticks-1)'-dtf)*dt + ticks(1,6);
  ticks = datenum([yyt mmt ddt HHt MMt SSt]);
  % Checks ticks outside limits.
  inticks = (ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2));
  ticks(~inticks)   = [];
  inticks(~inticks) = [];
  inticks = sum(inticks(inticks));
  if inticks&amplt2, continue, end
  % Checks maximum number of ticks.
  if data.FixHigh
   l = 0;
   while (inticks&ampgtMaxDayTicks) &amp&amp (l&amplt3)
    l = l+1;
    tempticks = ticks;
    ticks     = ticks(1:2:end);
    inticks   = sum((ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2)));
    if inticks&ampltMinDayTicks
     ticks = tempticks;
     k = Inf;
     break
    end
   end
  end
  % Checks if seconds were not used. 'HH:MM' to be used.
  ticks2 = datevec(ticks(1:2)+0.1/86400);
  if round(ticks2(1,6))==round(ticks2(2,6))
   data.TicksFmt = 15;
  end 
      
 % HOURS or MINUTES ======================================================
 elseif isformat(4) || isformat(5)
  % Checks size. 'HH:MM:SS' to be used?
  if length(ticks)&amplt2, k = k-1; data.TicksFmt = 13; continue, end
  % Changes serial date to vector.
  ticks    = datevec(ticks+0.1/86400);
  if ticks(2,5)~=ticks(1,5)
   % MINUTES.
   % Gets date interval in minutes.
   dt = round((datenum([ticks(2,1:5) 0])-datenum([ticks(1,1:5) 0]))*1440);
  else % ((ticks(1,4)+ticks(2,4))==0) || (ticks(2,4)~=ticks(1,4))
   % HOURS
   % Gets date interval in hours.
   dt = round((datenum([ticks(2,1:4) 0 0]) - ...
               datenum([ticks(1,1:4) 0 0]))*24);
  end
  % 'HH:MM:SS' to be used?
  if dt==0
   ticks = datenum(ticks);
   k = k-1;
   data.TicksFmt = 13;
   continue
  end
  % Gets increase factor from factorization.
  dtf = factor(dt); dtf = dtf(1);
  % Gets new date interval.
  dt = dt/dtf;
  % Gets new number of ticks. 
  nticks = (size(ticks,1)+1)*dtf;
  % Generates new ticks.
  yyt = repmat(ticks(1,1),nticks,1);
  mmt = repmat(ticks(1,2),nticks,1);
  ddt = repmat(ticks(1,3),nticks,1);
  if ticks(2,5)~=ticks(1,5)
   % MINUTES.
   HHt = repmat(ticks(1,4),nticks,1);
   MMt = ((0:nticks-1)'-dtf)*dt + ticks(1,5);
   SSt = zeros(nticks,1);
  else % ((ticks(1,4)+ticks(2,4))==0) || (ticks(2,4)~=ticks(1,4))
   % HOURS
   HHt = ((0:nticks-1)'-dtf)*dt + ticks(1,4);
   MMt = zeros(nticks,1);
   SSt = MMt;
  end
  ticks = datenum([yyt mmt ddt HHt MMt SSt]);
  % Checks ticks outside limits.
  inticks = (ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2));
  % 'HH:MM:SS' to be used?
  if sum(inticks(inticks))&amplt2 
   k = k-1; 
   data.TicksFmt = 13;
   inticks = sum(inticks(inticks));
   continue
  end
  % Clears bad ticks.
  ticks(~inticks) = [];
  inticks = sum(inticks(inticks));
  % Checks maximum number of ticks.
  if data.FixHigh
   l = 0;
   while (inticks&ampgtMaxDayTicks) &amp&amp (l&amplt3)
    l = l+1;
    tempticks = ticks;
    ticks     = ticks(1:2:end);
    inticks   = sum((ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2)));
    if inticks&ampltMinDayTicks
     ticks = tempticks;
     k = Inf;
     break
    end
   end
  end
  % Checks if seconds are used or if minutes/hours are not used.
  ticks2 = datevec(ticks(1:2)+0.1/86400);
  if round(ticks2(1,6))~=round(ticks2(2,6))
   % 'HH:MM:SS' to be used.
   data.TicksFmt = 13;
  elseif (round(ticks2(1,5))==round(ticks2(2,5))) &amp&amp ...
          round(ticks2(1,4))==round(ticks2(2,4))
   % Minutes/hours not used. 'mm/dd' to be used.
    data.TicksFmt = 6; 
    data.LabelFmt = data.LabelY;
  elseif (k==kmax) &amp&amp (inticks&ampltMinDayTicks)
   k = 0;
   % 'HH:MM:SS' to be used.
   data.TicksFmt = 13;
  end 
     
 % DAYS ==================================================================
 elseif isformat(3)
  % Checks size. 'HH:MM' to be used?
  if length(ticks)&amplt2 
   k = k-1; 
   data.TicksFmt = 15; 
   data.LabelFmt = data.LabelYMD; 
   continue 
  end
  % Changes serial date to vector.
  ticks   = datevec(ticks);
  % Gets date interval in days.
  dt      = datenum([ticks(2,1:3) 0 0 0])-datenum([ticks(1,1:3) 0 0 0]);
  if dt==0
   ticks = datenum(ticks);
   k = k-1;
   % 'HH:MM' to be used.
   data.TicksFmt = 15;
   data.LabelFmt = data.LabelYMD;
   continue
  end
  if dt&ampgt27 &amp&amp dt&amplt32
   % One month interval, decreased to 15 days.
   nticks = 2*size(ticks,1);
   % Generates new ticks.
   yyt    = ticks(:,1);
   mmt    = ticks(:,2);
   yyt    = [yyt yyt].'; yyt = yyt(:);
   mmt    = [mmt mmt].'; mmt = mmt(:);
   ddt    = [ones(nticks/2,1) repmat(15,nticks/2,1)].'; ddt = ddt(:);
  else
   % Just increases the old interval
   % Gets increase factor from factorization.
   dtf    = factor(round(dt)); dtf = dtf(1);
   % Gets new date interval.
   dt     = dt/dtf;
   % Gets new number of ticks. 
   nticks = size(ticks,1); nticks = dtf*(nticks+1); 
   % Generates new ticks.
   yyt    = repmat(ticks(1,1),nticks,1);
   mmt    = repmat(ticks(1,2),nticks,1);
   ddt    = ((0:nticks-1)'-dtf)*dt + ticks(1,3);
  end
  HHt     = zeros(nticks,1);
  MMt     = HHt;
  SSt     = MMt;
  ticks   = datenum([yyt mmt ddt HHt MMt SSt]);
  % Checks ticks outside limits.
  inticks = (ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2));
  % 'HH:MM' to be used?
  if sum(inticks(inticks))&amplt2
   k = k-1; 
   data.TicksFmt = 15; 
   data.LabelFmt = data.LabelYMD;
   inticks = sum(inticks(inticks));
   continue 
  end
  % Clears bad ticks.
  ticks(~inticks)   = [];
  inticks = sum(inticks(inticks));
  % Checks maximum number of ticks.
  if data.FixHigh
   l = 0;
   while (inticks&ampgtMaxDayTicks) &amp&amp (l&amplt3)
    l = l+1;
    tempticks = ticks;
    ticks     = ticks(1:2:end);
    inticks   = sum((ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2)));
    if inticks&ampltMinDayTicks
     ticks = tempticks;
     k = Inf;
     break
    end
   end
  end
  % Checks if hours are used or if days are not used.
  ticks2 = datevec(ticks(1:2)+0.1/86400);
  if round(ticks2(1,4))~=round(ticks2(2,4))
   % Hours used.
   data.TicksFmt = 15; % 'HH:MM'
   data.LabelFmt = data.LabelYMD;
  elseif round(ticks2(1,3))==round(ticks2(2,3))
   % Days not used.
    data.TicksFmt = 3; % 'mmm'
    data.LabelFmt = data.LabelY;
  elseif (k==kmax) &amp&amp (inticks&ampltMinDayTicks)
   k = 0;
   % Hours to be used.
   data.TicksFmt = 15; % 'HH:MM'
   data.LabelFmt = data.LabelYMD;
  end
  
 % MONTHS ================================================================
 elseif isformat(2) % Adds months
  % Checks size. 'mm/dd' to be used?
  if length(ticks)&amplt2, k = k-1; data.TicksFmt = 6; continue, end
  % Changes serial date to vector.
  ticks = datevec(ticks);
  % Gets date interval in months.
  dt = ticks(2,2) - (ticks(1,2))+12*(ticks(2,1)-ticks(1,1));
  if dt==0
   ticks = datenum(ticks);
   k = k-1;
   % 'mm/dd' to be used.
   data.TicksFmt = 6;
   continue
  end
  % Gets increase factor from factorization.
  dtf = factor(round(dt)); dtf = dtf(1);
  % Gets new date interval.
  dt = dt/dtf;
  % Gets new number of ticks. 
  nticks = (size(ticks,1)+1)*dtf;
  % Generates new ticks.
  yyt     = repmat(ticks(1,1),nticks,1);
  mmt     = ((0:nticks-1)'-dtf)*dt + ticks(1,2);
  ineg    = mmt&amplt=0;
  while any(ineg)
   yyt(ineg) = yyt(ineg)-1;
   mmt(ineg) = mmt(ineg)+12;
   ineg      = mmt&amplt=0;
  end
  ddt     = ones(nticks,1);
  HHt     = zeros(nticks,1);
  MMt     = HHt;
  SSt     = MMt;
  ticks   = datenum([yyt mmt ddt HHt MMt SSt]);
  % Checks ticks outside limits.
  inticks = (ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2));
  % 'mm/dd' to be used?
  if sum(inticks(inticks))&amplt2 
   k = k-1; 
   data.TicksFmt = 6; 
   inticks = sum(inticks(inticks));
   continue 
  end
  % Clears bad ticks.
  ticks(~inticks) = [];
  inticks = sum(inticks(inticks));
  % Checks maximum number of ticks.
  if data.FixHigh
   l = 0;
   while (inticks&ampgtMaxDayTicks) &amp&amp (l&amplt3)
    l = l+1;
    tempticks = ticks;
    ticks     = ticks(1:2:end);
    inticks   = sum((ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2)));
    if inticks&ampltMinDayTicks
     ticks = tempticks;
     k = Inf;
     break
    end
   end
  end
  % Checks if days are used or if months are not used.
  ticks2 = datevec(ticks(1:2)+0.1/86400);
  if round(ticks2(1,3))~=round(ticks2(2,3))
   % 'mm/dd' to be used.
   data.TicksFmt = 6;
  elseif round(ticks2(1,2))==round(ticks2(2,2))
   % Months not used. 'yyyy' to be used.
    data.TicksFmt = 10;
    data.LabelFmt = '';
  elseif (k==kmax) &amp&amp (inticks&ampltMinDayTicks)
   k = 0;
   % 'mm/dd' to be used.
   data.TicksFmt = 6;
   data.LabelFmt = data.LabelY;
  end  
     
 % YEARS =================================================================
 elseif isformat(1) % Adds years
  % Checks size. 'mmm' to be used?
  if length(ticks)&amplt2 
   k = k-1; 
   data.TicksFmt = 3; 
   data.LabelFmt = data.LabelY;
   continue 
  end
  % Changes serial date to vector.
  ticks = datevec(ticks);
  % Gets date interval in years.
  dt = ticks(2,1) - ticks(1,1);
  if dt==0
   ticks = datenum(ticks);
   k = k-1;
   % 'mmm' to be used.
   data.TicksFmt = 3;
   data.LabelFmt = data.LabelY;
   continue
  end
  % Gets increase factor from factorization.
  dtf = factor(round(dt)); dtf = dtf(1);
  % Gets new date interval.
  dt = dt/dtf; 
  % Gets new number of ticks. 
  nticks = (size(ticks,1)+1)*dtf;
  % Generates new ticks.
  yyt       = ((0:nticks-1)'-dtf)*dt + ticks(1,1);
  mmt       = ones(nticks,1);
  ddt       = mmt;
  HHt       = zeros(nticks,1);
  MMt       = HHt;
  SSt       = MMt;
  ineg      = yyt&amplt0;
  yyt(ineg) = [];
  mmt(ineg) = [];
  ddt(ineg) = [];
  HHt(ineg) = [];
  MMt(ineg) = [];
  SSt(ineg) = [];
  ticks     = datenum([yyt mmt ddt HHt MMt SSt]);
  % Checks ticks outside limits.
  inticks = (ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2));
  % 'mmm' to be used?
  if sum(inticks(inticks))&amplt2 
   k = k-1; 
   data.TicksFmt = 3; 
   data.LabelFmt = data.LabelY;
   inticks = sum(inticks(inticks));
   continue 
  end
  % Clears bad ticks.
  ticks(~inticks) = [];
  inticks = sum(inticks(inticks));
  % Checks maximum number of ticks.
  if data.FixHigh
   l = 0;
   while (inticks&ampgtMaxDayTicks) &amp&amp (l&amplt3)
    l = l+1;
    tempticks = ticks;
    ticks     = ticks(1:2:end);
    inticks   = sum((ticks&ampgt=tlim(1)) &amp (ticks&amplt=tlim(2)));
    if inticks&ampltMinDayTicks
     ticks = tempticks;
     k = Inf;
     break
    end
   end
  end
  % Checks if months are used.
  ticks2 = datevec(ticks(1:2)+0.1/86400);
  if round(ticks2(1,2))~=round(ticks2(2,2))
   % 'mmm' to be used.
   data.TicksFmt = 3;
   data.LabelFmt = data.LabelY;
  elseif (k==kmax) &amp&amp (inticks&ampltMinDayTicks)
   k = 0;
   % 'mmm' to be used.
   data.TicksFmt = 3;
   data.LabelFmt = data.LabelY;
  end 
 end
end
if data.KeepTicks
 ticks = tickskeep;
end
if ~isempty(data.DATEFORM)
 data.LabelFmt = LabelFmt;
end
nd
<font color="blue">function data = parseInputs(data,varargin) </font>
 Retrieves inputs.
 Looks for axes handles.
f nargin&ampgt1 &amp&amp ~isempty(varargin{1}) &amp&amp all(ishandle(varargin{1}))
data.AX = [];
for k = 1:length(varargin{1})
 switch get(varargin{1}(k),'type')
 case {'figure','uipanel'}
  % Find axes on figures.
  ax = sort(findobj(varargin{1}(k),'-depth',1,'Type','axes',...
   '-not','Tag','Colorbar','-not','Tag','legend'));
 case 'axes'
  % Directc from axes.
  ax = varargin{1}(k);
 otherwise
  error('CVARGAS:tlabel:incorrectHandleInput', ...
        'Input handle must be from figures, uipanels or axes.')
 end
 data.AX = [data.AX; ax(:)];
end
if isempty(data.AX)
  error('CVARGAS:tlabel:incorrectHandleInput', ...
        'Input handle must be from figures, uipanels or axes.')
end
varargin(1) = [];
nd
 Initializes Which.
ata.Which = ishandle(data.AX);
 Parses all other inputs.
ivenKeepTicks  = false;
ivenKeepLimits = false;
hile ~isempty(varargin)

if isempty(varargin{1})
 % continue
elseif ischar(varargin{1})
 % Look for strings inputs.
 
 switch lower(varargin{1})
  case {'keeplimits','keeplimit','keeplimi','keeplim','keepli','keepl'}
   data.KeepLimits = true;
   givenKeepLimits = true;
  case {'keepticks','keeptick','keeptic','keepti','keept'}
   data.KeepTicks = true; 
   givenKeepTicks = true;
  case {'freelimits','freelimit','freelimi','freelim','freeli','freel'}
   data.KeepLimits = false;
   givenKeepLimits = true;
  case {'freeticks','freetick','freetic','freeti','freet'}
   data.KeepTicks = false; 
   givenKeepTicks = true;
  case 'x'
   data.TICKAXIS = 'x';
  case 'y'
   data.TICKAXIS = 'y';
  case 'z'
   data.TICKAXIS = 'z';
  case {'language','languag','langua','langu','lang','lan','la'}
   if length(varargin)&ampgt1 &amp&amp ...
      (strcmpi(varargin{2},'local') || strcmpi(varargin{2},'en_us'))
    data.Language = varargin{2};
   else
    warning('CVARGAS:tlabel:incorrectLanguageInput', ...
     '''Language'' must be one of ''local'' or ''en_us''. Default used.')
   end
   varargin(1) = []; % Clear property name
  case {'linkothers','linkother','linkothe','linkoth','linkot','linko',...
        'link','lin','li'}
   if (length(varargin)&ampgt1) &amp&amp ((ischar(varargin{2}) &amp&amp ...
      (length(varargin{2})&amplt3) &amp&amp ...
      (strcmpi(varargin{2},'x')  || strcmpi(varargin{2},'y')  || ...
       strcmpi(varargin{2},'z')  || strcmpi(varargin{2},'xy') || ...
       strcmpi(varargin{2},'yx') || strcmpi(varargin{2},'yz') || ...
       strcmpi(varargin{2},'zy') || strcmpi(varargin{2},'xz') || ...
       strcmpi(varargin{2},'zx'))) || islogical(varargin{2}))
    data.LinkOthers = varargin{2};
   else
    warning('CVARGAS:tlabel:incorrectLinkothersInput', [...
     '''LinkOthers'' must be one of ''x'', ''y'', ''z'', or a ' ...
     'combination, or a logical. Default used.'])
   end
   varargin(1) = []; % Clear property name
  case {'whichaxes','whichaxe','whichax','whicha','which','whic','whi',...
        'wh','w'} % Fixed BUG, Aug 2009 (thanks to Giles Lesser)
   if (length(varargin)&ampgt1) &amp&amp ((ischar(varargin{2}) &amp&amp ...
    (strcmpi(varargin{2},'all')   || strcmpi(varargin{2},'none') || ...
     strcmpi(varargin{2},'first') || strcmpi(varargin{2},'last'))) || ...
     all(ishandle(varargin{2})))
   data.WhichAxes = varargin{2};
   else
    warning('CVARGAS:tlabel:incorrectWhichaxesInput', [...
     '''WhichAxes'' must be one of ''all'', ''none'', ''first'', '...
     '''last'' or specific axes handles. Default used.'])
   end
   varargin(1) = []; % Clear property name
  case {'fixlow','fixlo','fixl'}
   if (length(varargin)&ampgt1) &amp&amp (numel(varargin{2})==1) &amp&amp ...
       isfinite(varargin{2})
    data.FixLow = round(abs(varargin{2})); % Forces integer
   else
    warning('CVARGAS:tlabel:incorrectFixlowInput', ...
     '''FixLow'' must be a positive integer or zero. Default used.')
   end
   varargin(1) = []; % Clear property name
  case {'fixhigh','fixhig','fixhi','fixh'}
   if (length(varargin)&ampgt1) &amp&amp (numel(varargin{2})==1) &amp&amp ...
       isfinite(varargin{2})
    data.FixHigh = varargin{2};
   else
    warning('CVARGAS:tlabel:incorrectFixHighInput', ...
     '''FixHigh'' must be a positive integer or zero. Default used.')
   end
   varargin(1) = []; % Clear property name
  case {'reference','referenc','referen','refere','refer','refe','ref',...
    're','r'} % Fixed BUG, Aug 2009 (tanhks to Giles Lesser)
   if (length(varargin)&ampgt1) &amp&amp (ischar(varargin{2}) &amp&amp...
      (strcmpi(varargin{2},'middle') || strcmpi(varargin{2},'first') ||...
       strcmpi(varargin{2},'last')) || strcmpi(varargin{2},'none'))
   data.Reference = varargin{2};
   else
    warning('CVARGAS:tlabel:incorrectReferenceInput', [...
     '''Reference'' must be one of ''middle'', ''first'', ''last'' or '...
     '''none''. Default used.'])
   end
   varargin(1) = []; % Clear property name
  case 'labely'
   try
    datestr(1,varargin{2});
    data.LabelY = varargin{2};
   catch
    warning('CVARGAS:tlabel:incorrectLabelyInput', ...
     '''LabelY'' must be a valid date format. Default used.')
   end
   varargin(1) = []; % Clear property name
  case 'labelym'
   try
    datestr(1,varargin{2});
    data.LabelYM = varargin{2};
   catch
    warning('CVARGAS:tlabel:incorrectLabelymInput', ...
     '''LabelYM'' must be a valid date format. Default used.')
   end
   varargin(1) = []; % Clear property name
  case 'labelymd'
   try
    datestr(1,varargin{2});
    data.LabelYMD = varargin{2};
   catch
    error('CVARGAS:tlabel:incorrectLabelymdInput', ...
     '''LabelYMD'' must be a valid date format. Default used.')
   end
   varargin(1) = []; % Clear property name

  otherwise
   % A different char input.
   
   if length(varargin{1})&ampgt6 &amp&amp strcmpi(varargin{1}(1:6),'numfmt')
    % Look for NumFmtNN input.
    
    numfmt = str2double(varargin{1}(7:end));
    if ismember(numfmt,0:31)
     if numfmt==0, numfmt = 32; end
     try
      datestr(1,varargin{2});
      data.NumFmt{numfmt} = varargin{2};
     catch
      warning('CVARGAS:tlabel:incorrectNumfmtnnStringInput', ...
       '''NumFmtNN'' must be a valid date format. Default used.')
     end
    else
     warning('CVARGAS:tlabel:incorrectNumfmtnnNumericInput', ...
      ['''NN'' in ''NumFmtNN'' must be an integer from ''0'' to '...
       '''31''. Default used.'])
    end
    varargin(1) = []; % Clear property name
   else
    % Look for DATEFORM string input.
    try
     datestr(1,varargin{1});
     data.DATEFORM = varargin{1};
    catch
     warning('CVARGAS:tlabel:incorrectDateformStringInput', ...
      ['String ''DATEFORM'' must be a valid date format or a not ' ...
       'recognized property were given. Default used.'])
    end
   end
   
 end
else
 % Numeric DATEFORM input?
 if isnumeric(varargin{1}) &amp&amp isfinite(varargin{1}) &amp&amp ...
   (numel(varargin{1})==1) &amp&amp ismember(varargin{1},0:31) % Fixed bug, Aug 2009
  data.DATEFORM = varargin{1};
 else
  warning('CVARGAS:tlabel:incorrectDateformNumericInput', ...
   'Numeric ''DATEFORM'' must be an integer from 0 to 31. Default used')
 end
end

% Deletes readed input:
varargin(1) = []; % Clear property value

nd
 Fixed BUG (3rd time!), Jul 2009. Thanks to Ayal Anis.
f ~givenKeepTicks &amp&amp ~data.KeepTicks &amp&amp ...
all(strcmp(get(data.AX,[data.TICKAXIS 'TickMode']),'manual'))
data.KeepTicks = true;
nd
f ~givenKeepLimits &amp&amp ~data.KeepLimits &amp&amp ...
all(strcmp(get(data.AX,[data.TICKAXIS 'LimMode']),'manual'))
data.KeepLimits = true;
nd
 [EOF]   tlabel.m
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/tlabel.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="wave_climate_MEX_TEST">
<H2>wave_climate_MEX_TEST</H2></A>
 first run startup.m from climada and then startup_coastal.m
 
 invoke climada 
 % % disp('loading climada') 
 % % run([dir_climada,filesep,'startup.m'])
 % % 
 % % % invoke climada coastal 
 % % disp('loading climada - coastal modules ') 
 % % run([dir_climada_coastal,filesep,'startup_coastal.m'])
 
lobal climada_global
% 
 SIMULATION OF SEA LEVEL COMPONENTS: 
       TIDES, HISTORICAL SEA LEVEL, SEA LEVEL RISE 

% LOAD COORDINATES 
oad([climada_global.data_coastal_dir,filesep,'test_coastal_hazards_centroids.mat'])
% GET WAVE CLIMATE PROPERTIES 
 
 sea level rise projections for Representative Concentration Pathways 
 Values correspond to mean value of projection (central estimate), and total sea level rise.
 Values correspond to SLR for &quot2081-2100 20-yr mean minus 1986-2005 20-yr mean&quot
 Units: &quotm&quot
orrect_by_coast = 1; 
output]=climada_get_GlobalWaveClimate(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude, correct_by_coast)
oast = load (climada_global.map_border_file); 
oast.lon = [coast.shapes(:).X]; 
oast.lat = [coast.shapes(:).Y]; 
oxcoord=[min(coastal_hazard_centroids.Longitude(:)) max(coastal_hazard_centroids.Longitude(:)),...
   min(coastal_hazard_centroids.Latitude(:)) max(coastal_hazard_centroids.Latitude(:))]; 
igure, 
ubplot(1,2,1) 
old on, axis tight, axis equal, grid on, axis(boxcoord)
lot(coast.lon,coast.lat,'k','linewidth',2)
catter(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude,30,output.Hsq95,'fill'), colorbar, title('95% sign. wave height (m)') 

ubplot(1,2,2) 
old on, axis tight, axis equal, grid on, axis(boxcoord)
lot(coast.lon,coast.lat,'k','linewidth',2)
catter(coastal_hazard_centroids.Longitude,coastal_hazard_centroids.Latitude,30,output.WavePowerMean,'fill'), colorbar, title('Mean Wave Power (kw/m)') 
eturn 
% CREATE MULTIVARIATE PLOT USING CAMUS ET AL 2011 AND REGUERO ET AL 2013 
 requires: SOM toolbox &amp kmeans algorithm 
 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/coastal_hazards/code/wave_climate_MEX_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="centroids_generate_hazard_sets">
<H2>centroids_generate_hazard_sets</H2></A>
<font color="blue">function centroids_hazard_info=centroids_generate_hazard_sets(centroids,probabilistic,force_recalc,check_plots,peril_ID) </font>
 climada
 MODULE:
   country_risk
 NAME:
   centroids_generate_hazard_sets
 PURPOSE:
   run all (available) perils for a given set of centroids. Generate
   earthquake (EQ), volcano (VQ), tropical cyclone (TC), torrential rain
   (TR) and storm surge (TS) hazard event sets 
   1) figure which hazards affect the centroids
   2) create the hazard event sets, uses
      - climada_tc_hazard_set (wind)
      - climada_tr_hazard_set (rain)
      - climada_ts_hazard_set (surge)
      - eq_global_hazard_set (earthquake)
      - European winter storm module (existing hazard)

   Note that the code supports both TC tracks from unisys database files
   and (NCAR) netCDF TC track files. Should both exist in the active
   ..\data\tc_tracks folder, the user NEEDS to 'hide' the ones not needed
   (e.g. by moving them into a temporary subfolder). Otherwise, the code
   produces two hazard event sets (which might be intended).

   Please not further that the WS_Europe hazard event set is defined in
   PARAMETERS, as this is not freshly generated, but the country hazard
   event set is just a subset (see also climada module ws_europe)

   previous step: country_risk_calc or climada_create_GDP_entity
   next step: see country_risk_calc (if you start with your own centroids,
   you might rather calculate the risk yourself, e.g. using
   climada_EDS_calc...)
 CALLING SEQUENCE:
   centroids_hazard_info=centroids_generate_hazard_sets(centroids,probabilistic,force_recalc,check_plots,peril_ID)
 EXAMPLE:
   centroids_generate_hazard_sets; % interactive, prompt for centroids
 INPUTS:
   centroids: a centroid structure, see e.g. climada_centroids_load
       or an entity (in which case it takes the entity.assets.lat and
       entity.assets.lon)
       &ampgt prompted for if empty (centroids need to exist als .mat file
       already - otherwise run e.g. climada_centroids_read first).
       In case you select an entity, it takes entity.assets.lat and
       entity.assets.lon.
 OPTIONAL INPUT PARAMETERS:
   probabilistic: if =1, generate probabilistic hazard event sets,
       =0 generate 'historic' hazard event sets (default)
       While one need fully probabilistic sets for really meaningful
       results, the default is 'historic' as this is the first thing to
       check.
   force_recalc: if =1, recalculate the hazard sets, even if they exist
       (good for TEST while editing the code, default=0)
   check_plots: if =1, show figures to check hazards etc.
       If =0, skip figures (default)
   peril_ID: if passed on, run all calculations only for specified peril
       peril_ID can be 'TC','TS','TR','EQ','WS'..., default='' for all
 OUTPUTS:
   writes hazard event set files: III_name_rrr_PP{|_hist}.mat with III
       ISO2 country (admin0) code, country name, rrr peril region and PP
       peril_ID. Appends _hist if non-probabilistic. Note that for admin1
       hazard event sets, name does alos contain the admin1 name.
   centroids_hazard_info(centroids_i): a structure with hazard information for
       each set of centroids. See centroids_hazard_info.res.hazard with
       peril_ID: 'TC' or ...
       data_file: for TC only: the file sused to generste the event set
       hazard_set_file: the full filename of the hazard set generated
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141025, moved out of country_risk_calc
 David N. Bresch, david.bresch@gmail.com, 20141026, probabilistic as input
 David N. Bresch, david.bresch@gmail.com, 20141029, WSEU added
 David N. Bresch, david.bresch@gmail.com, 20141208, possibility to pass entity as centroids
 David N. Bresch, david.bresch@gmail.com, 20150110, save with -v7.3 (needed for large hazard sets)
 David N. Bresch, david.bresch@gmail.com, 20150112, hazard extension '_hist' for historic, '' for probabilistic
 David N. Bresch, david.bresch@gmail.com, 20150112, III_name_rrr_PP{|_hist}.mat
 David N. Bresch, david.bresch@gmail.com, 20150118, tc_track nodes file with track number
 David N. Bresch, david.bresch@gmail.com, 20150123, distance2coast_km in TC added
 David N. Bresch, david.bresch@gmail.com, 20150128, tc_track handling simplified, climada_tc_track_nodes
 David N. Bresch, david.bresch@gmail.com, 20150309, VQ (volcano) added, but switched off as default
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20151010, TR switched on as default
 David N. Bresch, david.bresch@gmail.com, 20151224, hazard module names renamed
 David N. Bresch, david.bresch@gmail.com, 20160517, double-check for tc datasets
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/centroids_generate_hazard_sets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_create_GDP_entity">
<H2>climada_create_GDP_entity</H2></A>
<font color="blue">function [centroids,entity,entity_future]=climada_create_GDP_entity(country_name,polygon,check_figure,no_wbar) </font>
 GDP entity assets
 MODULE:
   GDP_entity
 NAME:
   climada_create_GDP_entity
 PURPOSE:
   create centroids and entity for a specific country, distribute assets
   and value according to night light intensities and scale up to match 
   GDP today (see climada_global.present_reference_year) and a future (see
   climada_global.future_reference_year) scenario 
 CALLING SEQUENCE:
   [centroids entity entity_future] = climada_create_GDP_entity(country_name,polygon,check_figure,no_wbar)
 EXAMPLE:
   [centroids entity entity_future] = climada_create_GDP_entity
   [centroids entity entity_future] = climada_create_GDP_entity('Mexico')
 INPUTS:
   country_name: the name of the country or an ISO3 country code (like
       'CHE'), see climada_country_name
   polygon: do restrict to centroids in polygon, calls
       climada_cut_out_GDP_entity, see parameters there.
   check_figure: set to 1 to visualize figures, default 1
   no_wbar: 1 to suppress waitbars
   OBSOLETE (not supported any more): GDP: GDP data within a structure, 
       prompted for if not given, loaded automatically from economic_indicators_mastertable.mat file if existing
       --&ampgt all automatic now
 OUTPUTS:
   centroids: a structure with fields centroid_ID, Latitude, Longitude,
       onLand, country_name, comment for each centroid
   entity         : a structure with fields assets, damagefunctions, measures,
                    discount. Assets values are based on night light 
                    intensity and scaled up to todays GDP (e.g. 2014)
   entity_future  : entity strucure with values scaled to a future GDP
                    scenario
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140206
 David N. Bresch, david.bresch@gmail.com, 20141209, country ISO3 enabled
 David N. Bresch, david.bresch@gmail.com, 20141212, migrated to world_50m.gen being local to GDP_entity, as climada moved to admin0.mat
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150125, incorporated climada_entity_value_GDP_adjust to scale up the entity, ... 
                                                    climada_entity_GDP not used anymore
 David N. Bresch, david.bresch@gmail.com, 20150204, cleanup
 David N. Bresch, david.bresch@gmail.com, 20150804, cleanup
 David N. Bresch, david.bresch@gmail.com, 20160517, fix for missing entity.assets.centroid_index and entity.assets.hazard.comment
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/climada_create_GDP_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_entity_GDP">
<H2>climada_entity_GDP</H2></A>
<font color="blue">function entity = climada_entity_GDP(entity_base, GDP, year_requested, centroids, borders, check_figure, check_printplot) </font>
 upscale given base entity (sum of assets is 100, or less if only coastal
 areas) to match the GDP of a specific country for a given year
 NAME:
   climada_entity_GDP
 PURPOSE:
   Upscale entity to a GDP of a given country and year, read GDP data from
   worldbank/IMF, find country for given entity/centroids
 CALLING SEQUENCE:
   entity = climada_entity_GDP(entity_100, GDP, year_start, centroids,
   borders, check_figure, check_printplot)
 EXAMPLE:
   entity = climada_entity_GDP(entity_100, GDP, 2014, centroids)
 INPUTS:
   entity_base: entity with entity.assets.Value sum up to 100 for the
   entire country (if only coastal areas, sum is less than 100)
 OPTIONAL INPUTS:
   GDP       : GDP data within a structure, prompted for if not given, loaded
               automatically from GDP.mat file if existing
   year_requested: year for GDP for a given country, default
               climada_global.present_reference_year
   centroids : prompted if not given, centroids with field .country_name
               for each centroid indicating the country matching with GDP data
   borders   : border structure (with name, polygon for every country)
   check_figure   : 1 to visualize figure
   check_printplot: 1 to print/save figure
 OUTPUTS:
   entity             : assets upscaled to a GDP of a country and a given year
   a structure, with
       assets         : a structure, with
           Latitude   : the latitude of the values
           Longitude  : the longitude of the values
           Value      : the total insurable value
           Deductible : the deductible
           Cover      : the cover
           DamageFunID: the damagefunction curve ID
       damagefunctions: a structure, with
           DamageFunID: the damagefunction curve ID
           Intensity  : the hazard intensity
           MDD        : the mean damage degree
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140206
 David N. Bresch, david.bresch@gmail.com, 20141105,
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/climada_entity_GDP.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hybrid_entity">
<H2>climada_hybrid_entity</H2></A>
<font color="blue">function [entity,centroids]=climada_hybrid_entity(admin0_name) </font>
 climada hybrid entity
 MODULE:
   country_risk
 NAME:
   climada_hybrid_entity
 PURPOSE:
   Create a high-resolution entity (climada_nightlight_entity) for the
   country within its borders and add the mid-resolution centroids for
   offshore along the coast plus coarse resolution centroids around the
   country (from GDP_entity)
 CALLING SEQUENCE:
   [entity,centroids]=climada_hybrid_entity(admin0_name)
 EXAMPLE:
   entity=climada_hybrid_entity('Switzerland')
 INPUTS:
   admin0_name: country name
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   entity: the entity, see e.g. climada_entity_read for a description of
       the entity structure
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150915, intitial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/climada_hybrid_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_night_light_to_country">
<H2>climada_night_light_to_country</H2></A>
<font color="blue">function [values_distributed,pp] = climada_night_light_to_country(country_name,pp,night_light,... </font>
   borders,border_mask,check_figure,check_printplot,save_on,silent_mode)
 NAME:
   climada_night_light_to_country
 PURPOSE:
   distributed values within one country according to night light density

   geographically distribute values within one country according to
   nonlinearly tranformed night light density values (values between 1 and 63)
   based on nonlinear relationship between night light intensity and
   distribution of GDP assets, use a second order polynomial function
   without y-indent: y = pp(1) x^2 + pp(2) x;

   previous: climada_night_light_read
   next: climada_resolution_downscale
 CALLING SEQUENCE:
   [values_distributed pp] = climada_night_light_to_country(country_name, pp, night_light,...
             borders, border_mask, check_figure, check_printplot, save_on, silent_mode)
 EXAMPLE:
 values_distributed = climada_night_light_to_country('Bangladesh')
 INPUTS:
   country_name     : name of country (string)
 OPTIONAL INPUT PARAMETERS:
   pp               : parameter of second order polynomial function to transform night lights
                      nonlinearly into distribution of GDP assets
                      y = pp(1)*x^2 + pp(2)*x;
   night_light      : night light mat file (structure with values,
                      lon_range, lat_range, resolution_x, resolution_y and comment)
   borders          : climada world map country borders (structure with
                      polygon and names)
   border_mask      : structure with all country masks (zeros and ones)
   check_figure     : set to 1 to visualize figures, default 1
   check_printplot  : set to 1 to save figure, default 0
   save_on          : set to 1 to save Gvalues_distributed.mat
   silent_mode      : if set to 1, no print out messages, default 0
 OUTPUTS:
   values_distributed: a struct, with following fields
         .values       : distributed GDP per pixel
         .lon_range    : range of Longitude
         .lat_range    : range of Latitude
         .resolution_x : resolution in x-direction
         .resolution_y : resolution in y-direction
         .comment      : information about distributed GDP data, year and pp
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20130412
 David N. Bresch, david.bresch@gmail.com, 20141205, cleanup and 1km try (see parameters below)
 David N. Bresch, david.bresch@gmail.com, 20160222, module_data_dir updated
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/climada_night_light_to_country.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_nightlight_entity">
<H2>climada_nightlight_entity</H2></A>
<font color="blue">function entity=climada_nightlight_entity(admin0_name,admin1_name,selections,check_plot,scale_Value,img_filename,save_entity) </font>
 country admin0 admin1 entity high resolution
 NAME:
	climada_nightlight_entity
 PURPOSE:
   Construct an entity file based on high-res (1km!) or mid -res (10km)
   night light data.

   Reads an image file with nightlight density and matches it to the local
   geography.

   Prompts for country (admin0) and state/province (admin1), obtains the
   high-resolution night lights for this area and constrains the active
   centroids (with values&ampgt0) to the selected country or admin1 (see input
   parameter selections) and saves the entity, adding distance to coast
   (im km) and elevation (in m) for each centroid, too.

   Since we're dealing with admin1, no automatic scaling or allocation of
   GDP to centroids is performed (for this, see
   climada_create_GDP_entity), unless selection is set for full country
   (=1), in which case assets are scaled to 6 times GDP, as a proxy for
   insurable values.

   If the high-resolution night light image is stored locally (about 700MB
   as tiff, after first call about 24MB as .mat), the code works from
   there.
   See http://ngdc.noaa.gov/eog/dmsp/downloadV4composites.html#AVSLCFC3
   to obtain the file
   http://ngdc.noaa.gov/eog/data/web_data/v4composites/F182012.v4.tar
   and unzip the file F182012.v4c_web.stable_lights.avg_vis.tif in there
   to the /data folder of country_risk module. As the .tif is so much
   larger, the climada module country_risk comes with the .mat file, but
   does not contain the original (.tif). Please note that the GDP_entity
   could also deal with such a high-res dataset (see respective
   documentation) - that's why the present code does also check for the
   night light data to be stored there (see GDP_entity_CHECK in code)

   If the high-resolution night light image is stored locally, it fetches
   the tile of night light density from www (i.e. asks the user to enter a
   specific URL, to locally store the respective file) and works from
   there. (See also http://maps.ngdc.noaa.gov/viewers/dmsp_gcv4/ to obtain
   a specific 'tile' of the global high res via a web-GUI (but method with
   the coe suggesting the URL is strongly recommended).

   Programmer's remark: see fetch_mapserver_ngdc_noaa_gov_gcv4 at the
   bottom of the code, which could in theory fetch the tile from www

   See also climada_create_GDP_entity and climada_hybrid_entity
 CALLING SEQUENCE:
   entity=climada_nightlight_entity(admin0_name,admin1_name,selections,check_plot,scale_Value,img_filename,save_entity)
 EXAMPLE:
   entity=climada_nightlight_entity('Italy','',2); % good for test, as shape of Italy is well-known
   entity=climada_nightlight_entity('France','',-1); % France, scaled by GDP, 10km resolution
   entity=climada_nightlight_entity('United States of America','Florida',2,2);
   entity=climada_nightlight_entity('Sswitzerland','',1,0,[0 1 0 -1]); % scale by GDP (the -1)
   entity=climada_nightlight_entity('CHE','',1); % full country, scale by 6 times GDP as a proxy for insurable values
   entity=climada_nightlight_entity % all interacrtive
   climada_entity_plot(entity) % to check the content of the final entity
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   admin0_name: the country name, either full or ISO3
       &ampgt If empty, a list dialog lets the user select (default)
       Also useful if a img_filename is passed and thus if admin0_name is
       defined, the respective country is cut out.
       Instead of explicit country names, one can also use ISO3 country
       codes (like DEU, CHE). Note that the entity filename will use the
       full country name, but ISO3 is stored in entity.assets.admin0_ISO3
       See parameter selections, especially if you want to select a whole
       country.
   admin1_name: if passed on, do not prompt for admin1 name
       &ampgt If empty, a list dialog lets the user select (default)
       Most useful for subsequent calls, i.e. once one knows the exact
       admin1 name. Also useful if a img_filename is passed and thus if
       admin1_name is defined, the respective admin1 is cut out.
       NOTE: Still an issue with some characters, i.e. Zrich does not work
       if entered as admin1_name, please use the admin1_code, also shown
       behind the | in the list dialog, e.g. for Zurich, the call hence is
       entity=climada_nightlight_entity('CHE','CHE-176'). Note that the
       admin1_name is kept as on input, i.e. 'CHE-176' in the example, not
       'Zrich'.
   selections: =0 (default): select admin0 (country) and constrain the active
       centroids (with values&ampgt0) to the selected admin1 (state/province)
       add a regular grid outside (to allow e.g for smooth hazard
       intensity plots)
       =10: same as =0, but use 10km instead of 1km night light image
       regular grid outside hence also coarser
       resolution. See also remark about using -(selections) below.
       =1: select admin0 (full country), not admin1 (country
       state/province). The assets are scaled using climada_entity_value_GDP_adjust
       Note that selections=1 might lead to memory issues for large(r)
       countries, see option =2 or =10, too. This usage gets close to
       climada_create_GDP_entity.
       =2: select admin0 (like =1) and do not constrain the active
       centroids (with values&ampgt0) to the selected country (good for initial
       test and speedup, but less useful as an entity for damage
       calculation later).
       =3: select admin1 and do not constrain the active
       centroids (with values&ampgt0) to the selected state/province, see 2.
       &amplt0: If selections is negative, use mid-resolution nightlights (see
       PARAMETER low_img_filename below). Default is high-res (1km).

       In case selection is a vector:
       selections(2)=1 -&ampgt add distance2coast_km (takes time)
       selections(3)=1 -&ampgt add elevation_m (takes time)
   check_plot: if =1: plot nightlight data with admin0 (countries)
       superimposed, if=2 also admin1 (country states/provinces)
       =0: no plot (default)
   scale_Value: =[a b c], scale entity.assets.Value to account for high
       nightlihgt intensity to represent larger share of values, as
       entity.assets.Value =  a + b*entity.assets.Value + c*entity.assets.Value.^2
       If = [a b c d], normalize after scaling and multiply by d. If d is
       negative, scale with country GDP (only makes sense if selections=1
       or =2), but works in other cases, too (as the user might find it
       useful).
       Default= [0 1 0 1e9], except for selections=1, in which case the
       assets are scaled using climada_entity_value_GDP_adjust
   img_filename: the filename of an image with night light density, as
       created using the GUI at http://maps.ngdc.noaa.gov/viewers/dmsp_gcv4/
       and select Satellite F18, 2010, avg_lights_x_pct, then 'Download
       data' and enter the coordinates
       The filename has to be of form A_B_C_D_{|E_F}*..lzw.tiff with A,B,C and D
       the min lon, min lat, max lon and max lat (integer), like
       87_20_94_27_F182010.v4c.avg_lights_x_pct.lzw.tiff and E and F the
       country (admin0) and state/province (admin1) name, like
       -88_24_-79_32_United States of America_Florida_high_res.avg_lights.lzw.tiff

       If empty (eg run the code without any argument), it prompts for country
       and admin1 name and constructs the URL to get the corresponding
       tile from the nightlight data, e.g. a string such as:
       http://mapserver.ngdc.noaa.gov/cgi-bin/public/gcv4/F182010.v4c.
           avg_lights_x_pct.lzw.tif?request=GetCoverage&ampservice=WCS&amp
           version=1.0.0&ampCOVERAGE=F182010.v4c.avg_lights_x_pct.lzw.tif&amp
           crs=EPSG:4326&ampformat=geotiff&ampresx=0.0083333333&ampresy=0.0083333333&amp
           bbox=-88,24,-79,32

       ='ASK' prompt for an image file (without first asking for country
       where one has to press 'Cancel') to get the to filename prompt
   save_entity: whether we save the entity (=1, default) or nor (=0).
 OUTPUTS:
   entity: a full climada entity, see climada_entity_read, plus the fields
       entity.assets.distance2coast_km(i): distance to coast in km (both on-
           and offshore) for each centroid
       entity.assets.elevation_m(i): elevation in m for each centroid,
           negatove for ocean depth (needs climada module etopo, just skips
           this if module not installed)
       entity.assets.admin0_name: country name
       entity.assets.admin0_ISO3: country ISO3 code
       entity.assets.admin1_name: state/province name (if restricted to
           admin1)
       entity.assets.admin1_code: state/province code (if restricted to
           admin1)
       see e.g. climada_entity_plot to check
 RESTRICTIONS:
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20141202
 david.bresch@gmail.com, 20141203, country and admin1 selection
 david.bresch@gmail.com, 20141204, 'ASK' debugged, cleaned up
 david.bresch@gmail.com, 20141205, high-res locally stored
 david.bresch@gmail.com, 20141206, GDP scaling added
 david.bresch@gmail.com, 20141209, admin1 name issue resolved
 david.bresch@gmail.com, 20141212, compatible with new admin0.mat instead of world_50m.gen
 david.bresch@gmail.com, 20141212, renamed to climada_nightlight_entity (formerly climada_high_res_entity)
 david.bresch@gmail.com, 20141215, switch to entity_template.xls
 david.bresch@gmail.com, 20141225, SPECIAL for Alaska in plot (avoid dateline)
 david.bresch@gmail.com, 20141226, distance2coast_km and elevation_m added
 david.bresch@gmail.com, 20160303, 10km resolution: issue fixed, when using .mat file as previously generated by climada_create_GDP_entity
 david.bresch@gmail.com, 20160524, fixed issue with new climada_entity_load (allow for empty assets)
 david.bresch@gmail.com, 20160529, if restricted to values within admin0 or admin1, add a regular grid outside
 david.bresch@gmail.com, 20160603, if admin0 and admin1 names are given on input, restrict admin1 search to within admin0 (logo)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/climada_nightlight_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_entity_assets">
<H2>climada_plot_entity_assets</H2></A>
<font color="blue">function fig = climada_plot_entity_assets(entity,centroids,country_name,check_printplot,printname,keep_boundary) </font>
 climada plot assets from entity file and save if needed
 NAME:
   climada_plot_entity_assets
 PURPOSE:
   plot assets from entity file on a map with different colors to show the
   distribution of assets, print if needed
   normally called from: climada_create_GDP_entity
 CALLING SEQUENCE:
   fig = climada_plot_entity_assets(entity, centroids, country_name, check_printplot)
 EXAMPLE:
   climada_plot_entity_assets(entity, centroids, country_name)
 INPUTS:
   entity          : entity structure, with entity.assets field
   centroids       : centroids mat-file (struct)
       if passed empty, the information is taken from entity.assets
 OPTIONAL INPUT PARAMETERS:
   country_name_str: country name as string format
   check_printplot : 1 for printing (save as pdf), set to 0 by default
   printname       : name for pdf-file, to be saved in .../climada/data/results/Entity_printname.pdf
 OUTPUTS:
   fig             : figure handle
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20140205
 David N. Bresch, david.bresch@gmail.com, 20141127, figure creating suppressed
 David N. Bresch, david.bresch@gmail.com, 20141208, country_name='' as default
 David N. Bresch, david.bresch@gmail.com, 20141209, abort if sum(Values)=0
 Lea Mueller, muellele@gmail.com, 20140205, add keep_boundary option
 Lea Mueller, muellele@gmail.com, 20160318, use climada_colormap('assets')
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/climada_plot_entity_assets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_admin1_risk_calc">
<H2>country_admin1_risk_calc</H2></A>
<font color="blue">function country_risk=country_admin1_risk_calc(country_name,probabilistic,check_plots,peril_ID,admin1_save_entity) </font>
 climada country admin1 risk calc
 MODULE:
   country_risk
 NAME:
   country_admin1_risk_calc
 PURPOSE:
   Run the all (available) perils for one country's admin1 level

   Obtains the admin1 boundaries (from www.naturalearthdata.com, see
   PARAMETERS in code) and carve out the respective centroids (set Value
   at all others to zero). Runs the risk calculation for each admin1 for
   all hazards. In case one would like to skip hazards, just (temporarily)
   remove the respective {country_ISO3}_{country_name}_*.mat hazard event
   sets or see parameter peril_ID. 

   ONLY makes sense if country_risk_calc has been run for the respective
   country (we keep it like this, as automatic mode might trigger lots of
   un-wanted calculations). If not, the code terminates with the
   respective messages (no entity found, no hazard set(s) found...)
   But one can run country_admin1_risk_calc for more than one
   country (see country_name), if the respective countries have been run
   as country_risk_calc.

   NOTE: Before using this code, make yourself familiar with 
   country_risk_calc

   next step: country_risk_report (same format as country_risk_calc)
 CALLING SEQUENCE:
   country_risk=country_admin1_risk_calc(country_name,probabilistic,check_plots,peril_ID,admin1_save_entity)
 EXAMPLE:
   country_risk=country_admin1_risk_calc; % interactive, select country from dropdown
   country_risk=country_admin1_risk_calc('ALL') % whole world, no figures
   country_risk=country_admin1_risk_calc({'Germany','Switzerland'}) % just two countries
 INPUTS:
   country_name: name of the country, like 'Switzerland', or a list of
       countries, like {'Switzerland','Germany','France'}, see
       climada_create_GDP_entity.
       If set to 'ALL', the code runs recursively through ALL countries
       (mind the time this will take...)
       &ampgt prompted for via dropdown list if empty (allows for single or
       multiple country selection)
 OPTIONAL INPUT PARAMETERS:
   probabilistic: Whether we use historic (=0) or probabilistic (=1,
       default) hazard event sets. Obviously depends on what hazard event sets
       have been generated in country_risk_calc
   check_plots: if =1, show figures to check hazards etc.
       If =0, skip figures (default)
       If =100, plot only, skip calculations
       If country_name is set to 'ALL', be careful to set check_plots=1
   peril_ID: if passed on, run all calculations only for specified peril
       Same behaviour as in country_risk_calc, namely:
       peril_ID can be 'TC','TS','TR','EQ','WS'..., default='' for all
       One can also specify the peril region within peril_ID, such as
       'atl_TC' and peril_ID can also contain a list, e.g. peril_ID=['atl_TC';'atl_TS';'EQ'] 
   admin1_save_entity: =1 to save each admin1 entity as single entity file
       Entity file named {country_ISO3}_{country_name}_{admin1_name}_entity.mat
       =0 to omit this (default)
 OUTPUTS:
   country_risk(1): a structure with some risk information, same structure
       as from country_risk_calc, see country_risk_report to create a
       readable report to stdout or file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141126, initial
 David N. Bresch, david.bresch@gmail.com, 20141212, compatible with new admin0.mat instead of world_50m.gen
 David N. Bresch, david.bresch@gmail.com, 20150110, country naming as in country_risk_calc
 David N. Bresch, david.bresch@gmail.com, 20150112, hazard extension '_hist' for historic, '' for probabilistic
 David N. Bresch, david.bresch@gmail.com, 20150112, climada_hazard2octave
 David N. Bresch, david.bresch@gmail.com, 20150714, find admin1 also based on ISO3
 David N. Bresch, david.bresch@gmail.com, 20150803, peril_ID added and admin1_save_entity debugged
 David N. Bresch, david.bresch@gmail.com, 20150803, probabilistic=1 as defaut
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/country_admin1_risk_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_calc">
<H2>country_risk_calc</H2></A>
<font color="blue">function country_risk=country_risk_calc(country_name,method,force_recalc,check_plots,peril_ID,damagefunctions) </font>
 climada
 MODULE:
   country_risk
 NAME:
   country_risk_calc
 PURPOSE:
   run all (available) perils for one country. I.e. generate earthquake
   (EQ), volcano (VQ), tropical cyclone (TC), torrential rain (TR), storm
   surge (TS) and European winter storm (WS) hazard event sets and run
   risk calculation for a given country:  
   1) generate centroids for the country (uses climada_create_GDP_entity)
   2) figure which hazards affect the country
   3) create the hazard event sets, uses
      - climada_tc_hazard_set (wind)
      - climada_tr_hazard_set (rain)
      - climada_ts_hazard_set (surge)
      - eq_global_hazard_set (earthquake)
      - European winter storms (existing European hazard set)
   4) run the risk calculation for all hazards

   NOTE that centroids_generate_hazard_sets is called for steps 2 and 3.
   Note further that should there be more than one source for TC tracks,
   more than one TC hazard set is generated (see centroids_generate_hazard_sets)

   next step: country_risk_report, see also country_admin1_risk_calc and
   esepcially country_risk_calibrate, plus cr_DFC_plot and cr_DFC_plot_aggregate
 CALLING SEQUENCE:
   country_risk=country_risk_calc(country_name,method,force_recalc,check_plots,peril_ID)
 EXAMPLE:
   country_risk0=country_risk_calc('CHE',1,0); % 10x10km resolution for
       % Switzerland, using climada_nightlight_entity (not GDP_entity)
   country_risk0=country_risk_calc('CHE',2,0); % 1x1km resolution for
       % Switzerland, using climada_nightlight_entity
   country_risk0=country_risk_calc('CHE',3,0); % 10x10km resolution for
       % Switzerland, using GDP_entity
   country_risk=country_risk_calc; % interactive, select country from dropdown
   country_risk=country_risk_calc('ALL',1,0,0) % whole world, no figures
   country_risk=country_risk_calc(country_name,-7,0,0,['atl_TC';'atl_TS']) % both TC and TS for atl
 INPUTS:
   country_name: name of the country, like 'Switzerland', or a list of
       countries, like {'Switzerland','Germany','France'}. See
       climada_check_country_name for the list of valid country names
       If set to 'ALL', the code runs recursively through ALL countries
       (mind the time this will take...)
       &ampgt prompted for via dropdown list if empty (allows for single or
       multiple country selection)
 OPTIONAL INPUT PARAMETERS:
   method: =1: use 10km nightlight (climada_nightlight_entity, NOT default)
       =2: use 1km nightlight (climada_nightlight_entity)
       =3: (default) use 10km nightlight (GDP_entity). In this case, USA is
           restricted to contiguous US excl. Alaska and NZL only West of dateline.

       Since the code uses the entity (III_Name, with III Iso3 code and
       Name the country name) if it exists already, the resolution only
       matters on the first call, that's why we can use force_recalc to
       direct resolution. For another entity resolution, delete or rename
       the entity.

       &amplt0: all above options *(-1) trigger the generation of the full
       probabilistic hazard sets (otherwise _hist is added to the hazard
       event sets) 
       =7 (for historic, or -7 to use probabilistic sets): skip entity and
       hazard set generation, straight to damage calculations (this allows
       to avoid any re-generation of - missing - hazard event sets, the
       code just takes what's there). In this case, peril_ID can contain
       the peril region, too, i.e. 'atl_TC' or 'glb_EQ' and peril_ID can
       be a list of IDs, such as peril_ID=['atl_TC';'atl_TS'].

       Internally: if method&amplt0, probabilistic=1, =0 else (default)
       =sign(.)*(abs(.)+100): use future entities, e.g. -107 uses
       future entity, and probabilistic hazards, but skips entity and
       hazard calculation.
       If method has two elements, the second one triggers
       EDS_emdat_adjust, i.e. if method(2)=1, we adjust the EDS by
       comparison with EM-DAT, see cr_EDS_emdat_adjust

       In case method is a vector and abs(method(1)) either 1 or 2:
       method(2)=1 -&ampgt add distance2coast_km (takes time)
       method(3)=1 -&ampgt add elevation_m (takes time)
   check_plot: if =1: plot nightlight data with admin0 (countries)
   force_recalc: if =1, recalculate the hazard sets, even if they exist
       (good for TEST while editing the code, default=0)
   check_plots: if =1, show figures to check hazards etc.
       If =0, skip figures (default)
       If country_name is set to 'ALL', be careful to set check_plots=1
   peril_ID: if passed on, run all calculations only for specified peril
       peril_ID can be 'TC','TS','TR','EQ','WS'..., default='' for all
       Once generated, one can also specify the peril region within
       peril_ID, such as 'atl_TC'. If method=+/-7, peril_ID can also
       contain a list, e.g. peril_ID=['atl_TC';'atl_TS';'EQ']
   damagefunctions: if passed, use damagefunctions instead of the one that
       comes with the entity (or entities). Replaces entity.damagefunctiuons 
       without any further tests. The user is responsible for not messing
       up, i.e. for entity.assets.DamageFunID to point to the right damage
       function, damagefunctions.peril_ID to be consistent with e.g. input
       parameter peril_ID etc.
 OUTPUTS:
   writes a couple files, such as entities and hazard event sets (the
       output to stdout lists all names)
   country_risk(country_i): a structure with some risk information for
       each country (if run eg with 'ALL'), see hazard(hazard_i).EDS
       e.g. plot damage for one hazard in one country at each centroid with
         climada_circle_plot(...
          country_risk(country_i).res.hazard(hazard_i).EDS.ED_at_centroid,...
          country_risk(country_i).res.hazard(hazard_i).EDS.assets.lon,...
          country_risk(country_i).res.hazard(hazard_i).EDS.assets.lat)
       see country_risk_report to create a readable report to stdout
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140831, initial
 David N. Bresch, david.bresch@gmail.com, 20140922, three hazards: TC,TS,TR
 David N. Bresch, david.bresch@gmail.com, 20141020, ready for checkin
 David N. Bresch, david.bresch@gmail.com, 20141025, major cleanup, WS and EQ added
 David N. Bresch, david.bresch@gmail.com, 20141026, probabilistic as input
 David N. Bresch, david.bresch@gmail.com, 20141029, force_re_encoding
 David N. Bresch, david.bresch@gmail.com, 20141103, matching peril_ID for damagefunction added
 David N. Bresch, david.bresch@gmail.com, 20141107, add ncetCFD tc_track file treatment (NCAR) (on flight to Dubai)
 David N. Bresch, david.bresch@gmail.com, 20141126, country list enabled and multiple selection added
 David N. Bresch, david.bresch@gmail.com, 20141222, method parameter simplified (replaces and includes probabilistic)
 David N. Bresch, david.bresch@gmail.com, 20150112, climada_hazard2octave
 David N. Bresch, david.bresch@gmail.com, 20150121, method=7 added
 David N. Bresch, david.bresch@gmail.com, 20150123, distance2coast_km added
 David N. Bresch, david.bresch@gmail.com, 20150213, peril_ID to contain region and multiple perils enabled (if method=+/-7)
 David N. Bresch, david.bresch@gmail.com, 20150819, centroids in their own folder
 Lea Mueller, muellele@gmail.com, 20151021, add climate change option (method=-8) (use hazard TWN_TAIWAN_wpa_TC_cc_2050.mat instead of TWN_TAIWAN_wpa_TC.mat)
 David N. Bresch, david.bresch@gmail.com, 20160303, method as vector added
 David N. Bresch, david.bresch@gmail.com, 20160517, probabilistic based on GDP entity as default
 David N. Bresch, david.bresch@gmail.com, 20160517, enabled use without tropical_cyclone or volcano_earthquake models loaded
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/country_risk_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_calibrate">
<H2>country_risk_calibrate</H2></A>
<font color="blue">function ok=country_risk_calibrate(country_name) </font>
 climada template
 MODULE:
   module name
 NAME:
   country_risk_calibrate
 PURPOSE:
   Calibrate a given country (or a list of countries)
   Call country_risk_calc before

   Standard procedure is that the switch statement below has entries for
   countries (and lists of countries) and hence performs the specific
   actions. Be careful to check for repetitious application. We set the
   field entity.calibrated=1 the first time it is treated here, but since
   one might need to re-calibrate, one should rather assign absolute
   values to e.g. damagefunctions.MDD, since a mere multiplication of
   existing values might lead to troubles on subsequent calls. the code
   climada_damagefunctions_replace does indeed not replace on repetitious
   calls if the result would be exactly the same.

   See also cr_country_hazard_test in order to test country calibration

 CALLING SEQUENCE:
   ok=country_risk_calibrate(country_name)
 EXAMPLE:
   ok=country_risk_calibrate('USA')
 INPUTS:
   country_name: a single country name or a list of countries
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150214, initial
 David N. Bresch, david.bresch@gmail.com, 20150217, Philippines and Taiwan re-adjusted
 David N. Bresch, david.bresch@gmail.com, 20150715, HKG added
 David N. Bresch, david.bresch@gmail.com, 20150803, USA EQ added
 Lea Mueller, muellele@gmail.com, 20151021, add additional countries for phase 2 (Aruba, Barbados, Bermuda, Venezuela, 
            Bahamas, Cook Islands, Guatemala, Honduras, Jamaica, Mozambique, Fiji, Trinidad), calibrated by Jacob Anz
 Lea Mueller, muellele@gmail.com, 20160212, rename to climada_damagefunctionS_generate instead of without s
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/country_risk_calibrate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_report">
<H2>country_risk_report</H2></A>
<font color="blue">function country_risk_report(country_risk,print_format,report_filename,DFC_return_periods,plot_DFC) </font>
 climada
 MODULE:
   country_risk
 NAME:
   country_risk_report
 PURPOSE:
   produce a report (country, peril, damage) based on the results from
   country_risk_calc and country_admin1_risk_calc

   previous call: country_risk_calc and/or country_admin1_risk_calc
   see also: country_risk_report_raw for a raw report (to stdout)
 CALLING SEQUENCE:
   country_risk_report(country_risk,print_format,report_filename,DFC_return_periods,plot_DFC)
 EXAMPLE:
   country_risk_report(country_risk_calc('Barbados')); % all in one

   country_risk0=country_risk_calc('Switzerland'); % country, admin0 level
   country_risk1=country_admin1_risk_calc('Switzerland'); % admin1 level
   country_risk_report([country_risk0 country_risk1]) % report all
   country_risk_report(country_risk,1,'',-250) % only 250yr RP
 INPUTS:
   country_risk: a structure with the results from country_risk_calc
 OPTIONAL INPUT PARAMETERS:
   print_format: =1, report damages in the order they have been calculated
       =2 show by descending damages (default)
       if negative, omit reporting all to stdout
       =0, call country_risk_report_raw (one line with ED per country)
   report_filename: the filename of the Excel file the report is written
       to. Prompted for if not given (if Cancel pressed, write to stdout only)
   DFC_return_periods: damage frequency curve return periods, define the
       return periods we report damage for set =[] to report expected damage
       (ED) only (note that the ED will be denoted as return period=0 in the
       report). Default: DFC_return_periods=[100 250];
       If you set DFC_return_periods to a negative valiue, ONLY that
       return peirod will be reported (no ED, expected damage). Useful if
       e.g. only 100yr damage is of interest (and hence sorting
       descedingly by 100yr return period works, if print_format=2
       Note: DFC_return_periods are not passed on in the old version
       (print_format=0)
   plot_DFC: if =1, plot damage frequency curves (DFC) of all EDSs (!) in
       country_risk, =0 not (default)
       if =2, plot logarithmic scale both axes
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141209, initial
 David N. Bresch, david.bresch@gmail.com, 20141211, header added to Excel report
 David N. Bresch, david.bresch@gmail.com, 20150715, bug fix for empty EDS (e.g. if combine EDS is called prior to report)
 David N. Bresch, david.bresch@gmail.com, 20150715, empty EDS not reported any more
 David N. Bresch, david.bresch@gmail.com, 20150815, option to only report one single RP (no ED)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/country_risk_report.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_report_raw">
<H2>country_risk_report_raw</H2></A>
<font color="blue">function country_risk_report_raw(country_risk,print_unsorted,plot_DFC) </font>
 climada
 MODULE:
   country_risk
 NAME:
   country_risk_report_raw
 PURPOSE:
   produce a quick&ampdirty report based on the results from
   country_risk=country_risk_calc

   previous call: country_risk_calc and country_admin1_risk_calc
   see also: country_risk_report
 CALLING SEQUENCE:
   country_risk_report_raw(country_risk,print_unsorted,plot_DFC)
 EXAMPLE:
   country_risk_report_raw(country_risk_calc('Barbados')); % all in one

   country_risk0=country_risk_calc('Switzerland'); % country, admin0 level
   country_risk1=country_admin1_risk_calc('Switzerland'); % admin1 level
   country_risk_report([country_risk0 country_risk1]) % report all
 INPUTS:
   country_risk: a structure with the results from country_risk_calc
 OPTIONAL INPUT PARAMETERS:
   print_unsorted: =1, show the results in the order they have been calculated
       =0, show by descending damages (default)
   plot_DFC: if =1, plot damage frequency curves (DFC) of all EDSs (!) in
       country_risk, =0 not (default)
       if =2, plot logarithmic scale both axes
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141024, initial
 David N. Bresch, david.bresch@gmail.com, 20141025, cleanup of country_risk_report
 David N. Bresch, david.bresch@gmail.com, 20141209, renamed to country_risk_report_raw
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/country_risk_report_raw.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="country_risk_waterfall">
<H2>country_risk_waterfall</H2></A>
<font color="blue">function [entity, entity_future, DFC, DFC_eco, DFC_cc] = country_risk_waterfall(country_name,annual_eco_growth) </font>
 country_risk_waterfall(country_name,annual_eco_growth)
 MODULE:
   country risk
 NAME:
   country_risk_waterfall
 PURPOSE:
   Produce waterfall graph for a specific country, using the precalculated
   hazards (TC, TS, TC_cc_2050, TS_cc_2050) and entity (entity today)
 CALLING SEQUENCE:
   country_risk_waterfall(country_name,annual_eco_growth)
 EXAMPLE:
   country_risk_waterfall('Mexico',0.04)
   country_risk_waterfall({'Mexico'; 'Aruba'},0.04)
   country_risk_waterfall('ALL',0.04)
 INPUTS:
   country_name: name of the country, like 'Switzerland', or a list of
       countries, like {'Switzerland','Germany','France'}. See
       climada_check_country_name for the list of valid country names
       If set to 'ALL', the code runs recursively through ALL countries
       (mind the time this will take...)
       &ampgt prompted for via dropdown list if empty (allows for single or
       multiple country selection)
 OPTIONAL INPUT PARAMETERS:
   annual_eco_growth: annual economic growth, e.g. 0.04 for 4% growth for 
       a developing country, and 0.01 for a developed country 
 OUTPUTS:
   entity: entity structure with today's values
   entity_future: entity structure with future values
   DFC: damage frequency curve with 250 year damage for today's values
   DFC_eco: 250 year damage for economic growth
   DFC_cc: 250 year damage for economic growth and climate change
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151029, initial
 Lea Mueller, muellele@gmail.com, 20151105, call climada_entity_scaleup_factor for future entity and add output variables
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/country_risk_waterfall.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="emdat_read">
<H2>emdat_read</H2></A>
<font color="blue">function em_data=emdat_read(emdat_file,country_name,peril_ID,exposure_growth,verbose_mode,CAGR) </font>
 climada template
 MODULE:
   country_rsk
 NAME:
   emdat_read
 PURPOSE:
   Read EM-DAT database (www.emdat.be and www.emdat.be/explanatory-notes)
   from the file {country_risk_module}/data/emdat/emdat.xls

   Please note that the EM-DAT database does NOT contain its reference
   date (i.e. the last year it contains data for, see EMDAT_last_year
   in PARAMETERS)

   If requested, index past damages according to GDP (see
   exposure_growth). This feature needs t GDP_entity module to exist

   Also produce a damage frequency curve (DFC) in order to ease comparison with
   climada results, especially if EM-DAT data is filtered by country (see
   input country_name) and peril (see input peril_ID).
   Use e.g. plot(em_data.DFC.return_period,em_data.DFC.damage) to plot the
   damage excess frequency curve based on EM-DAT.

 CALLING SEQUENCE:
   em_data=emdat_read(emdat_file,country_name,peril_ID,exposure_growth,verbose_mode)
 EXAMPLE:
   em_data=emdat_read('','United States','TC');
 INPUTS:
   emdat_file: filename of the emdat database
       Default (='' or no input at all) is full global EM-DAT database, 
       see PARAMETERS for its default location
       if ='ASK', prompt for
 OPTIONAL INPUT PARAMETERS:
   country_name: if provided, only return records for specific country - r
   for the list of countries, if provided as cell, i.e. {'Vanuata','Aruba'}
       default: all countries
   peril_ID: if provided, only return records for specific peril,
       currently implemented are
       - 'TC': tropical cyclone, returns records with disaster subtype='Tropical cyclone'
       - 'TS': tropical cyclone surge, returns records with disaster subtype='Coastal flood'
       - 'FL': flood, returns records with disaster subtype='Riverine flood'
       - 'WS': winter storm, returns records with disaster subtype='Extra-tropical s'
       - 'EQ': earthquake, returns records with disaster subtype='Ground movement'
       - or just any of the disaster subtypes in EM-DAT, e.g. 'Tsunami'. You
         might use em_data=emdat_read('','China','',0,1); to get a list of all
         available disaster subtypes in China
       Default: all perils (i.e. all disaster subtypes)
   exposure_growth: =1: correct damage numbers to account for exposure
       growth (the field em_data.damage_orig contains the uncorrected numbers
       Only works if a single country is requested, i.e. if country_name
       is specified. In essence, we calculate the correction factor for
       year i as GDP(today)/GDP(year i)
       =0: no correction (default)
   verbose_mode: if =1, print list of countries and disaster subtypes that
       are returned in em_data. Default=0 (silent)
   CAGR: the compound annual growht rate (decimal). If not specified, the
       GDP development of thw past is used to index damages, and a CAGR
       default is used where no GDP exists (see PARAMETERS section, CAGR set
       to 0.02).
 OUTPUTS:
   em_data, a structure with (for each event i)
       filename: the original filename with EM-DAT fata
       year(i): the year (e.g. use hist(em_data.year) to get a feel...)
       disaster_type{i}: disaster type i, see www.emdat.be/explanatory-notes
       disaster_subtype{i}: disaster subtype i, see www.emdat.be/explanatory-notes
       occurrence(i): see www.emdat.be/explanatory-notes
       deaths(i): see www.emdat.be/explanatory-notes
       affected(i): see www.emdat.be/explanatory-notes
       injured(i): see www.emdat.be/explanatory-notes
       homeless(i): see www.emdat.be/explanatory-notes
       damage(i): the damage in USD (in units of 1 USD)
           Note that EM-DAT estimated damage in the database are given in
           US$ (?000), hence we multiply by 1000.
       damage_orig(i): the uncorrected damage in case exposure_growth=1
       frequency(i): the frequency of eaxch event (once in the years the
           database exists for)
       DFC: the damage frequency curve, a structure, see e.g.
           climada_EDS2DFC for this structures's fields, e.g.
           DFC.return_period and DFC.damage
       DFC_orig: the DFC of the original damages in case exposure_growth=1
       YDS: the year damage set, just plain summation of all damages in
           one year, use climada_EDS2DFC(em_data.YDS) to plot...
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150126, initial, Sils Maria
 David N. Bresch, david.bresch@gmail.com, 20150207, list of countries accepted
 David N. Bresch, david.bresch@gmail.com, 20150208, YDS added
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/emdat_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="selected_countries_all_in_one">
<H2>selected_countries_all_in_one</H2></A>
 selected_countries_all_in_one
 climada template
 MODULE:
   module name
 NAME:
   selected_countries_all_in_one, run all project countries, all calculations

   run as a batch code, such that all is available on command line
 PURPOSE:
   Run all climada for project

   In order to synchronize all entities with GDP etc, country_risk_calc
   uses climada_entity_value_GDP_adjust

 CALLING SEQUENCE:
   selected_countries_all_in_one
 EXAMPLE:
   selected_countries_all_in_one
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150105
 David N. Bresch, david.bresch@gmail.com, 20150116, almost complete
 David N. Bresch, david.bresch@gmail.com, 20150121, GDP adjust added
 David N. Bresch, david.bresch@gmail.com, 20150121, GDP adjust added
 David N. Bresch, david.bresch@gmail.com, 20150215, country calibration added at the bottom (all commented out, see there)
 David N. Bresch, david.bresch@gmail.com, 20150225, figure name added
 David N. Bresch, david.bresch@gmail.com, 20150815, latest country list and report only for 250yr event
 David N. Bresch, david.bresch@gmail.com, 20150815, WARNING: cr_EDS_adjust_all and country_risk_EDS2YDS switched off for now
 David N. Bresch, david.bresch@gmail.com, 20150819, centroids in their own dir
 Lea Mueller, muellele@gmail.com, 20151021, add climate change calculations (country_risk_calc_method=-8)
 Lea Mueller, muellele@gmail.com, 20151021, use country_list for phase1+phase2
 David N. Bresch, david.bresch@gmail.com, 20160322, country_list for TEST phase3 (US admin1)
 David N. Bresch, david.bresch@gmail.com, 20160324, small edit
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/country_risk/code/selected_countries_all_in_one.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="bf_TEST">
<H2>bf_TEST</H2></A>
 bf_TEST: bushfire TEST batch file 
 MODULE:
   drought_fire
 NAME:
   bf_TEST
 PURPOSE:
   TEST bushfire module
   
   Uses TEST data within the module's data folder (and subfolders). For
   operational use, use the standard climada data folder (see
   climada_global.data_dir), i.e. copy centrpids, entities etc. to the
   respective sub-folders there.

   please refer to the main code climada_bf_hazard_set
 CALLING SEQUENCE:
   bf_TEST
 EXAMPLE:
   bf_TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
 MODIFICATION HISTORY:
 beuschl@student.ethz.ch, 20160601, initial, key author
 horatc@student.ethz.ch, 20160601, initial, key author
 david.bresch@gmail.com, 20160601, climada-compatibility
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/drought_fire/code/bf_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="bf_generator">
<H2>bf_generator</H2></A>
<font color="blue">function bf=bf_generator(number_years,store_intensity_field) </font>
 BF event probabilistic
 MODULE:
   drought_fire
 NAME:
   bf_generator
 PURPOSE:
   generate a hazard event set of bushfires for a specified number of
   years and domain. It is currently set up for the region of Melbourne
   with corresponding data. Next step: climada_bf_hazard_set.m
 CALLING SEQUENCE:
   bf_generator(number_years);
 EXAMPLE:
   bf_generator(5);
 INPUTS:
   number_years: how many years of bushfire you want to simulate
   store_intensity_field: if non-zero: matrix of size dx times dy, 
   bf(i).intensity_field, is stored for all fires. for each fire, fire then 
   can easily be plotted with for instance contourf(bf(1).intensity_field). 
   if 0: matrix bf(i).intensity_field is not stored.
   note: for many years, intensity_field must be set to 0, because not
   enough memory capacity!
 OPTIONAL INPUT PARAMETERS:
   none 
 OUTPUTS: 
   a struct bf where bf(i) is one individual fire:
   with bf(i).lon: array with longitudes of intensities
   with bf(i).lat: array with latitudes of intensities
   with bf(i).intensity: array with intensities at locations (bf(i).lon, bf(i).lat)
   with bf(i).no_year: number of years simulated
   with bf(i).intensity_field: matrix of size dx times dy which contains
   intensities - note: only needed for plots. comment otherwise  needs a 
   lot of memory (see below)
 MODIFICATION HISTORY:
 beuschl@student.ethz.ch, 20160601, initial, key author
 horatc@student.ethz.ch, 20160601, initial, key author
 david.bresch@gmail.com, 20160601, climada-compatibility
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/drought_fire/code/bf_generator.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="bf_generator2">
<H2>bf_generator2</H2></A>
<font color="blue">function bf=bf_generator2(number_years,store_intensity_field) </font>
 BF event probabilistic
 MODULE:
   drought_fire
 NAME:
   bf_generator
 PURPOSE:

   TEST versin to improove speed, dbresch

   generate a hazard event set of bushfires for a specified number of
   years and domain. It is currently set up for the region of Melbourne
   with corresponding data. Next step: climada_bf_hazard_set.m
 CALLING SEQUENCE:
   bf_generator(number_years);
 EXAMPLE:
   bf_generator(5);
   bf_generator(0.01,1): % fast test
 INPUTS:
   number_years: how many years of bushfire you want to simulate
   store_intensity_field: if non-zero: matrix of size dx times dy,
   bf(i).intensity_field, is stored for all fires. for each fire, fire then
   can easily be plotted with for instance contourf(bf(1).intensity_field).
   if 0: matrix bf(i).intensity_field is not stored.
   note: for many years, intensity_field must be set to 0, because not
   enough memory capacity!
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   a struct bf where bf(i) is one individual fire:
   with bf(i).lon: array with longitudes of intensities
   with bf(i).lat: array with latitudes of intensities
   with bf(i).intensity: array with intensities at locations (bf(i).lon, bf(i).lat)
   with bf(i).no_year: number of years simulated
   with bf(i).intensity_field: matrix of size dx times dy which contains
   intensities - note: only needed for plots. comment otherwise  needs a
   lot of memory (see below)
 MODIFICATION HISTORY:
 beuschl@student.ethz.ch, 20160601, initial, key author
 horatc@student.ethz.ch, 20160601, initial, key author
 david.bresch@gmail.com, 20160601, climada-compatibility
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/drought_fire/code/bf_generator2.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="bf_generator_large">
<H2>bf_generator_large</H2></A>
<font color="blue">function hazard=bf_generator_large(csv_file,centroids,hazard_set_file) </font>
 climada template
 MODULE:
   drought_fire
 NAME:
   bf_generator_large
 PURPOSE:
   Process the MODIS5 firms data in order to generate large fires.
   See also bf_generator_small to generate small fires (using a cellular
   automat)

   Please proceed as follows:
   0. run bf=bf_generator_large('TEST') to test whether all works
      This generates a _TEST_BF_hazard_large hazard set
   1. Download the historic fire data (since Nov 2000-today) as .csv file
      from https://firms.modaps.eosdis.nasa.gov/download (the full global
      dataset since 2000 is too large for a single download) and store the
      .csv file as ....
   2. run bf_generate_large to process the data (calls firms_read) and to
      generate the bushfire hazard event set

   previous call: generate an entity, see e.g. climada_nightlight_entity,
   climada_srtm_entity or climada_GDP_entity (all in
   https://github.com/davidnbresch/climada_module_country_risk)
   next call: e.g. climada_EDS_calc

   Citation for both MCD14DL and MCD14ML: This data set was
   provided by the University of Maryland and NASA FIRMS operated by
   NASA/GSFC/ESDIS with funding provided by NASA/HQ
 CALLING SEQUENCE:
   hazard=bf_generator_large(csv_file,param2)
 EXAMPLE:
   hazard=bf_generator_large('TEST') % use the TEST dataset
 INPUTS:
   csv_file: the name and path of the .csv file as downloaded from
       https://firms.modaps.eosdis.nasa.gov/download
       &ampgt promted for filename for if not given
       for TESTS, there is a .csv file for Australia in the drought_fire
       module's data folder, just set csv_file='TEST'. In this case, test
       centroids are used, too.
   centroids: a centroids structure (see climada_centroids_read) or an
       entity structure (in which case entity.assets.lon and .lat are used)
       &ampgt promted for if empty
   hazard_set_file: the filename (and path, optional) of the hazard
       event set. If no path provided, default path ../data/hazards is used
       (and name can be without extension .mat)
       &ampgt promted for if empty
 OPTIONAL INPUT PARAMETERS:
   param2: as an example
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       intensity(event_i,centroid_i), sparse: the hazard intensity of
           event_i at centroid_i
       frequency(event_i): the frequency of each event
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20160703
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/drought_fire/code/bf_generator_large.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_bf_hazard_set">
<H2>climada_bf_hazard_set</H2></A>
<font color="blue">function hazard=climada_bf_hazard_set(bf,centroids,fscrew,areascrew,hazard_set_file) </font>
 climada template
 MODULE:
   drought_fire
 NAME:
   climada_bf_hazard_set
 PURPOSE:
   Generate a BF (bushfire) hazard event set. 

   The TEST case for average fires in Victoria, Australia, see code bf_TEST

   Each fire is attributed to 1 centroid (valid for centroids down to 10km
   resolution, revise if using 1km or finer).

   previous: likely climada_bf_generator.m
   next: e.g climada_EDS_calc
 CALLING SEQUENCE:
   hazard = climada_bf_hazard_set(bf,centroids,fscrew,areascrew,hazard_set_file);
 EXAMPLE:
   hazard = climada_bf_hazard_set;
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   bf: file containing lon, lat, intentsity of each wildfire and number
       of years simulated (the 'proto-hazard set')
   centroids:  centroids in my domain (to contribute intensity to)
   fscrew:     to account for climate change: constant factor I multiply
               frequency with -&ampgt if empty set to 1 by default -&ampgt input in
               format 1+%increase -&ampgt eg for 30% increase fscrew = 1.3
   areascrew:  to account for climate change: constant factor I multiply
               affected area with -&ampgt if empty set to 1 by default -&ampgt input
               in format 1+%increase -&ampgt eg for 30% increase areascrwe = 1.3
 OUTPUTS:
 MODIFICATION HISTORY:
 beuschl@student.ethz.ch, 20160601, initial, key author
 horatc@student.ethz.ch, 20160601, initial, key author
 david.bresch@gmail.com, 20160601, climada-compatibility
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/drought_fire/code/climada_bf_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="firms_read">
<H2>firms_read</H2></A>
<font color="blue">function firms=firms_read(csv_file,check_plot) </font>
 climada template
 MODULE:
   module name
 NAME:
   firms_read
 PURPOSE:
   Read the MODIS5 firms csv data

   Please proceed as follows:
   1. Download the historic fire data (since Nov 2000-today) as .csv file
      from https://firms.modaps.eosdis.nasa.gov/download (the full global
      dataset since 2000 is too large for a single download) and store the
      .csv file as ....
   2. run firms_read to read the data

   next call: bf_generator_large

   Citation for both MCD14DL and MCD14ML: This data set was
   provided by the University of Maryland and NASA FIRMS operated by
   NASA/GSFC/ESDIS with funding provided by NASA/HQ
 CALLING SEQUENCE:
   firms=firms_read(csv_file,check_plot)
 EXAMPLE:
   firms=firms_read('TEST') % use the TEST dataset
 INPUTS:
   csv_file: the name and path of the .csv file as downloaded from
       https://firms.modaps.eosdis.nasa.gov/download
       &ampgt promted for filename for if not given
       for TESTS, there is a .csv file for Australia in the drought_fire
       module's data folder, just set csv_file='TEST'
 OPTIONAL INPUT PARAMETERS:
   param2: as an example
 OUTPUTS:
   firms: the data, a structure with fields
       filename: the original .csv filename with path
       lat(i): latitudes of burning point i
       lon(i): longitudes of burning point i
       brightness(i): brightness of burning point i
       datenum(i): the matlab datenum for each point i, also
           datenum_unique: the unique datenums
           unique_IA: the positions of the first unique elements
           unique_IC: the output of [~,IA,IC]=unique
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20160703, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/drought_fire/code/firms_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="MMI_attenuation_calc">
<H2>MMI_attenuation_calc</H2></A>
<font color="blue">function MMI = MMI_attenuation_calc(mag, dist, dep, correction, a1, a2, a3, a4, b) </font>
 Calculate the attenuation of an earthquake's intensity with distance from
 the epicenter
 MODULE:
 eq_global
 NAME:
   simple_eq_MMI
 PURPOSE:
   calculate MMI at a given distance from the epicenter 
 CALLING SEQUENCE:
   MMI=MMI_attenuation_calc(mag, dist, correction,a1, a2, a3, a4)
 EXAMPLE:
   MMI=MMI_attenuation_calc(7.44,10.0,1.67,1.67,1.3,0.0026);
   MMI=MMI_attenuation_calc(8,15.5)   % using default values for
   depth, correction and the attenuation parameters a1, a2, a3, a4, 
 INPUTS:
   mag:    magnitude
   dist:   distance to epicentre [in km] 
 OPTIONAL INPUTS:
   dep: epicenter depth
   correction, a1,a2,a3,a4,b: parameters defining an attenuation function
   of the type MMI = a1 + a2*mag - a3*log(dist+correction) - a4*dist + b*dep
   where MMI is the Modified Mercalli Intensity at distance dist from the 
   epicenter and dep is the epicenter depth; log denotes the natural
   logarithm
   Have a look at eq_global-master/data/system/attenuation_parameters.xlsx 
   for a compilation of parameters for selected geographic regions
 OUTPUT:
   MMI:    the MMI at distance dist from the epicenter (Modified Mercalli
   Intensity)
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141116
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141209, added correction parameter
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150118, minor clean-up, renaming
% default values for attenuation parameters: dep, correction, a1, a2, a3, a4, b
f ~exist('dep','var') || isempty(dep), dep = 0; end
f ~exist('correction','var') || isempty(correction), correction = 0; end
f ~exist('a1','var') || isempty(a1), a1 = 1.7; end
f ~exist('a2','var') || isempty(a2), a2 = 1.5; end
f ~exist('a3','var') || isempty(a3), a3 = 1.1726; end
f ~exist('a4','var') || isempty(a4), a4 = 0.00106; end
f ~exist('b','var') || isempty(b), b = 0; end
% compute the attenuation equation 
 MMI is kept below a maximum value defined by the equation 
 I_0 = 1.5*(mag - 1), where I_0 is the epicentral intensity (in MMI)
 and mag the Richter magnitude of the earthquake
 Source: Y-X. Hu, S-C. Liu, W. Dong: Earthquake Engineering
aximum_MMI = 1.5*(mag-1);
MI = a1 + a2 * mag - a3 * log(dist+correction) - a4 * dist + b*dep;
f MMI &ampgt maximum_MMI, MMI = maximum_MMI; end
nd
       


View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/MMI_attenuation_calc.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_get_single_event">
<H2>climada_get_single_event</H2></A>
<font color="blue">function single_eq_event = climada_get_single_event(eq_data, event_i) </font>
 get single earthquake event
 MODULE:
 eq_global
 NAME:
   climada_get_single_event
 PURPOSE:
   Extract a single event from a set of hazards
 PREVIOUS STEP:
   Generation of a hazard set, either by reading a set of historic hazard
   events (see eq_isc_gem_read) or by creating a probabilistic hazard
   event set based on a historic event set (see eq_global_probabilistic)
 INPUTS:
   eq_data, a structure with the following fields:
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude
       country(line_i): country
   event_i: number of the event to be extracted from eq_data. If not
   given, event_i is set to 1
 OUTPUT:
   single_event: a structure with the same fields as eq_data, but 
   containing only the data for the (event_i)th hazard in eq_data
 CAUTIONARY NOTE: 
   This code has only been written for testing purposes
   (namely as a helper function for validate_eq_damage) and might need 
   some improvements for general use
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141213, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/climada_get_single_event.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_centennial_read">
<H2>eq_centennial_read</H2></A>
<font color="blue">function eq_data=eq_centennial_read(centennial_file,check_plot) </font>
 Read Centennial Earthquake Database
 MODULE:
 eq_global
 NAME:
   eq_centennial_read
 PURPOSE:
   Read earthquake (EQ) database, a raw text file downloaded from
   earthquake.usgs.gov/data/centennial/ usually the file
   http://earthquake.usgs.gov/data/centennial/centennial_Y2K.CAT
   
   see the associated readme at
   http://earthquake.usgs.gov/data/centennial/centennial_README.rtf

   next step: see eq_global_probabilistic
 CALLING SEQUENCE:
   eq_data=eq_centennial_read(centennial_file,check_plot)
 EXAMPLE:
   eq_data=eq_centennial_read('',1) % read std file, show epicenters plot
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centennial_file: the filename of the ASCII text file with the raw data
       if empty, the code tries a default name, if it does not exist, it
       promptes the user to locate the file
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude
   also stored as .mat file. Please delete the .mat file manually in order
   to re-read from the original .txt file 
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141010, initial
 David N. Bresch, david.bresch@gmail.com, 20141014, some minor improvements
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/eq_centennial_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_attenuation">
<H2>eq_global_attenuation</H2></A>
<font color="blue">function intensity_at_centroids = eq_global_attenuation(glat,glon,mag,centroids,check_plot,dep,correction,a1,a2,a3,a4,b) </font>
 Calculate the attenuation of an earthquake's intensity with
 increasing distance from the epicenter
 MODULE:
 eq_global
 NAME:
   eq_global_attenuation
 PURPOSE:
   given an earthquake (EQ) epicenter, defined by glat,glon,dep,mag,
   calculate the resulting intensity at a set of centroids, using an attenuation
   function. Distance is on sphere iro correction for latitude, but no
   great circle distance (for speedup reasons, other errors are bigger).

   In order to speed up the calculation, no consistency checks are done,
   code assumes proper glat,glon,dep,mag and reasonable centroids input

   For basic theory, see e.g. https://en.wikipedia.org/wiki/Peak_ground_acceleration

   To test attenuation functions, see eq_global_attenuation_TEST
   then edit between *********** lines beow

   mainly called from: eq_global_hazard_set
 CALLING SEQUENCE:
   intensity_at_centroids = eq_global_attenuation(glat,glon,dep,mag,centroids,check_plot,a1,a2,a3,a4)
 EXAMPLE:
   for an earthquake in Vancouver, Canada:
   glat=49.25;glon=-123.10;
   intensity_at_centroids = eq_global_attenuation(glat,glon,5,6,centroids,0,1,2.4,1.5,1.13,0.0063)
   The parameters a1=2.4, a2=1.5, a3=1.13, a4=0.0063 describe the
   attenuation function for Western Canada; see
   eq_global-master/data/system/attenuation_parameters.xlsx
 INPUTS:
   glat: latitude of epicenter [in degrees]
   glon: longitude of epicenter [in degrees]
   dep: depth [km] of epicenter
   mag: magnitude (Richter) of epicenter
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
   correction,a1,a2,a3,a4,b: parameters defining the attenuation function. 
   See eq_global-master/data/system/attenuation_parameters.xlsx to use
   parameters for specific regions; otherwise default values representing
   a &quotglobal average attenuation function&quot will be used
   check_plot: =1, if a check plot shall be drawn (default=0)
 OUTPUTS:
   intensity_at_centroids: the MMI at centroids
 RESTRICTIONS:
   code does not quality or even consistency checks, optimized for speed.
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141013
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141106
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/eq_global_attenuation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_attenuation_TEST">
<H2>eq_global_attenuation_TEST</H2></A>
<font color="blue">function eq_global_attenuation_TEST </font>
 eq attenuation test
 NAME:
   eq_global_attenuation_TEST
 PURPOSE:
   Test different attenuation functions

   all set in code to allow for maximum flexibility

 CALLING SEQUENCE:
   eq_global_attenuation_TEST
 EXAMPLE:
   eq_global_attenuation_TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   plots attenuation function
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141016
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/eq_global_attenuation_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_hazard_set">
<H2>eq_global_hazard_set</H2></A>
<font color="blue">function hazard=eq_global_hazard_set(eq_data,hazard_set_file,centroids,TEST_epicenter_preselection,correction,a1,a2,a3,a4,b) </font>
 Create earthquake hazard set
 MODULE
 eq_global
 NAME:
   eq_global_hazard_set
 PURPOSE:
   generate an earthqake (EQ) hazard event set, starting from epicenters
   calculating attenuation (distance and depth) to convert Richter
   magnitude to a modified Mercalli intensity (MMI)

   previous step: see eq_global_probabilistic or eq_isc_gem_read (or
   eq_centennial_read, or eq_signieq_read)
 CALLING SEQUENCE:
   
   hazard=eq_global_hazard_set(eq_data,hazard_set_file,centroids)
 EXAMPLE:
   eq_data=eq_global_probabilistic(eq_isc_gem_read); % global
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   hazard=eq_global_hazard_set(eq_data,'_EQ_TEST',centroids);
   %hazard=eq_global_hazard_set(eq_global_probabilistic(eq_isc_gem_read))
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   eq_data: a structure with EQ epicenters, see eq_isc_gem_read
       &ampgt promted for if not given
   hazard_set_file: the name and path of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes
           Latitude(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used
       (TEST mode), see hard-wired definition in code (a rectangular area in California)
   TEST_epicenter_preselection: whether we show the epicenters selected
       for processing (=1) or not (=0, default)
       if =2, STOP after plot of preselection (to check preselection only)
   correction,a1,a2,a3,a4,b: parameters defining the attenuation function. See
       eq_global-master/data/system/attenuation_parameters.xlsx to use
       parameters for specific regions; otherwise the function
       eq_global_attenuation will use default values that represent a &quotglobal
       average attenuation function&quot
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'EQ' for
       earthquake
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)

   simple check for hazard content: hist(full(hazard.intensity(find(hazard.intensity))))
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141012
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141223, added correction,a1,a2,a3,a4
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150120, hazard_arr_density=0.01
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, parfor speedup, factor 3-5
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/eq_global_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_hazard_set_slow">
<H2>eq_global_hazard_set_slow</H2></A>
<font color="blue">function hazard=eq_global_hazard_set_slow(eq_data,hazard_set_file,centroids,TEST_epicenter_preselection,correction,a1,a2,a3,a4,b) </font>
 Create earthquake hazard set
 MODULE
 eq_global
 NAME:
   eq_global_hazard_set
 PURPOSE:
   SLOW version of eq_global_hazard_set

   generate an earthqake (EQ) hazard event set, starting from epicenters
   calculating attenuation (distance and depth) to convert Richter
   magnitude to a modified Mercalli intensity (MMI)

   previous step: see eq_global_probabilistic or eq_isc_gem_read (or
   eq_centennial_read, or eq_signieq_read)
 CALLING SEQUENCE:
   hazard=eq_global_hazard_set_slow(eq_data,hazard_set_file,centroids)
 EXAMPLE:
   hazard=eq_global_hazard_set_slow(eq_global_probabilistic(eq_isc_gem_read))
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   eq_data: a structure with EQ epicenters, see eq_isc_gem_read
       &ampgt promted for if not given
   hazard_set_file: the name and path of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes
           Latitude(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used
       (TEST mode), see hard-wired definition in code (a rectangular area in California)
   TEST_epicenter_preselection: whether we show the epicenters selected
       for processing (=1) or not (=0, default)
       if =2, STOP after plot of preselection (to check preselection only)
   correction,a1,a2,a3,a4,b: parameters defining the attenuation function. See
       eq_global-master/data/system/attenuation_parameters.xlsx to use
       parameters for specific regions; otherwise the function
       eq_global_attenuation will use default values that represent a &quotglobal
       average attenuation function&quot
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'EQ' for
       earthquake
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)

   simple check for hazard content: hist(full(hazard.intensity(find(hazard.intensity))))
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141012
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141223, added correction,a1,a2,a3,a4
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150120, hazard_arr_density=0.01
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, renamed to eq_global_hazard_set_slow
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/eq_global_hazard_set_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_global_probabilistic">
<H2>eq_global_probabilistic</H2></A>
<font color="blue">function eq_data=eq_global_probabilistic(eq_data_in,ens_size,check_plot) </font>
 generate probabilistic hazard set
 MODULE:
 eq_global
 NAME:
   eq_global_probabilistic
 PURPOSE:
   Given an earthquake(EQ) database, create a probabilistic version by
   wiggling location, depth and magnitudes of epicenters

   previous step: see eq_isc_gem_read, eq_centennial_read, or eq_signigeq_read
   next step: see eq_global_hazard_set
 CALLING SEQUENCE:
   eq_data=eq_global_probabilistic(eq_data_in,check_plot)
 EXAMPLE:
   eq_data=eq_global_probabilistic(eq_centennial_read,9,1)
 INPUTS:
   eq_data_in: an EQ database, see eq_centennial_read
 OPTIONAL INPUT PARAMETERS:
   ens_size: ensemble size, the number of 'copies' of the original
       database we create, default=9 (means 10x as original data)
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141010, initial
 David N. Bresch, david.bresch@gmail.com, 20160423, rand('seed',0) --&ampgt rng(0)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/eq_global_probabilistic.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_isc_gem_read">
<H2>eq_isc_gem_read</H2></A>
<font color="blue">function [eq_data,isc_gem_file_mat]=eq_isc_gem_read(isc_gem_file,check_plot) </font>
 read ISC-GEM earthquake catalogue
 EQ eq data read
 NAME:
   isc_gem_read
 PURPOSE:
   Read earthquake (EQ) database, a .csv file downloaded from
   www.isc.ac.uk/iscgem/download.php
   for further information on the earthquake catalogue, see
   www.isc.ac.uk/iscgem/index.php

   Note: it can sometimes happen that the original epicenters file
   isc-gem-cat.csv gets currupted. Just donwload it from
   www.isc.ac.uk/iscgem/download.php (or directly
   http://colossus.iris.washington.edu/iscgem/download/isc-gem-cat.zip)
   again. 

   next step: see eq_global_probabilistic
 CALLING SEQUENCE:
   [eq_data,isc_gem_file_mat]=eq_isc_gem_read(isc_gem_file,check_plot)
 EXAMPLE:
   eq_data=eq_isc_gem_read('',1) % read std file, show epicenters plot
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   isc_gem_file: the filename of the .csv file with the raw data
       if empty, the code tries a default name, if it does not exist, it
       prompts the user to locate the file
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude (moment magnitude, mw)
       &ampgt also stored as .mat file. Please delete the .mat file manually in order
       to re-read from the original .csv file 
   isc_gem_file_mat: the name of the .mat file eq_data is stored to
 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141117
 David N. Bresch, david.bresch@gmail.com, 20141210, date conversion revised
 David N. Bresch, david.bresch@gmail.com, 20141223, issue with .csv file noted
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/eq_isc_gem_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="eq_signigeq_read">
<H2>eq_signigeq_read</H2></A>
<font color="blue">function eq_data=eq_signigeq_read(signigeq_file,check_plot) </font>
 Read Significant Earthquake Database
 MODULE:
 eq_global
 NAME:
   eq_signigeq_read
 PURPOSE:
   Read earthquake (EQ) database, an .xlsx file downloaded from
   www.ngdc.noaa.gov/nndc/struts/form?t=101650&amps=1&ampd=1

   for MATLAB to be able to read the .xlsx file, open it once in Excel,
   convert columns SECOND, LATITUDE and LONGITUDE to Number format and
   save as signigeq_CLEAN.xlsx (otherwise you will likely get errors of
   the kind &quotError using xlsread, Invalid zip file ... &quot

   next step: see eq_global_probabilistic
 CALLING SEQUENCE:
   eq_data=eq_signigeq_read(signigeq_file,check_plot)
 EXAMPLE:
   eq_data=eq_signigeq_read('',1) % read std file, show epicenters plot
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   signigeq_file: the filename of the .xlsx file with the raw data
       if empty, the code tries a default name, if it does not exist, it
       promptes the user to locate the file
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude
   also stored as .mat file. Please delete the .mat file manually in order
   to re-read from the original .xlsx file 
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141015, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/eq_signigeq_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="plot_attenuation_parameters">
<H2>plot_attenuation_parameters</H2></A>
<font color="blue">function plot_attenuation_parameters(mag,attenuation_file,dep) </font>
 Plot attenuation curves
 MODULE:
 eq_global
 NAME:
   plot_attenuation_parameters
 PURPOSE:
   plot the attenuation functions defined by the sets of parameters in
   earthquake_volcano/data/system/attenuation_parameters.xlsx, for a
   given magnitude
 CALLING SEQUENCE:
   plot_attenuation_parameters(magnitude, filename)
 EXAMPLE:
   plot_attenuation_parameters(8)
   plot_attenuation_parameters
 OPTIONAL INPUTS:
   mag: Richter magnitude at epicenter. If empty, 8 is used as
   default value
   attenuation_file: Name of the file that contains the attenuation 
   parameters. 
   If empty, the code tries a default name, if it does not exist, it
   prompts the user to locate the file
   dep: epicenter depth (only makes a difference for attenuation functions
   with a depth-dependent term
 OUTPUT:
   A plot showing the attenuation of intensity with distance for each set
   of parameters and for the magnitude specified in the input
 COMMENT:
   The parameters a1, a2, a3, and a4 describe an attenuantion of the type
   MMI(dist) = a1 + a2*mag - a3*log(dist+correction) - a4*dist + b*dep 
       where
       mag is the Richter magnitude at the epicenter
       dist is the distance from the epicenter (in km)
       dep is the epicenter depth
       MMI is the Mercalli Modified Intensity at distance dist from the
       epicenter

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141209, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150123, inlcuded dep and correction
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/plot_attenuation_parameters.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="plot_gutenberg_richter">
<H2>plot_gutenberg_richter</H2></A>
<font color="blue">function plot_gutenberg_richter(eq_data)  </font>
 plot a Gutenberg Richter curve
 MODULE
 eq_global
 NAME:
   plot_gutenberg_richter
 PURPOSE:
   produces a plot showing the relationship between the
   magnitude and total number of earthquakes of at least that 
   magnitude 
   see http://en.wikipedia.org/wiki/Gutenberg%E2%80%93Richter_law 
   for some background
 CALLING SEQUENCE:
   plot_gutenberg_richter(eq_data)
 EXAMPLE:
   eq_data = eq_isc_gem_read   % read historic earthquakes 
   eq_data_prob = eq_global_probabilistic(eq_data) % create probabilistic event set
   plot_gutenberg_richter(eq_data_prob)
 COMMENT:
   eq_data can be a historic data set directly generated by eq_isc_gem_read 
   or a set of probabilistic events generated based on the historic data 
   using eq_global_probabilistic
 INPUT:
   eq_data, a structure with
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       hr(line_i)  : origin hour
       min(line_i) : origin min
       sec(line_i) : origin sec
       glat(line_i): geographic latitude
       glon(line_i): geographic longitude
       dep(line_i) : focal depth
       mag(line_i) : magnitude

 OUTPUT:
   A plot showing the relationship between earthquake magnitude (mag) and 
   its relative occurrence (N/N_tot, where N is the number
   of events having a magnitude &ampgt=mag and N_tot is the total number of
   earthquakes in eq_data). The plot also shows a power law fit to the 
   input data, of form N/N_tot = 10^(a-b*mag). The parameter b, which is 
   commonly close to 1.0 in seismically active regions, can be used as a
   first check whether the input data fits empirical relations between
   earthquake magnitude and occurrence frequency

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141119, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/plot_gutenberg_richter.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="validate_eq_damage">
<H2>validate_eq_damage</H2></A>
<font color="blue">function eq_data_calculated_damage = validate_eq_damage(eq_data, check_plot) </font>
 Calculate damages of single earthquakes (and compare to historic data)
 MODULE:
 eq_global
 NAME:
   validate_eq_damage
 PURPOSE:
   Calculate the damages (in USD) of individual events, e.g., to compare
   them to historic damage data for validation purposes 
 CALLING SEQUENCE:
   eq_data_calculated_damage = validate_eq_damage(eq_data)
 EXAMPLE:
   eq_data_calculated_damage = validate_eq_damage
 OPTIONAL INPUTS:
   eq_data, a structure generated by reading a catalog of historic
   earthquakes (see eq_isc_gem_read) or by 'boosting' historic earthquakes
   to a probabilistic event set (see eq_global_probabilistic). 
   eq_data contains the following fields:
       yyyy(line_i)    : year
       mm(line_i)      : month
       dd(line_i)      : day
       hr(line_i)      : origin hour
       min(line_i)     : origin min
       sec(line_i)     : origin sec
       glat(line_i)    : geographic latitude
       glon(line_i)    : geographic longitude
       dep(line_i)     : focal depth
       mag(line_i)     : magnitude
       country(line_i) : country

   Alternatively, eq_data can also be a filename of a saved eq_data
   structure, or the filename of an excel file to read the earthquake data
   from (e.g., the file signieq_table_for_validation.xls in 
   eq_global/data/epicenters). 
   In the latter case, the excel sheet needs to have the following
   fields:
       YEAR        : year when the earthquake happened
       MONTH       : month
       DAY         : day
       HOUR        : hour
       MINUTE      : minute
       SECOND      : second
       FOCAL_DEPTH : hypocenter depth (km)   
       MAGNITUDE   : Richter magnitude of the earthquake
       COUNTRY     : country 
       LATITUDE    : geographic latitude
       LONGITUDE   : geographic longitude
       DAMAGE_DOLLARS (optional): damage data in USD (historic estimates)

   If eq_data is not given, a dialog box opens to prompt for it.

   check_plot: show a plot of the calculated damages (=1), or not
   (=0, default). If eq_data contains estimated damage values, these data are 
   plotted as well to allow for comparison and the mean ratio of
   calculated to estimated damage is displayed.
 
 OUTPUTS:
   eq_data_calculated_damage: eq_data with an additional field  
   'calculated damage' containing the calculated damages (in USD)
   of the earthquakes

 COMMENT:
 Generating the entities and centroids via climada_create_GDP_entity can
 be pretty time consuming for large countries. If the country-specific 
 entities and centroids are already available as .mat files, the code will
 skip that step and load them directly from those .mat files instead. In
 order for this to work, the entity files need to be placed
 in the /data/entities directory of the climada-master module, and named 
 in the following way:
 ISO3_countryname_centroids.mat (e.g. ITA_Italy_centroids.mat),
 and the centroids need to be placed in the /data/system directory of the
 climada-master module, and named in the following way:
 ISO3_countryname_entity.mat (e.g. ITA_Italy_entity.mat)
 
 CAUTIONARY NOTE:
 This code was only produced for testing purposes and has not been
 optimized for general applications - it might therefore need some
 adjustment to work properly in different environments.

 MODIFICATION HISTORY:
 Melanie Bieli, melanie.bieli@bluewin.ch, 20141212, initial
 Melanie Bieli, melanie.bieli@bluewin.ch, 20150123, minor changes
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/validate_eq_damage.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="vq_global_hazard_set">
<H2>vq_global_hazard_set</H2></A>
<font color="blue">function hazard=vq_global_hazard_set(vq_data,hazard_set_file,centroids,TEST_volcano_preselection) </font>
 Create volcanoe hazard set
 MODULE
 eq_global
 NAME:
   vq_global_hazard_set
 PURPOSE:
   generate a volcano (VQ) hazard event set, starting from volcano data
   calculating ash thickness (distance and depth).

   previous step: see vq_volcano_list_read and vq_global_probabilistic
 CALLING SEQUENCE:
   hazard=vq_global_hazard_set(vq_data,hazard_set_file,centroids)
 EXAMPLE:
   hazard=vq_global_hazard_set(vq_volcano_list_read)
   hazard=vq_global_hazard_set(vq_volcano_list_read,'',[],1) % TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   vq_data: a structure with volcano information, see vq_volcano_list_read
       &ampgt promted for if not given
   hazard_set_file: the name and path of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes
           Latitude(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used
       (TEST mode), see hard-wired definition in code (a rectangular area in California)
   TEST_volcano_preselection: if =1, check and show centroids and volcano
       positions, if =2 STOP after check, Default=0, no check
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'EQ' for
       earthquake
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)

   simple check for hazard content: hist(full(hazard.intensity(find(hazard.intensity))))
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150302, initial
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/vq_global_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="vq_global_probabilistic">
<H2>vq_global_probabilistic</H2></A>
<font color="blue">function vq_data=vq_global_probabilistic(vq_data,ens_size,check_plot) </font>
 generate probabilistic hazard set
 MODULE:
   eq_global
 NAME:
   vq_global_probabilistic
 PURPOSE:
   Given a volcano (VQ) database, create a probabilistic version by
   wiggling duration, cloud height, wind direction and speed...

   First, add wind speed and direction (from climatolog) to historic
       eruptions. For those historic eruptions with no known month, add mean
       wind.
   Second, generate 11 times the events and add the 'missing' months winds
       For historic eruptions without wind, use January wind for historic
   Third, generate probabilistic eruptions

   previous step: see vq_volcano_list_read
   next step: see vq_global_hazard_set
 CALLING SEQUENCE:
   vq_data=vq_global_probabilistic(vq_volcano_list_read,ens_size,check_plot)
 EXAMPLE:
   vq_data=vq_global_probabilistic(vq_volcano_list_read,9,1)
 INPUTS:
   vq_data: an volcano (VQ) database, see vq_volcano_list_read
 OPTIONAL INPUT PARAMETERS:
   ens_size: ensemble size, the number of 'copies' of the original
       database we create, default=9 (means 10x as original data)
       if =0, the data is only enriched by wind climatology and no
       probabilistic eruptions are generated (for historic events with no
       month indicated, the annual mean wind is used).
       if =1, the data is 'replicated' 11 additional times, to reflect the
       wind climatology each month.
       if &ampgt1, it's really replicating other parameters, mainly Cloud_height_km
       parameters are sampled ens_size-1 times, the final event count is
       thus n_orig_events*12*(ens_size-1)
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   vq_data, same as output of vq_volcano_list_read (see there), just for
       (many) more eruptions, plus U_vel_kmh an U_vel_rad added
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150307, initial
 David N. Bresch, david.bresch@gmail.com, 20160423, rand('seed',0) --&ampgt rng(0)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/vq_global_probabilistic.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="vq_tephra_field_cm">
<H2>vq_tephra_field_cm</H2></A>
<font color="blue">function T=vq_tephra_field_cm(centroids,lon,lat,H,U_vel,U_phi,tau,check_plot) </font>
 Create volcanoe hazard set
 MODULE
 eq_global
 NAME:
   vq_tephra_field_cm
 PURPOSE:
   Calculate the tephra (ash) field thickness for one eruption at
   centroids. The eroption is characterized by (obviously) the coordinate
   of the eruption center, the eruptive column height, the prevailing wind
   and the duration of the eruption.

   according to A. O. Gonzalez-Mellado and S. De la Cruz-Reyna, 2010: A
   simple semi-empirical approach to model thickness of ash-deposits for
   different eruption scenarios. Nat. Hazards Earth Syst. Sci., 10,
   2241?2257, 2010, direct:
   www.nat-hazards-earth-syst-sci.net/10/2241/2010/nhess-10-2241-2010.pdf

   Variable parameters are distance r between centroid(i) and eruption
   center and phi, angle between the wind direction and the vector from
   the ash emission center to centroid(i).

   Some PARAMETERS set in code, see below, also defaults

   previous step: see vq_global_hazard_set (usually colled from there)
 CALLING SEQUENCE:
   T=vq_tephra_field_cm(centroids,lon,lat,H,U_vel,U_phi,tau)
 EXAMPLE:
   lon=14.426;lat=40.821; % Vesuvius
   centroids.lon=lon-1:.01:lon+1;centroids.lat=centroids.lon*0+lat; % 1D cross-section
   T=vq_tephra_field_cm(centroids,lon,lat,15,50,0,1);
   plot((centroids.lon-lon)*100,T);hold on;plot([0 0],[0 max(T)],'-r');
   xlabel('approx km');ylabel('ash thickness [cm]')

   [X,Y]=meshgrid(lon-1:.01:lon+1,lat-1:.01:lat+1); % 2D grid
   centroids.lon=reshape(X,numel(X),1);centroids.lat=reshape(Y,numel(X),1); % 2D grid
   T=vq_tephra_field_cm(centroids,lon,lat,15,50,0,1,1); % last '1' for plot

   % As in Fig. 11 of cited paper: 30 June 1997 Popocatepetl eruption
   T=vq_tephra_field_cm(centroids,lon,lat,8,80,312/360*pi,0.58,1); % last '1' for plot

 INPUTS:
   centroids: a structure with lon(i) and lat(i) of all the points we'd
       like to obtain the tephra field thickness for
   lon: the longitude (scalar) of the eruption center
   lat: the latitude of the eruption center
 OPTIONAL INPUT PARAMETERS:
   H: eruptive column height in km
   U_vel: wind velocity in km/h, indicative 50-100 km/h most often.
   U_phi: direction of wind in radian (-pi..pi), counterclockwise from
       (dx=1,dy=0), i.e. from direction East, West=pi, North=pi/2
   tau: duration of the high-intensity phase of the eruption in hours
       (e.g. Pinatubo 1-5h) default=8h
   check_plot: =1, show check plot, =0 not (default)
 OUTPUTS:
   T: the height of the tephra field (in cm) at each centroid
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150302, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/vq_tephra_field_cm.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="vq_volcano_list_read">
<H2>vq_volcano_list_read</H2></A>
<font color="blue">function [vq_data,volcano_list_file_mat]=vq_volcano_list_read(volcano_list_file,check_plot) </font>
 read ISC-GEM earthquake catalogue
 EQ eq data read
 NAME:
   eq_GVP_volcano_list_read
 PURPOSE:
   Read volcano (VQ) database, either

   GVP_Volcano_List.xls from http://www.volcano.si.edu
   (more volcanoes, but less information)

   or

   NGDC_SignificantVolcanicEvents.xls from
   http://www.ngdc.noaa.gov/nndc/struts/results?type_15=Like&ampquery_15=&ampop_30=eq
   &ampv_30=&ampge_23=&ample_23=&ampop_29=eq&ampv_29=&amptype_16=Like&ampquery_16=&ample_17=&ampge_18=
   &ample_18=&ampge_17=&ampop_20=eq&ampv_20=&ampge_7=&ample_7=&ampbt_24=&ampst_24=&amptype_25=EXACT
   &ampquery_25=None+Selected&ampbt_26=&ampst_26=&amptype_27=EXACT&ampquery_27=None+Selected
   &amptype_12=Exact&ampquery_12=&amptype_11=Exact&ampquery_11=&ampt=102557&amps=50&ampd=50
   (more information, but less volcanoes)

   next step: see vq_global_probabilistic
 CALLING SEQUENCE:
   [vq_data,vq_data_file_mat]=vq_volcano_list_read(volcano_list_file_mat,check_plot)
 EXAMPLE:
   [vq_data,vq_data_file_mat]=vq_volcano_list_read % returns NGDC...
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   volcano_list_file: the filename of the .xls file with the tab
       volacano_list with volcano information
       if empty, the code tries a default name, if it does not exist, it
       prompts the user to locate the file
       Two short options are possible, too: 'GVP' or 'NGDC', see above
       Default is 'NGDC', as this list contains more parameters
   check_plot: show a check plot (=1), or not (=0, default)
 OUTPUTS:
   vq_data, a structure with either (for
       NGDC_SignificantVolcanicEvents.xls)
       yyyy(line_i): year
       mm(line_i)  : month
       dd(line_i)  : day
       lat(line_i): geographic latitude
       lon(line_i): geographic longitude
       elevation_m(line_i) : the elevation of the volcano
       mag(line_i) : magnitude (moment magnitude, mw)
       ...and other fields, same names as column headers in Excel
   or for GVP_Volcano_List.xls
       lat(i): geographic latitude
       lon(line_i): geographic longitude
       elevation_m(line_i) : the elevation of the volcano
       filename: the filename the data has been read from
       Volcano_Number(i)
       Volcano_Name{i}
       country_name{i}
       Primary_Volcano_Type{i}
       Activity_Evidence{i}
       Last_Known_Eruption{i}
       Region{i}
       Subregion{i}
       Dominant_Rock_Type{i}
       Tectonic_Setting{i}
       &ampgt also stored as .mat file. Please delete the .mat file manually in order
       to re-read from the original .xls file
   volcano_list_file_mat: the name of the .mat file vq_data is stored to
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20150217, initial
 David N. Bresch, david.bresch@gmail.com, 20150223, some trimming
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/earthquake_volcano/code/vq_volcano_list_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_srtm_entity">
<H2>climada_srtm_entity</H2></A>
<font color="blue">function [entity,centroids,SRTM_info]=climada_srtm_entity(centroidsORcountryORshapes,check_plot) </font>
 climada template
 MODULE:
   elevation_models
 NAME:
   climada_srtm_entity
 PURPOSE:
   Starting grom SRTM digital elevation model (90m), construct a country
   entity an the corresponding centroids, save both with standard names,
   i.e. III_{country_name}_SRTM_{entity|centroids}, with III the 3-digit
   iso code and country_name with no spaces, e.g. UnitedStates.

   check using climada_entity_plot and climada_centroids_plot
   please note that you need to run climada_EDS_calc with
   force_re_encode=1 unless you re-generate the hazard with the controids
   as generated here. Even better, run climada_assets_encode and save the
   encoded entity (
 CALLING SEQUENCE:
   entity=climada_srtm_entity(centroidsORcountryORshapes,check_plot)
 EXAMPLE:
   entity=climada_srtm_entity('Tuvalu')
 INPUTS:
   centroidsORcountryORshapes:  can be a country_name 'El Salvador', or
       coordinates of the rectangle box to get topography within [lonmin lonmax latmin latmax]
       or centroids (as e.g. from climada_centroids_load)
       handed over to climada_srtm_get, see there
 OPTIONAL INPUT PARAMETERS:
   check_plot: show a check plot, if =1, (default=0)
       if negative, omit calculation of distance2coast_km (which easily
           takes a few minutes)
 OUTPUTS:
   entity: a climada entity structure, see climada_entity_read for format
       description
   centroids: a climada centroids structure, see climada_centroids_read
   SRTM_info: just handed over from climada_srtm_get, see there
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20160514, initial (Rotterdam)
 david.bresch@gmail.com, 20160516, full compatibility with eg centroids_generate_hazard_sets
 david.bresch@gmail.com, 20160529, Cancel pressed works
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/elevation_models/code/climada_srtm_entity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_srtm_get">
<H2>climada_srtm_get</H2></A>
<font color="blue">function [SRTM,srtm_info] = climada_srtm_get(centroidsORcountryORshapes,check_plot,save_tile,verbose) </font>
 climada
 MODULE:
   elevation_models
 NAME:
   climada_srtm_get
 PURPOSE:
   Read the digital elevation model data from the files in an existing
   srtm directory. Data can be downloaded from http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp
   or http://srtm.csi.cgiar.org/index.asp

   The code tries to automatically get the tiles from
   http://droppr.org/srtm/v4.1/6_5x5_TIFs/ (see SRTM_URL in PARAMETERS in
   code). If this fails, the list of required tiles of the SRTM is printed
   to stdout for the suer to manually retrieve
 CALLING SEQUENCE:
   [SRTM,srtm_info] = climada_srtm_get(centroidsORcountryORshapes,check_plot,save_tile,verbose)
 EXAMPLE:
   [SRTM,srtm_info] = climada_srtm_get('Switzerland',1,1,1)

   SRTM = climada_srtm_get('El Salvador',1,0)
   SRTM = climada_srtm_get([-89.15 -89.1 13.695 13.73],1,0) % las canas area, San Salvador
   SRTM = climada_srtm_get([min_lon max_lon min_lat max_lat],1,0)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroidsORcountryORshapes:  can be a country_name 'El Salvador', or
       coordinates of the rectangle box to get topography within [lonmin lonmax latmin latmax]
       or centroids (as e.g. from climada_centroids_load)
   check_plot: show a check plot, if =1, (default=0)
   save_tile: =1: save the respective SRTM tiles, in order to speed up in
       subsequent calls. =0 (default): do not save anything
       Warning: the user is responsible for managing such tiles in the
       ../data/results folder
   verbose: =1 print info, =0 not (default)
 OUTPUTS:
   SRTM: a structure, with
       .x(i,j): the longitude coordinates
       .y(i,j): the latitude coordinates
       .h(i,j): the elevation [m, negative below sea level]
       sourcefile: the source file (e.g. .../srtm_18_10.tif)
   If save_tile=1, the tile as returned is also saved to
       ../data/results/etopo_*
 MODIFICATION HISTORY:
 muellele@gmail.com, 20150723, init based on climada_90m_DEM by Gilles Stassen and etopo_get by David Bresch
 david.bresch@gmail.com, 20160122, srtm folder moved, some fixes (removed hard-wired paths)
 david.bresch@gmail.com, 20160126, automatic retrieve implemented
 david.bresch@gmail.com, 20160126, single precision (half the memory need)
 david.bresch@gmail.com, 20160513, issue southern hemisphere solved
 david.bresch@gmail.com, 20160529, Cancel pressed works
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/elevation_models/code/climada_srtm_get.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="etopo_elevation_m">
<H2>etopo_elevation_m</H2></A>
<font color="blue">function elevation_m=etopo_elevation_m(lon,lat,check_plot) </font>
 climada elevation m etopo
 MODULE:
   etopo
 NAME:
   etopo_elevation_m
 PURPOSE:
   obtain elevation in m (based on ETOPO)

   See etopo_get for any further information about ETOPO. See
   http://www.ngdc.noaa.gov/mgg/global/global.html and the readme files in
   .../etopo/data. Since ETOPO1 is globally consistent, its use is highly
   recommended (use ETOPO2 only if e.g. running in memory issues).
 CALLING SEQUENCE:
   elevation_m=etopo_elevation_m(lon,lat,check_plot)
 EXAMPLE:
   elevation_m=etopo_elevation_m(lon,lat)
 INPUTS:
   lon: vector of longitues
   lat: vector of latitudes
 OPTIONAL INPUT PARAMETERS:
   check_plot: =1: show circle plot for check, only works for more than
       one point
       =0: no plot (default)
 OUTPUTS:
   elevation_m: elevation in m for each lat/lon (ocean depth for below sea
       level)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141226, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/elevation_models/code/etopo_elevation_m.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="etopo_get">
<H2>etopo_get</H2></A>
<font color="blue">function ETOPO=etopo_get(etopo_coords,check_plot,save_tile) </font>
 climada topography ETOPO bathymetry
 NAME:
   etopo_get
 PURPOSE:
   get a chunk (tile) of the global ETOPO elevation (and bathymetry) dataset.

   Test it calling etopo_get without any argument (you should get an area
   around Switzerland)

   There are two datasets, ETOPO1 in high-res and ETOPO2 in mid-res. See
   http://www.ngdc.noaa.gov/mgg/global/global.html and the readme files in
   .../etopo/data. Since ETOPO1 is globally consistent, it?s use is highly
   recommended (use ETOPO2 only if e.g. running in memory issues).

   If there is no data file, means no file .../etopo/data/ETOPO1.nc,
   proceed as follows:
   1. Download the file
      http://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/data/ice_surface/grid_registered/netcdf/ETOPO1_Ice_g_gmt4.grd.gz
   2. Move it to .../etopo/data/
   3. Unzip it (it might do so automatically, e.g. on a Mac)
   4. Rename it to ETOPO1.nc
   5. Test it using etopo_get without any argument (you should get an area
      around Switzerland)

 CALLING SEQUENCE:
   ETOPO=etopo_get(etopo_coords,check_plot,save_tile)
 EXAMPLE:
   ETOPO=etopo_get([4 14 43 53])
 INPUTS:
   etopo_coords: the rectangle to get topography within
       [lonmin lonmax latmin latmax]
       if empty (or not provided): TEST mode, you should get an area
       around Switzerland - and the elevation is plotted, too.
 OPTIONAL INPUT PARAMETERS:
   check_plot: show a check plot, if =1, (default=0)
   save_tile: =1: save the respective etopo tile, in order to speed up in
       subsequent calls. =0 (default): do not save anything
       Warning: the user is responsible for managing such tiles in the
       ../data/results folder
       The option has mainly been introduced to support use of etopo_get
       under Octave, which does not yert provide ncread. Please note that
       check_plot does not work on subsequent calls.
 OUTPUTS:
   ETOPO: a structure, with
       x(i,j): the longitude coordinates
       y(i,j): the latitude coordinates
       h(i,j): the elevation [m, negative below sea level]
       sourcefile: the source file (.../ETOPO1.nc)
   If save_tile=1, the tile as returned is also saved to
       ../data/results/etopo_*
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140422
 David N. Bresch, david.bresch@gmail.com, 20141022, small fix if requested area ourside limits (just a FIX, not a nice one, see below)
 David N. Bresch, david.bresch@gmail.com, 20150101, save_tile
 David N. Bresch, david.bresch@gmail.com, 20160526, better error messaging for ETOPO issues
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/elevation_models/code/etopo_get.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_encode_distance">
<H2>climada_hazard_encode_distance</H2></A>
<font color="blue">function hazard = climada_hazard_encode_distance(hazard,entityORassetsORcentroids,cutoff) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_hazard_encode_distance
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Convert landslide hazard intensity (landslide depth(m))
   into distance between an asset and the nearest centroid with nonzero
   intensity. Distance is transformed into intensity in the form of (y = mx+b), 
   which means increasing intensity with increasing damage, 
   intensity = 1 - 1/cutoff * distance_m
   Minimum distance is set to  1m, which translates into the maximum intensity 1.
   The lat/lon coordinates of the hazard are overwritten by the asset
   lat/lon coordinates
   A default distance cutoff, when it can be assumed that no asset is
   affected anymore is introduced at 1000 m.
 CALLING SEQUENCE:
   hazard = hazard_distance_convert(hazard,entity,cutoff)
 EXAMPLE:
   hazard = hazard_distance_convert(hazard,entity,250)
 INPUTS:
   hazard: landslide hazard structure, intensity given as meters soildepth
   entity: climada entity structure, with .assets.lon and .assets.lat
 OPTIONAL INPUT PARAMETERS:
   cutoff: default 1000m, can be set to other value
 OUTPUTS:
   hazard: a climada structure with lat/lon that equal the entity.assets.lat/lon
           and intensity as 1-1/cutoff*distance_m (-)
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20150708, initial
 Lea Mueller, muellele@gmail.com, 20150713, intensity as 1-1/cutoff*distance_m instead of distance
 Gilles Stassen, gillesstassen@hotmail.com, 20150803, faster (~30x) alternative to knnsearch; argin entity -&ampgt entityORassetsORcentroids
 Gilles Stassen, 20150805, elevation cutoff. Entity points higher in elevation than land slide excluded
 Lea Mueller, muellele@gmail.com, 20150915, bugfix when calculate distance_m from intensity
 Lea Mueller, muellele@gmail.com, 20151106, move to flood
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_hazard_encode_distance.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_binary_plot">
<H2>climada_ls_hazard_binary_plot</H2></A>
<font color="blue">function fig = climada_ls_hazard_binary_plot(hazard) </font>
 climada plot ls binary hazard
 MODULE:
   flood
 NAME:
   climada_ls_hazard_binary_plot
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Plot binary landslide hazard, all events on one map
 PREVIOUS STEP:
   hazard_binary = climada_ls_hazard_set_binary(centroids)
 NEXT STEP:
   hazard = climada_hazard_encode_distance(hazard,centroids,cutoff);
 CALLING SEQUENCE:
   fig = climada_ls_hazard_binary_plot(hazard)
 EXAMPLE:
   fig = climada_ls_hazard_binary_plot;
 INPUTS:
   hazard:  a climada hazard stucture with binary landslide
   information (.intensity is either 1 or 0)
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   fig: handle of map with landslide events
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init
 -
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('hazard', 'var'), hazard = []; end
f isempty(hazard), hazard = climada_hazard_load; end   
        
 visualize binary ls hazard on a map
 ------------------------------
 delete nans if there are any
azard.intensity(isnan(hazard.intensity)) = 0;
xlim = [min(hazard.lon) max(hazard.lon) min(hazard.lat) max(hazard.lat)];
_events = hazard.event_count;
_colors = jet(n_events);
 show a maximum number of events
vent_step = 1;
ax_events_to_show = 100;
f n_events&ampgtmax_events_to_show, event_step = round(n_events/max_events_to_show);end
ig = climada_figuresize(0.5,0.7);
 plot(entity.assets.lon, entity.assets.lat,'.','linewidth',0.2,'markersize',0.8,'color',[255 64 64 ]/255);
old on
egendstr = []; h = []; counter = 0;
or e_i = 1:event_step:n_events
   is_event = logical(hazard.intensity(e_i,:));
   if any(is_event)
       counter = counter+1;
       %hold on; plot3(hazard.lon(is_event), hazard.lat(is_event), ones(sum(is_event))*3000, 'dr','linewidth',2,'markersize',5,'color',[255 64 64 ]/255)
       h(counter) = plot(hazard.lon(is_event), hazard.lat(is_event),'dr','linewidth',2,'markersize',5,'color',n_colors(e_i,:));
       hold on; 
       %plot(polygon_canas.X, polygon_canas.Y, 'b-');
       legendstr{counter} = sprintf('Event %d',e_i);
   end
nd
itlestr = 'LS hazard binary';
ry titlestr = sprintf('%s hazard (%s), %d events, %d',hazard.peril_ID, hazard.units, n_events, hazard.reference_year);end
itle(titlestr); axis(axlim); box on; 
limada_figure_axis_limits_equal_for_lat_lon(axlim); climada_figure_scale_add('',1,1)
egend(h,legendstr,'location','eastoutside')
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_ls_hazard_binary_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_set">
<H2>climada_ls_hazard_set</H2></A>
<font color="blue">function [hazard, centroids, fig] = climada_ls_hazard_set(centroids,n_events,hazard_set_file,... </font>
                                       wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                       n_downstream_cells,focus_area,polygon_correction,random_trigger_condition,...
                                       check_plot)
 Generate a landslide hazard set
 MODULE:
   flood
 NAME:
   climada_ls_hazard_set
 PURPOSE:
   This is a all-in-one function to generate a landslide hazard set. The 
   landslide events are based solely on topographical information 
   (SRTM 90m digital elevation data) and calculates slope and 
    topographical wetness index. We create first a binary hazard,
   encode to distance and plot figures if required.
   invokes 
       - climada_ls_hazard_set_binary
       - climada_hazard_encode_distance
   and for plots
       - climada_ls_hazard_binary_plot
       - climada_map_plot
       - climada_hazard_stats
       - climada_hazard_stats_figure   
 PREVIOUS STEP:
   create centroids, select a rectangle box to create the landslide hazard
   centroids = climada_centroids_elevation_add;
 CALLING SEQUENCE:
   [hazard, centroids, fig] = climada_ls_hazard_set(centroids,n_events,hazard_set_file,...
                                         wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                         n_downstream_cells,focus_area,polygon_correction,random_trigger_condition,...
                                         check_plot)
 EXAMPLE:
   hazard = climada_ls_hazard_set(centroids)
   check_plot = 1;
   [hazard, centroids, fig]  = climada_ls_hazard_set([-89.145 -89.1 13.692 13.727],'','','','','','','','','','',check_plot)
 INPUTS:
   centroids:  a climada centroids stucture (ideally including topographical
   information) or a rectangle to define lon/lat box, if not given, the
   user can select a rectangle by first selecting a country and then drawing
   a rectangle on a map
 OPTIONAL INPUT PARAMETERS:
   n_events: number of events
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat)
       &ampgt promted for if not given
   wiggle_factor_TWI:    an array, default is 0.35, to modify topographical
                         wetness factor, which is a number between 0 and 1.4
   condition_TWI:        an array, default is 0.95, to define a minimum
                         topographical wetness index, where a landslide occurs
   wiggle_factor_slope:  an array, default is 0.35, to modify the slope factor, 
                         which is a number between 0 and 1
   condition_slope:      an array, default is 0.45, to define a minimum slope
                         where a landslide occurs
   n_downstream_cells:   number of downstream cells where the landslide is extended
   focus_area:           a polygon to define the focus area (with focus_area.lon, focus_area.lat),
                         landslides only in the given area will be filtered 
                         and the other areas are cut out
   polygon_correction:   a polygon to define an area where less landlislides should occur
   random_trigger_condition: a number between 0 and 1, 1 prevents all landslide 
                         in the polygon_correction area, 0 does not inhibit any
                         landlides in the polygon_correction area
   check_plot:          set to 1 if you want to see maps (elevation, slope, hazard, etc)
 OUTPUTS:
   hazard: a climada hazard structure with binary landslide information
       .peril_ID: 'LS'
       .date: the creation date of the set
       .intensity(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i, binary, 1 indicates a landslide, 0 no landslide
       .frequency(event_i): the frequency of each event
       .matrix_density: the density of the sparse array hazard.intensity
       .filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
   centroids: a climada centroids structure with fields
       .lon
       .lat
       .elevation_m, elevation in meters
       .slope_deg, slope in degree
       .TWI, topographical wetness index
       .aspect_deg, spect in degree
   fig: handle of figures (maps with elevation, slope, landslide
        hazard,etc)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init
 -
 init
azard = []; fig = [];
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('centroids', 'var'), centroids = []; end
f ~exist('n_events', 'var'), n_events = []; end
f ~exist('hazard_set_file', 'var'), hazard_set_file = []; end
f ~exist('wiggle_factor', 'var'), wiggle_factor_TWI = []; end
f ~exist('TWI_condition', 'var'), condition_TWI = []; end
f ~exist('wiggle_factor_slope', 'var'), wiggle_factor_slope = []; end
f ~exist('slope_condition', 'var'), condition_slope = []; end
f ~exist('n_downstream_cells', 'var'), n_downstream_cells = []; end
f ~exist('focus_area', 'var'), focus_area = []; end
f ~exist('polygon_correction', 'var'), polygon_correction = []; end
f ~exist('random_trigger_condition', 'var'), random_trigger_condition = []; end
f ~exist('check_plot', 'var'), check_plot = 0; end
 create binary landslide hazard
hazard_binary, centroids]  = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,...
                                   wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                   n_downstream_cells,focus_area,polygon_correction,random_trigger_condition);
              
 encode binary hazard to distance, so that we have the distance to
 landslides as intensity
utoff = 1000;
azard = climada_hazard_encode_distance(hazard_binary,centroids,cutoff);
 save hazard
pathname, filename, ext] = fileparts(hazard.filename);
f ~exist(pathname,'dir')
   hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'LSXX_hazard.mat'];
   [filename, pathname] = uiputfile(hazard_set_file, 'Save LS hazard set as:');
   if isequal(filename,0) || isequal(pathname,0)
       return; % cancel
   else
       hazard_set_file = fullfile(pathname,filename);
   end
lse
   filename = [strrep(filename,'binary','') 'distance'];
   hazard_set_file = fullfile(pathname,filename);
nd
printf('Save landslide (LS) hazard set (encoded to distance) as %s\n',hazard_set_file);
ave(hazard_set_file,'hazard')
f check_plot   
   % create landslide binary event map
   fig = climada_ls_hazard_binary_plot(hazard_binary);
   
   % plot centroids with characteristics (elevation, slope, twi, etc)
   fieldname_to_plot = {'elevation_m' 'slope_deg' 'TWI' 'aspect_deg'};
   plot_method = 'plotclr';
   [~, fig_temp] = climada_map_plot(centroids,fieldname_to_plot,plot_method);
   
   % plot hazard statistics
   hazard.orig_years = 1000; % we set the number of years to 1000 to have nice images, but please check if this is suitable
   hazard.frequency = ones(size(hazard.event_ID))*(1./hazard.orig_years);
   
   return_periods = [10 25 50 100 150 200];
   hazard_stats = climada_hazard_stats(hazard,return_periods,0);
   fig_temp_2 = climada_hazard_stats_figure(hazard_stats,return_periods);
  
   % concatenate figure handles
   fig = [fig fig_temp fig_temp_2];
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_ls_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_set_binary">
<H2>climada_ls_hazard_set_binary</H2></A>
<font color="blue">function [hazard, centroids]  = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,... </font>
                                   wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                   n_downstream_cells,focus_area,polygon_correction,random_trigger_condition)
 Generate a binary landslide hazard set
 MODULE:
   flood
 NAME:
   climada_ls_hazard_set_binary
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Generate a binary landslide hazard set based solely on topographical
   information (slope and topographical wetness index)
 PREVIOUS STEP:
   centroids = climada_centroids_elevation_add;
 CALLING SEQUENCE:
   hazard = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,...
                    wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                    n_downstream_cells,focus_area,polygon_correction,random_trigger_condition)
 EXAMPLE:
   hazard = climada_ls_hazard_set_binary(centroids)
   hazard = climada_ls_hazard_set_binary([-89.145 -89.1 13.692 13.727])
   hazard = climada_ls_hazard_set_binary
 INPUTS:
   centroids:  a climada centroids stucture (ideally including topographical
   information) or a rectangle to define lon/lat box, if not given, the
   user can select a rectangle by first selecting a country and then drawing
   a rectangle on a map
 OPTIONAL INPUT PARAMETERS:
   n_events: number of events
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat)
       &ampgt promted for if not given
   wiggle_factor_TWI:    an array, default is 0.35, to modify topographical
                         wetness factor, which is a number between 0 and 1.4
   condition_TWI:        an array, default is 0.95, to define a minimum
                         topographical wetness index, where a landslide occurs
   wiggle_factor_slope:  an array, default is 0.35, to modify the slope factor, 
                         which is a number between 0 and 1
   condition_slope:      an array, default is 0.45, to define a minimum slope
                         where a landslide occurs
   n_downstream_cells:   number of downstream cells where the landslide is extended
   focus_area:           a polygon to define the focus area (with focus_area.lon, focus_area.lat),
                         landslides only in the given area will be filtered 
                         and the other areas are cut out
   polygon_correction:   a polygon to define an area where less landlislides should occur
   random_trigger_condition: a number between 0 and 1, 1 prevents all landslide 
                         in the polygon_correction area, 0 does not inhibit any
                         landlides in the polygon_correction area
 OUTPUTS:
   hazard: a climada hazard structure with binary landslide information
       .peril_ID: 'LS'
       .date: the creation date of the set
       .intensity(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i, binary, 1 indicates a landslide, 0 no landslide
       .frequency(event_i): the frequency of each event
       .matrix_density: the density of the sparse array hazard.intensity
       .filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150911, init
 Lea Mueller, muellele@gmail.com, 20150920, add polygon_correction with a random trigger condition, to reduce landslides in a given polygon
 Lea Mueller, muellele@gmail.com, 20151124, return centroids as output, use climada_hazard_focus_area
 Lea Mueller, muellele@gmail.com, 20151124, call from climada_ls_hazard_set
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_hazard_crop from climada_hazard_focus_area
 -
azard = []; % init
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('centroids', 'var'), centroids = []; end
f ~exist('n_events', 'var'), n_events = []; end
f ~exist('hazard_set_file', 'var'), hazard_set_file = []; end
f ~exist('wiggle_factor', 'var'), wiggle_factor_TWI = []; end
f ~exist('TWI_condition', 'var'), condition_TWI = []; end
f ~exist('wiggle_factor_slope', 'var'), wiggle_factor_slope = []; end
f ~exist('slope_condition', 'var'), condition_slope = []; end
f ~exist('n_downstream_cells', 'var'), n_downstream_cells = []; end
f ~exist('focus_area', 'var'), focus_area = []; end
f ~exist('polygon_correction', 'var'), polygon_correction = []; end
f ~exist('random_trigger_condition', 'var'), random_trigger_condition = []; end
f isnumeric(centroids) &amp&amp numel(centroids) == 4
   % we have a box that defines where centroids should be created on 90m
   % resolution (given by SRTM)
   % return
   centroids = climada_centroids_elevation_add('',centroids);
nd
f isempty(centroids) 
   % create centroids by asking user for a country and to define a
   % rectangle region on the figure
   % return
   centroids = climada_centroids_elevation_add('','');
nd
 PARAMETERS
f isempty(n_events); n_events = 100; end
f isempty(wiggle_factor_TWI); wiggle_factor_TWI = 0.35; end
f isempty(condition_TWI); condition_TWI = 0.95; end
f isempty(wiggle_factor_slope); wiggle_factor_slope = 0.2; end
f isempty(condition_slope); condition_slope = 0.45; end
f isempty(n_downstream_cells); n_downstream_cells = 5; end
f isempty(random_trigger_condition); random_trigger_condition = 0; end
 prompt for hazard_set_file if not given
f isempty(hazard_set_file) % local GUI
   hazard_set_file      = [climada_global.data_dir filesep 'hazards' filesep 'LSXX_hazard_binary.mat'];
   [filename, pathname] = uiputfile(hazard_set_file, 'Save LS (binary) hazard set as:');
   if isequal(filename,0) || isequal(pathname,0)
       return; % cancel
   else
       hazard_set_file = fullfile(pathname,filename);
   end
nd
 complete path, if missing
fP,fN,fE] = fileparts(hazard_set_file);
f isempty(fP),hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep fN fE];end
% load template for hazard-structure
azard_example_file = [climada_global.data_dir filesep 'hazards' filesep 'TCNA_today_small.mat'];
f exist(hazard_example_file,'file')
   load(hazard_example_file)
lse
   fprintf('No hazard example found to be loaded. \n')
nd
azard_ex = hazard;
 overwrite template hazrd with actual information
azard.lon = centroids.lon;
azard.lat = centroids.lat;
azard.centroid_ID = 1:numel(hazard.lon);
azard.peril_ID         = 'LS';
azard.orig_years       = 10000;
azard.orig_event_count = n_events;
azard.event_count      = n_events;
azard.event_ID         = 1:n_events;
azard.orig_event_flag  = ones(1,n_events);
azard.yyyy             = ones(1,n_events);
azard.mm               = ones(1,n_events);
azard.dd               = ones(1,n_events);
azard.intensity        = sparse(n_events,numel(hazard.lon));
azard.name             = cell(1,n_events);
azard.frequency        = ones(1,n_events)/hazard.orig_years;
azard.comment          = centroids.comment;
azard.date             = datestr(now);
azard.units            = 'binary';
azard.orig_yearset     = [];
azard.filename         = hazard_set_file;
azard.matrix_density   =  0.01; % estimate
 n_centroids = length(centroids.centroid_ID);
f ~isfield(centroids,'slope_deg')
   fprintf('Add topographical characteristics to the centroids, based on elevation\n')
   centroids = climada_centroids_TWI_calc(centroids);
nd
 calculate slope_factor as cos(slope)/sin(slope)
lope_factor = 1./(cosd(centroids.slope_deg) ./ sind(centroids.slope_deg));
lope_factor(isinf(slope_factor)) = 0;
lope_factor(slope_factor&ampgt0.55) = 0.6;
f ~isfield(centroids,'slope_factor')
   centroids.slope_factor = slope_factor;
nd
 normalize TWI
f ~isfield(centroids,'TWI_norm')
   % TWI_norm = centroids.TWI/10;
   % TWI_norm(TWI_norm&ampgt0.85) = 0.85;
   TWI_norm = centroids.TWI/10;
   TWI_norm(isnan(TWI_norm)) = 0;
   centroids.TWI_norm = TWI_norm;
nd
 % slope factor
 titlestr = 'Slope factor (-)';
 miv = 0;
 mav = 0.6;
 fig = climada_figuresize(0.5,0.6);
 plotclr(centroids.lon, centroids.lat, centroids.slope_factor, marker,markersize,cbar_on,miv,mav);
 title(titlestr); axis(axlim); box on; climada_figure_scale_add('',7,1)
 pdf_filename = sprintf('LS_slope_factor.pdf');
 print(fig,'-dpdf',[ls_dir pdf_filename])
 
 % TWI norm
 titlestr = 'TWI normalised';
 miv = 0;
 mav = 1;
 fig = climada_figuresize(0.5,0.6);
 plotclr(centroids.lon, centroids.lat, centroids.TWI_norm, marker,markersize,cbar_on,miv,mav);
 title(titlestr); axis(axlim); box on; climada_figure_scale_add('',7,1)
 pdf_filename = sprintf('LS_TWI_normalised.pdf');
 print(fig,'-dpdf',[ls_dir pdf_filename])
f ~isempty(polygon_correction)
   lon_lat_polygon = climada_concatenate_lon_lat(polygon_correction.lon,polygon_correction.lat);
   lon_lat = climada_concatenate_lon_lat(centroids.lon,centroids.lat);
   needs_correction = inpoly(lon_lat,lon_lat_polygon);
   %sum(needs_correction)
   needs_correction = find(needs_correction);
nd
 create TWI wiggle as the sum of TWI_norm + TWI_delta
 create slope wiggle as the sum of slope_factor + slope_delta
 TWI_wiggle = zeros(size(hazard.intensity)); %init
 slope_wiggle = zeros(size(hazard.intensity)); %init
elta_TWI = rand(size(hazard.intensity)) * wiggle_factor_TWI;
elta_slope = rand(size(hazard.intensity)) * wiggle_factor_slope;
or e_i = 1:n_events
   wiggle_TWI = centroids.TWI_norm + delta_TWI(e_i,:);
   wiggle_slope = centroids.slope_factor + delta_slope(e_i,:);
       
   % check where landslides occur
   ls_occurence(e_i,:) = wiggle_TWI&ampgtcondition_TWI &amp wiggle_slope&ampgtcondition_slope ;
   
   if ~isempty(polygon_correction)
       random_trigger = rand(numel(needs_correction),1);
       random_trigger(random_trigger&ampgtrandom_trigger_condition) = 1;
       random_trigger(random_trigger&amplt=random_trigger_condition) = 0;
       not_triggered = needs_correction(~random_trigger);
       ls_occurence(e_i,not_triggered) = 0;
   end
   
nd
 expand landslides to following n_cells downstream
f n_downstream_cells&ampgt1
   if ~isfield(centroids,'sink_ID_10')
       centroids = climada_flow_find(centroids);
   end
   if n_downstream_cells&ampgt10
       n_downstream_cells = 10;
       fprintf('Maximum numbers of downstream cells is 10.\n')
   end
   
   msgstr   = sprintf('Expand landslide to %d downstream cells for %i events ... ',n_downstream_cells,n_events);
   mod_step = 10; % first time estimate after 10 assets, then every 100
   if climada_global.waitbar
       fprintf('%s (updating waitbar with estimation of time remaining every 50th event)\n',msgstr);
       h        = waitbar(0,msgstr);
       set(h,'Name','Expand landslide to ownstream cells');
   else
       fprintf('%s (waitbar suppressed)\n',msgstr);
       format_str='%s';
   end
   
   % loop over all events
   for e_i = 1:n_events
       is_event = ls_occurence(e_i,:);
       centroid_list = find(is_event);
       
       % loop over centroids, that are sliding
       for i = centroid_list
           selected_sinks = centroids.sink_ID_10(i,:);
           % take only a given number of downstream cells
           if numel(selected_sinks)&ampgtn_downstream_cells
                selected_sinks = selected_sinks(1:n_downstream_cells);
           end
           if ~isempty(selected_sinks)
               is_sink = []; %init
               for s_i = 1:numel(selected_sinks)
                   if selected_sinks(s_i)&ampgt0
                       is_sink(s_i) = find(selected_sinks(s_i) == centroids.centroid_ID);
                   end
               end
               %is_sink = ismember(centroids.centroid_ID,selected_sinks);
               ls_occurence(e_i,is_sink) = ones(1,numel(is_sink));
           end
       end
       
       % the progress management
       if mod(e_i,mod_step)==0
           mod_step          = 50;
           msgstr = sprintf('%i/%i events',e_i,n_events);
           if climada_global.waitbar
               waitbar(e_i/n_events,h,msgstr); % update waitbar
           else
               fprintf(format_str,msgstr); % write progress to stdout
               format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
           end
       end
   
   end
   ls_occurence = logical(ls_occurence);
nd
 create sparse matrix
azard.intensity = sparse(ls_occurence);
f climada_global.waitbar
   close(h) % dispose waitbar
lse
   fprintf(format_str,''); % move carriage to begin of line
nd
 restrict hazard landslides to a given focus area (delete locations outside this area, .lon, .lat, .intensity)
f ~isempty(focus_area)
   fprintf('Filter out landslides in the given focus area.\n')
   hazard = climada_hazard_crop(hazard, focus_area);
   
     if isfield(focus_area,'lon') &amp&amp isfield(focus_area,'lat')
         polygon = climada_concatenate_lon_lat(focus_area(1).lon, focus_area(1).lat);
         
     elseif isfield(focus_area,'X') &amp&amp isfield(focus_area,'Y')
         polygon = climada_concatenate_lon_lat(focus_area(1).X, focus_area(1).Y);
         
     elseif isnumeric(focus_area) % it is already formatted as a polygon
         [i, j] = size(focus_area);
         if j == 2 &amp&amp i&ampgt2
             polygon = focus_area;
         end
     else
         fprintf('Please check the input of the focus area.\n')
         return
     end
     hazard_lon_lat = climada_concatenate_lon_lat(hazard.lon, hazard.lat);
     is_inside = inpoly(hazard_lon_lat,polygon);
     if any(is_inside)
         hazard.lon = hazard.lon(is_inside);
         hazard.lat = hazard.lat(is_inside);
         hazard.centroid_ID = 1:numel(hazard.lon);
         hazard.intensity = hazard.intensity(:,is_inside);
     end
nd
printf('Save landslide (LS) hazard set (binary) as %s\n',hazard_set_file);
ave(hazard_set_file,'hazard')
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_ls_hazard_set_binary.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="DEM_rainfall">
<H2>DEM_rainfall</H2></A>
<font color="blue">function [WO_object,precip] = DEM_rainfall(centroids) </font>
UNTITLED2 Summary of this function goes here
average the rainfall dataset
%
 climada RF hazard event set
 NAME:
   climada_RF_hazard_set
 PURPOSE:
   Construct hazard set structure from global historical daily precipitation data
   found here: ftp://ftp.cgd.ucar.edu/archive/PRECIP/GPCP_1DD_v1.2_199610-201407.nc.gz
               http://www.esrl.noaa.gov/psd/data/gridded/data.gpcc.html
   The ens_size probabilistic events are generated by taking the x_fraction most
   extreme events from the original data, and adjusting their intensity.
   The extent of the wiggle is determined by generating a random wiggle
   paramater from a normal distribution with standard deviation ens_amp.
 CALLING SEQUENCE:
   hazard = climada_rf_hazard_set(centroids, precip_file, x_fraction, ens_size, ens_amp, hazard_set_file, check_plots)
 EXAMPLE:
   hazard = climada_rf_hazard_set(centroids, '', 0.2, 9, 0.1, 'NO_SAVE', 1)
   hazard = climada_rf_hazard_set(centroids, '', 0.7, 1)
   hazard = climada_rf_hazard_set
 INPUTS:
   hazard_set_file: the name of the newly created rainfall (RF) hazard
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   check_plots: whether to show plots (default = 1)
 OUTPUTS:
   hazard:     a hazard event set, see core climada doc
               also written to a .mat file (see hazard_set_file)
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150316
 Gilles Stassen, gillesstassen@hotmail.com, 20150406 overhaul to daily
                   precipitation data, including auto download functionality, and
                   probabilistic set of extreme events
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/DEM_rainfall.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_90m_DEM">
<H2>climada_90m_DEM</H2></A>
<font color="blue">function [centroids, DEM] = climada_90m_DEM(centroidsORcountryORshapes, srtm_dir, DEM_save_file, smooth, check_plot) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_read_srtm_DEM
 PURPOSE:
   Read the digital elevation model data from the files in an existing
   srtm directory. Data can be downloaded from http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp
 CALLING SEQUENCE:
   [centroids,DEM] = climada_90m_DEM(centroids, srtm_dir, DEM_save_file, smooth, check_plot)
 EXAMPLE:
   [centroids,DEM] = climada_90m_DEM('Netherlands',[],[],[],1)
   [~,DEM] = climada_90m_DEM
   [centroids,DEM] = climada_90m_DEM([min_lon max_lon min_lat max_lat],srtm_dir,DEM_save_file, 4,1)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   centroids:  If centroids are provided as an input, the DEM will contain
               elevation data sampled at the location of centroids, and
               hence will have an extra field .centroid_ID. The extra
               field is required for tc_surge_hazard_create if you wish to
               provide your own topography data (e.g. srtm).
               If this input is left empty , a
               centroids struct will be generated at the same resolution
               as the DEM.
               If set to a 4-element vector (centroids_rect), these 4
               points will define the area of interest, which is
               subsequently cropped out of the DEM.
               NOTE:   It is only sensible to provide a centroids struct
               as input if its resolution is significantly lower than that
               of the DEM, otherwise, it is much faster to generate
               centroids directly from the DEM.
   srtm_dir:   The directory of an srtm data tile folder, containing at
               least a .hdr and a .tif file. Can also be set to 'DL' 
               (default) which will initiate automatic download from SRTM 
               website according to the centroidsORcountry given as input.
   smooth:     Can either be set to an integer N (smooth by default filter
               specified by a matrix size NxN with values 1/N^2) or a
               smoothing filter. Default = [] (no smoothing).
   check plot: Specify whether to plot a relief of the DEM, default = 0
 OUTPUTS:
   DEM:        Struct containing information of the digital elevation
               model at full 90m resolution, with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
   centroids:  Climada centroids struct with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
               .onLand:        Set to 0 if .elevation_m &amplt0, 1 otherwise
               .admin0_name    Country name
               .admin0_ISO3    ISO 3 country code
 MODIFICATION HISTORY:
   Gilles Stassen 20150107
   Gilles Stassen 20150224     fixed some bugs in the plotting routines
                               and added messages to warn of DEM edges
   Gilles Stassen 20150225     cleanup and added automatic download and
                               unzip feature
   Gilles Stassen 20150707     renamed climada_read_srtm_DEM-&ampgtclimada_90m_DEM
                               usage of climada_grid2array replaced with
                               reshape, some further bug fixes
   Lea Mueller, muellele@gmail.com, 20150720, @Gilles, please correct,
   code does not work, srtm_19_10 is a .tif.aux.xml, not a .tif, probably
   file was not copied from your drive to the shared drive
EM =[];
lobal climada_global
f ~climada_init_vars,return;end % init/import global variables
f exist(climada_global.map_border_file, 'file')
   load(climada_global.map_border_file)
nd
odule_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
f ~exist('centroidsORcountryORshapes', 'var'),     centroidsORcountryORshapes  = [];   end
f ~exist('srtm_dir',           'var'),     srtm_dir            = 'DL'; end
f ~exist('DEM_save_file',      'var'),     DEM_save_file       = [];   end
f ~exist('smooth',             'var'),     smooth              = [];   end
f ~exist('check_plot',         'var'),     check_plot          = 0;    end
f ~isempty(centroidsORcountryORshapes)
   if isstruct(centroidsORcountryORshapes) &amp&amp isfield(centroidsORcountryORshapes,'centroid_ID')
       % input is centroids
       centroids   = centroidsORcountryORshapes; clear centroidsORcountryORshapes
       if isfield(centroids,'countryname')
           country_name    =   centroids.country_name;
           [country_name, ~, occurrence]=unique(country_name);
           country_name    =   country_name(mode(occurrence));
           country_name    =   country_name{1};
       else
           country_name = [];
       end
       rect        = [min(centroids.lon) max(centroids.lon) min(centroids.lat) max(centroids.lat)];
   elseif isstruct(centroidsORcountryORshapes) &amp&amp (isfield(centroidsORcountryORshapes,'X') || isfield(centroidsORcountryORshapes,'lon'))
       % input is probably shapes
       shapes = centroidsORcountryORshapes; clear centroidsORcountryORshapes
       if isfield(shapes,'lon'),   shapes.X  =shapes.lon; shapes.Y = shapes.lat; end
       bb          = [min([shapes(:).X]) min([shapes(:).Y])
                      max([shapes(:).X]) max([shapes(:).Y])];
       rect        = [bb(:,1)' bb(:,2)']; clear bb
   elseif isnumeric(centroidsORcountryORshapes) &amp&amp numel(centroidsORcountryORshapes) == 4
       % input is centroids_rect
       centroids   = [];
       rect        = centroidsORcountryORshapes; clear centroidsORcountryORshapes
   elseif ischar(centroidsORcountryORshapes)
       % input is country name
       centroids   = [];
       country_name= centroidsORcountryORshapes; clear centroidsORcountryORshapes
       [country_name,country_ISO3,shape_index] = climada_country_name(country_name);
       if isempty(shape_index)
           cprintf([1 0 0],'ERROR: invalid country name \n')
           [country_name,country_ISO3,shape_index] = climada_country_name;
       end
       
       % bb          = shapes(shape_index).BoundingBox;    % countries with colonies pose problems here...
       bb          = [min(shapes(shape_index).X) min(shapes(shape_index).Y)
           max(shapes(shape_index).X) max(shapes(shape_index).Y)];
       rect        = [bb(:,1)' bb(:,2)']; clear bb
   end
lse
   centroids   = []; clear centroidsORcountry
   [country_name,country_ISO3,shape_index] = climada_country_name('Single');
   country_name = char(country_name);
   if isempty(country_name), return; end % error message already printed in climada_country_name
   % bb          = shapes(shape_index).BoundingBox;    % countries with colonies pose problems here...
   bb          = [min(shapes(shape_index).X) min(shapes(shape_index).Y)
       max(shapes(shape_index).X) max(shapes(shape_index).Y)];
   rect        = [bb(:,1)' bb(:,2)']; clear bb
nd
 country string for fprintf and fig title
f exist('country_name','var') &amp&amp ~isempty(country_name)
   cntry_str = sprintf(' for %s',country_name'); 
lse
   cntry_str = ''; 
nd
 conversion to srtm tile indices
ect_buffer      = 0.5;     % set buffer to avoid missing data due to imperfect conversions below
f rect(1) &amplt-179.9,rect(1) = rect(1)+359.9; end
rtm_min_lon_ndx = max(ceil(72 * (rect(1)-rect_buffer + 180)/(179.28+180.00)),1);
rtm_max_lon_ndx = min(ceil(72 * (rect(2)+rect_buffer + 180)/(179.28+180.00)),72);
rtm_min_lat_ndx = max(ceil(24 * (60 - rect(3)+rect_buffer) /( 60.00+ 57.83)),1);
rtm_max_lat_ndx = min(ceil(24 * (60 - rect(4)-rect_buffer) /( 60.00+ 57.83)),24);
I,J]   = meshgrid([srtm_min_lon_ndx: srtm_max_lon_ndx],[srtm_max_lat_ndx: srtm_min_lat_ndx]);
_tiles = (1+srtm_max_lon_ndx-srtm_min_lon_ndx)*(1+srtm_min_lat_ndx-srtm_max_lat_ndx);
 load srtm tile from internet and unzip
l_check = 0;
f strcmp(srtm_dir, 'DL')
   dl_check = 1;
   clear srtm_dir
   
   % construct filenames
   if n_tiles &ampgt 9 % is this the limit??
       warn_msg = sprintf('WARNING: Your specified region of interest requires %i DEM tiles. \n\t \t Computation may be slow and Matlab may crash. Are you sure you wish to continue? (y/n) ',n_tiles);
       response = input(warn_msg,'s');
       if ~strcmp(response,'y')
           fprintf('aborting\n')
           return
       end
   end
   
   t0 = clock;
   format_str = '%s';
   for tile_i = 1 : n_tiles
       srtm_fN{tile_i}     = strcat('srtm_',num2str(I(tile_i),'%02.0f'),'_',num2str(J(tile_i),'%02.0f'));
       srtm_dir{tile_i}    = [module_data_dir filesep 'system' filesep srtm_fN{tile_i}];
       srtm_URL{tile_i}    = ['ftp://srtm.csi.cgiar.org/SRTM_V41/SRTM_Data_GeoTiff/' srtm_fN{tile_i} '.zip'];
       
       if exist([srtm_dir{tile_i} filesep srtm_fN{tile_i} '.tif'],'file') &amp&amp ...
               exist([srtm_dir{tile_i} filesep srtm_fN{tile_i} '.hdr'],'file')
           substr = sprintf('%s already exists - skipping', srtm_fN{tile_i});
           skip_file = 1;
       else
           % delete existing folder to avoid any unzipping issues
           if exist(srtm_dir{tile_i},'dir'), rmdir(srtm_dir{tile_i},'s'); end
           substr = sprintf('downloading and unzipping %s', srtm_fN{tile_i});
           skip_file = 0;
       end
       
       % progress management
       t_elapsed_tile   = etime(clock,t0)/tile_i;
       tiles_remaining  = n_tiles-tile_i;
       t_projected_sec   = t_elapsed_tile*tiles_remaining;
       if t_projected_sec&amplt60
           msgstr = sprintf('%s, est. %3.0f sec left (%i/%i files)',substr, t_projected_sec, tile_i,n_tiles);
       else
           msgstr = sprintf('%s, est. %3.1f min left (%i/%i files)',substr, t_projected_sec/60,tile_i,n_tiles);
       end
       fprintf(format_str,msgstr); % write progress to stdout
       format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
       
       if ~skip_file
           try
               mkdir(srtm_dir{tile_i});
               unzip(srtm_URL{tile_i}, srtm_dir{tile_i});
           catch
               http_URL = ['http://droppr.org/srtm/v4.1/6_5x5_TIFs/' srtm_fN{tile_i} '.zip'];
               urlwrite(http_URL,[srtm_dir{tile_i} '.zip']);
               unzip([srtm_dir{tile_i} '.zip'],srtm_dir{tile_i});
           end
       else     
           pause(1)
       end
   end
lse
   tmp         = srtm_dir;     clear srtm_dir
   srtm_dir{1} = tmp;          clear tmp
nd
printf('\nreading and processing DEM%s... ',cntry_str)
 struct containing the lat/lon extremes of each tile (in any order)
xtremes.lon = [];
xtremes.lat = [];
or tile_i = 1 : n_tiles
   srtm_files = dir(srtm_dir{tile_i});
   
   for file_i = 1 : numel(srtm_files)
       [~, ~, fE] = fileparts(srtm_files(file_i).name);
       
       if strcmp(fE, '.hdr')
           fid = fopen([srtm_dir{tile_i} filesep srtm_files(file_i).name]);
           scale_check = 0;
           while ~feof(fid),
               line = fgetl(fid);
               
               if scale_check
                   scale = str2num(line);
                   dlon = scale(1); dlat = scale(2);
                   scale_check =0;
               end
               if strfind(line,'ModelPixelScaleTag')
                   scale_check = 1;
               end
               
               if strfind(line,'Upper Left')
                   loc_i = strfind(line, '(');
                   loc_f = strfind(line, ')');
                   UL = str2num(line(loc_i+1:loc_f-1));
               end
               if strfind(line,'Lower Left')
                   loc_i = strfind(line, '(');
                   loc_f = strfind(line, ')');
                   LL = str2num(line(loc_i+1:loc_f-1));
               end
               if strfind(line,'Upper Right')
                   loc_i = strfind(line, '(');
                   loc_f = strfind(line, ')');
                   UR = str2num(line(loc_i+1:loc_f-1));
               end
               if strfind(line,'Lower Right')
                   loc_i = strfind(line, '(');
                   loc_f = strfind(line, ')');
                   LR = str2num(line(loc_i+1:loc_f-1));
               end
           end
           fclose(fid);
           extremes.lon = [extremes.lon UL(1) UR(1)];
           extremes.lat = [extremes.lat UL(2) LL(2)];
           break;
       end
   end
   
   for file_i = 1 : numel(srtm_files)
       [~, ~, fE] = fileparts(srtm_files(file_i).name);
       
       if strcmp(fE, '.tif') || strcmp(fE, '.tif.aux.xml')
           raw(I(tile_i),J(tile_i)).grid = imread([srtm_dir{tile_i} filesep srtm_files(file_i).name]);
           break;
       end
   end
nd
EM_grid = [];
 Concatenate tiles
or i = srtm_min_lon_ndx: srtm_max_lon_ndx
   DEM_grid_j = [];
   for j = srtm_max_lat_ndx: srtm_min_lat_ndx
       DEM_grid_j = [DEM_grid_j ; raw(i,j).grid];
   end
   DEM_grid = [DEM_grid DEM_grid_j];
nd
lear raw DEM_grid_j
eference_box = [min(extremes.lon) max(extremes.lon) min(extremes.lat) max(extremes.lat)];
EM_grid(DEM_grid== min(min(DEM_grid))) = min(DEM_grid(DEM_grid~= min(min(DEM_grid))));
EM_grid = double(DEM_grid);
 smooth the DEM if desired
f ~isempty(smooth) &amp&amp any(smooth) &amp&amp ~isnan(smooth)
   if isscalar(smooth)
       smooth_matrix = (1/smooth^2) .* ones(smooth);
   elseif ismatrix(smooth)
       smooth_matrix = smooth;
   end
   DEM_grid = filter2(smooth_matrix,DEM_grid);
nd
 store as singleton arrays in DEM structure
 [elev, lon, lat] = climada_grid2array(DEM_grid', reference_box); % OLD
LON, LAT] = meshgrid(linspace(reference_box(1),reference_box(2),size(DEM_grid,1)),...
   linspace(reference_box(3),reference_box(4),size(DEM_grid,2)));
AT = flipud(LAT);
on = reshape(LON,numel(LON),1);
at = reshape(LAT,numel(LAT),1);
lev = reshape(DEM_grid,numel(DEM_grid),1);
printf('done \n')
f exist('centroids','var') &amp&amp isstruct(centroids)
   % crop to rect
   lon_crop_ndx    = rect(1) &amplt= lon &amp lon &amplt= rect(2);
   lat_crop_ndx    = rect(3) &amplt= lat &amp lat &amplt= rect(4);
   lon_crop        = lon(lon_crop_ndx &amp lat_crop_ndx);
   lat_crop        = lat(lon_crop_ndx &amp lat_crop_ndx);
   elev_crop       = elev(lon_crop_ndx &amp lat_crop_ndx);
   
   DEM.elevation_m     = elev_crop';
   DEM.lon             = lon_crop';
   DEM.lat             = lat_crop';
   
   n_centroids = numel(centroids.centroid_ID);
   fprintf('processing centroid elevation... ');
   t0 = clock;
   format_str = '%s';
   if n_tiles &ampgt 2
       for centroid_i = 1: n_centroids
           r_i = climada_geo_distance(centroids.lon(centroid_i),centroids.lat(centroid_i),lon_crop,lat_crop);
           %r_i = sqrt((centroids.lon(centroid_i)-lon_crop).^2 + (centroids.lat(centroid_i)-lat_crop).^2);
           [~,ndx] = min(r_i);
           DEM.centroid_ID(ndx) = centroid_i;
           centroids.elevation_m(centroid_i) = elev_crop(ndx)';
           % the progress management
           mod_step = 100;
           if mod(centroid_i,mod_step)==0
               t_elapsed_event   = etime(clock,t0)/centroid_i;
               events_remaining  = n_centroids-centroid_i;
               t_projected_sec   = t_elapsed_event*events_remaining;
               if t_projected_sec&amplt60
                   msgstr = sprintf('est. %3.0f sec left (%i/%i centroids)',t_projected_sec,   centroid_i,n_centroids);
               else
                   msgstr = sprintf('est. %3.1f min left (%i/%i centroids)',t_projected_sec/60,centroid_i,n_centroids);
               end
               fprintf(format_str,msgstr); % write progress to stdout
               format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
           end
       end
   else
       
       % F_DEM = scatteredInterpolant(DEM.lon',DEM.lat',DEM.elevation_m');
       F_DEM = scatteredInterpolant(lon_crop,lat_crop,elev_crop);
       centroids.elevation_m = F_DEM(centroids.lon',centroids.lat')';
       fprintf('done \n')
   end
   fprintf(format_str,sprintf('processing centroid elevation%s took %3.0f seconds \n',cntry_str, etime(clock,t0)));
   
   if ~dl_check % only necessary when existing data is selected, avoid warning message due to imperfect cropping
       % deal with DEM edges if they do not reach extent of centroids
       if min(lon) &ampgt min(centroids.lon) || max(lon) &amplt max(centroids.lon)
           cprintf([1 0.25 0.25], ['WARNING: longitudinal extent of centroids exceeds '...
               'that of DEM \n \t \t Elevation not processed for some centroids \n'])
       end
       if min(lat) &ampgt min(centroids.lat) || max(lat) &amplt max(centroids.lat)
           cprintf([1 0.25 0.25], ['WARNING: latitudinal extent of centroids exceeds '...
               'that of DEM \n \t \t Elevation not processed for some centroids \n'])
       end
   end
   
   centroids.elevation_m(min(lon) &ampgt centroids.lon) = NaN;
   centroids.elevation_m(max(lon) &amplt centroids.lon) = NaN;
   centroids.elevation_m(min(lat) &ampgt centroids.lat) = NaN;
   centroids.elevation_m(max(lat) &amplt centroids.lat) = NaN;
   
   if ~exist('rect','var') || isempty(rect)
       rect = [min(DEM.lon) max(DEM.lon) min(DEM.lat) max(DEM.lat)];
   end
   
lseif ~isempty(rect)
   
   if min(lon) &ampgt rect(1) || max(lon) &amplt rect(2)
       cprintf([1 0.25 0.25], ['WARNING: DEM does not cover longitudinal extent'...
           'defined by centroids rect \n \t \t Spatial extent of centroids limited to DEM \n'])
   end
   
   if min(lat) &ampgt rect(3) || max(lat) &amplt rect(4)
       cprintf([1 0.25 0.25], ['WARNING: DEM does not cover latitudinal extent'...
           'defined by centroids rect \n \t \t Spatial extent of centroids limited to DEM \n'])
   end
   
   fprintf('generating centroids from DEM...');
   
   % crop to rect
   lon_crop_ndx    = rect(1) &amplt= lon &amp lon &amplt= rect(2);
   lat_crop_ndx    = rect(3) &amplt= lat &amp lat &amplt= rect(4);
   lon             = lon(lon_crop_ndx &amp lat_crop_ndx);
   lat             = lat(lon_crop_ndx &amp lat_crop_ndx);
   elev            = elev((lon_crop_ndx &amp lat_crop_ndx));
   
   DEM.elevation_m     = elev';
   DEM.lon             = lon';
   DEM.lat             = lat';
   
   % Generate centroids struct at same resolution as DEM if not provided
   centroids.lon           = lon';
   centroids.lat           = lat';
   centroids.elevation_m   = elev';
   n_centroids             = numel(centroids.lon);
   centroids.centroid_ID   = [1:n_centroids];
   DEM.centroid_ID         = [1:n_centroids];
   centroids.onLand        = ones(1,n_centroids);
   centroids.onLand(elev&amplt0)= 0; % May be inaccurate when there are land points below sea level, but much faster than using inpolygon
   
   if exist('shapes','var')
       n_centroids = numel(centroids.lon);
       % accomodate for both climada global shp files, as well as shp
       % files downloaded from http://www.diva-gis.org/gdata
       if isfield(shapes,'NAME')  &amp&amp length(shapes) == 1
           for i = 1 : n_centroids
               centroids.country_name{i} = shapes.NAME;
           end
           centroids.admin0_name = shapes.NAME;
       elseif exist('country_name','var')
           for i = 1 : n_centroids
               centroids.country_name{i} = country_name;
           end
           centroids.admin0_name = country_name;
       end
       if isfield(shapes,'ADM0_A3')  &amp&amp length(shapes) == 1
           centroids.admin0_ISO3 = shapes.ADM0_A3;
       elseif exist('country_name','var')
           for i = 1 : n_centroids
               centroids.country_name{i} = country_ISO3;
           end
           centroids.admin0_name = country_ISO3;
       end
   end
   fprintf(' done \n');
lse
   DEM.elevation_m = elev';
   DEM.lon         = lon';
   DEM.lat         = lat';
   rect            = reference_box;
nd
lear elev lon lat
f ~isempty(DEM_save_file) &amp&amp ~strcmp(DEM_save_file,'NO_SAVE')
   save(DEM_save_file,'DEM');
nd
f isfield(centroids, 'filename')
   save(centroids.filename,'centroids');
nd
f check_plot
   fprintf('plotting DEM (might take a while)... ')
   % relief plot
   figure('Name', '2D Relief Plot', 'color', 'w');
   hold on
   title(sprintf('Digital Elevation Model %s', cntry_str))
   
   if isempty(which('climada_DEM_plot'))
       fprintf('Download DEM plotting function from http://ch.mathworks.com/matlabcentral/fileexchange/36380-dem--shaded-relief-image-plot--digital-elevation-model-\n')
       fprintf('and rename dem -&ampgt climada_DEM_plot for awesome relief plot \n')
       fprintf('using imagesc instead\n')
       [s_x,s_y]   = size(DEM_grid);
       tmp_x       = linspace(reference_box(1),reference_box(2),s_x);
       tmp_y       = linspace(reference_box(3),reference_box(4),s_y);
       imagesc(tmp_x,tmp_y,DEM_grid)
   else
       [s_y,s_x]   = size(DEM_grid);
       tmp_x       = linspace(reference_box(1),reference_box(2),s_x);
       tmp_y       = linspace(reference_box(3),reference_box(4),s_y);
       if numel(DEM_grid) &amplt= (2 * 6001 * 6001)
           climada_DEM_plot(tmp_x,fliplr(tmp_y),DEM_grid, 'NoDecim')
       else
           climada_DEM_plot(tmp_x,fliplr(tmp_y),DEM_grid)
       end
   end
   xlabel('Longitude');
   ylabel('Latitude');
   axis equal
   axis(rect)
   set(gca,'Ydir','normal')
   
   shape_plotter(shapes,[],[],[],'linewidth',2,'color','r')
   
   hold off
   fprintf('done\n')
nd
eturn
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_90m_DEM.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_fl_encode">
<H2>climada_fl_encode</H2></A>
<font color="blue">function hazard_fl=climada_fl_encode(centroids,hazard_fl) </font>
lon_i lon_j] = size(centroids.lon);
 find unique lat lons
f lon_j == 1 % was lon_i
   [lon_lat,indx, indx2] = unique([centroids.lon centroids.lat],'rows');
lseif lon_i == 1 % was lon_j
   [lon_lat,indx, indx2] = unique([centroids.lon;centroids.lat]','rows');
lse
   fprintf('Please check the dimensions of centroids.lon and centroids.lat.\n')
   return
nd
 start encoding
_centroids             = length(indx);
 n_assets            = length(assets.Value);
entroids.centroid_index = centroids.lon*0; % init
or centroids_i=1:n_centroids
   centroids_i
  % if climada_global.waitbar,
  waitbar(centroids_i/n_centroids);
  %end
   
   dist_m                       = climada_geo_distance(centroids.lon(indx(centroids_i)),centroids.lat(indx(centroids_i)),hazard_fl.lon,hazard_fl.lat);
   [min_dist,min_dist_index]    = min(dist_m);
   
   % set closest centroids position to zero if centroids is too far away from hazard_fl (depends on peril ID)
     if min_dist&ampgtmax_distance_to_centroids
         min_dist_index = 0;
     end
   indx3                        = find(indx2 == centroids_i);
   centroids.centroid_index(indx3) = min_dist_index;
   hazard_fl.value=
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_fl_encode.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_fl_onland">
<H2>climada_fl_onland</H2></A>
<font color="blue">function  haz_temp=climada_fl_onland(haz_temp) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_fl_onland
 PURPOSE:
   checking if evaluated centroids are onland, if not sets values to 0
 EXAMPLE:
   hazard(i)=climada_fl_onland(hazard(i));

   INPUTS:
   haz_temp:   A single event hazard 

 OUTPUTS:
  haz_temp:    The checked single event hazard

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

uses climada_tc_onland to evaluate if the centroids of the hazard are
onland 
or i=1:length(haz_temp)
   if ~isempty(haz_temp{1,i});
   evaluation=haz_temp{1,i};
   
   evaluation=climada_tc_on_land(evaluation);
   
   
   %evaluation.lat(evaluation.onLand==0)=[];
   %evaluation.lon(evaluation.onLand==0)=[];
   evaluation.value(evaluation.onLand==0)=0;
   haz_temp{1,i}=evaluation;
   clear evaluation
   display(sprintf('checked return period %d from %d',i,length(haz_temp)))
   else
   display(sprintf('skipped return period %d from %d',i,length(haz_temp)))   
   end
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_fl_onland.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_flood_module">
<H2>climada_flood_module</H2></A>
%function [hazard,S,DEMf]=climada_flood_module
 climada
 MODULE:
   flood
 NAME:
   climada_module_flood
 PURPOSE:
   Calculates a flood hazard including return periods from 1 to 500 years.
   Runs the entire flood module set
 EXAMPLE:
   hazard=climada_module_flood
   INPUTS:
   none, as the country name is asked for in a popup windows

 OUTPUTS:
   hazard:      A hazard struct, containing lon, lat, frequency (1/return
                period) and intensity
   S:           The stream structure. Visualize using plot(S)
   DEMf:        The smoothened DEM layer
 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

______________________________
initial parameters and settings:
 Empty variables
ax_ind_rp=[];
 Smoothing
arameter.smot='on';%[off];
centroids cleanup
arameter.remote_centroid_cleanup='off';
river network
arameter.accum_th=30000;
 Crosssection parameters
arameter.crosssect_width=0.1;
arameter.crossect_dy_dist=0.001;
arameter.smoothing_dist=0.005;
___________________________________
 1. choose a country
%centroids=climada_centroids_generate('',1,1,'NO_SAVE');
entroids = climada_centroids_generate([7 8 46 46.5]); % CHE Valais
Create the DEM layer for the country, retrieve the SRTM file if not loaded already
 next returns DEM.lon,lat and elevation_m as vectors
DEM]=climada_read_srtm_DEM('DL',centroids);
 next returns DEM.x,y and h as matrices
[DEM,srtm_info]=climada_srtm_get(centroids,0,0,1); % climada function
2. prepare the necessary input files
 2.1.1 interpolate the rainfall on the DEM resolution
 eleven return periods based on the available rainfall data are calculated
and stored in a weigthobject
long calculation time
the SRTM rainfall is loaded
WO_object,precip]=DEM_rainfall(DEM);
the return periods are interpolated based on the current (approx. 40 y) data
WO_obj]=rain_statistics(precip,DEM);
 2.1.2 Create an equal cellsized rainfall grid from colum
option: convert lat lon to UTM, parameters can be set in [meters] instead of degree lat/lon
convert lat lon to x y (takes a long time)
[DEM.x,DEM.y,DEM.utmzone] = deg2utm(DEM.lat,DEM.lon);
obtain a grid from the DEM vector
DEM] =vec2grid(DEM);
 3 Convert DEM into matlab objects
EM_2=GRIDobj(DEM.lon_vec,DEM.lat_vec,DEM.grid);
 4 preprepare the DEM; layer is smoothened and sinks are filled,
if DEM is good quality, no preprocessing like this is needed
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_flood_module.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_flood_plot">
<H2>climada_flood_plot</H2></A>
climada_flood_plot
options to plot different floodmodel attributes
plot the DEM
plot the river network
lot(S)
plot the rivernetwork elevation profile
lotdz(S(1),DEM_2)
plot single river elevation profiles based on
igure(3);plot(SW.xyz{1,7})
plot single river original elevation profiles based on
igure(3);plot(SW.zd0{1,7}(:,1))
plot the strahler stream order
igure(3); 
plot single swathobj crosssection parts
=37;figure(2)
or  m=3150:3350 %m=3200:3300;
   plotclr(SP.lat{1,b}(:,m),SP.lon{1,b}(:,m),SP.value{1,b}(:,m),'',5,1);
   m
nd
xis ij
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_flood_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_grid2array">
<H2>climada_grid2array</H2></A>
<font color="blue">function [data, x, y] = climada_grid2array(data_grid, x_vector, y_vector) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_grid2array
 PURPOSE:
   Restructure gridded data into singleton arrays. For consistency with
   imagesc, the first index in data_grid corresponds to the x coords,
   while the second index corresponds to the y coords. Used in
   climada_read_srtm_DEM, read_APHRO_MA_V1101 and climada_rf_hazard_set
 CALLING SEQUENCE:
 EXAMPLE:
 INPUTS:
   data_grid:  Gridded data  
 OPTIONAL INPUT PARAMETERS:
   x_vector:   Monotonically in/decreasing vector defining the x values of
               each of the columns of the data grid. If y_vector is left
               empty, x_vector can also be a vector of size 4, defining
               the corners of the grid as [min(x) max(x) min(y) max(y)]
   y_vector:   Monotonically in/decreasing vector defining the x values of
               each of the rows of the data grid.
 OUTPUTS:
   data:       The original data structured as a singleton array 
   x:          The x data structured as singleton array, same length as data array
   y:          The y data structured as singleton array, same length as data array
 MODIFICATION HISTORY:
 Gilles Stassen 20150107
 Gilles Stassen 20150224 major cleanup
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_grid2array.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_encode_distance">
<H2>climada_hazard_encode_distance</H2></A>
<font color="blue">function hazard = climada_hazard_encode_distance(hazard,entityORassetsORcentroids,cutoff) </font>
 climada
 MODULE:
   flood
 NAME:
   climada_hazard_encode_distance
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Convert landslide hazard intensity (landslide depth(m))
   into distance between an asset and the nearest centroid with nonzero
   intensity. Distance is transformed into intensity in the form of (y = mx+b), 
   which means increasing intensity with increasing damage, 
   intensity = 1 - 1/cutoff * distance_m
   Minimum distance is set to  1m, which translates into the maximum intensity 1.
   The lat/lon coordinates of the hazard are overwritten by the asset
   lat/lon coordinates
   A default distance cutoff, when it can be assumed that no asset is
   affected anymore is introduced at 1000 m.
 CALLING SEQUENCE:
   hazard = hazard_distance_convert(hazard,entity,cutoff)
 EXAMPLE:
   hazard = hazard_distance_convert(hazard,entity,250)
 INPUTS:
   hazard: landslide hazard structure, intensity given as meters soildepth
   entity: climada entity structure, with .assets.lon and .assets.lat
 OPTIONAL INPUT PARAMETERS:
   cutoff: default 1000m, can be set to other value
 OUTPUTS:
   hazard: a climada structure with lat/lon that equal the entity.assets.lat/lon
           and intensity as 1-1/cutoff*distance_m (-)
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20150708, initial
 Lea Mueller, muellele@gmail.com, 20150713, intensity as 1-1/cutoff*distance_m instead of distance
 Gilles Stassen, gillesstassen@hotmail.com, 20150803, faster (~30x) alternative to knnsearch; argin entity -&ampgt entityORassetsORcentroids
 Gilles Stassen, 20150805, elevation cutoff. Entity points higher in elevation than land slide excluded
 Lea Mueller, muellele@gmail.com, 20150915, bugfix when calculate distance_m from intensity
 Lea Mueller, muellele@gmail.com, 20151106, move to flood
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_hazard_encode_distance.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_binary_plot">
<H2>climada_ls_hazard_binary_plot</H2></A>
<font color="blue">function fig = climada_ls_hazard_binary_plot(hazard) </font>
 climada plot ls binary hazard
 MODULE:
   flood
 NAME:
   climada_ls_hazard_binary_plot
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Plot binary landslide hazard, all events on one map
 PREVIOUS STEP:
   hazard_binary = climada_ls_hazard_set_binary(centroids)
 NEXT STEP:
   hazard = climada_hazard_encode_distance(hazard,centroids,cutoff);
 CALLING SEQUENCE:
   fig = climada_ls_hazard_binary_plot(hazard)
 EXAMPLE:
   fig = climada_ls_hazard_binary_plot;
 INPUTS:
   hazard:  a climada hazard stucture with binary landslide
   information (.intensity is either 1 or 0)
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   fig: handle of map with landslide events
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init
 -
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('hazard', 'var'), hazard = []; end
f isempty(hazard), hazard = climada_hazard_load; end   
        
 visualize binary ls hazard on a map
 ------------------------------
 delete nans if there are any
azard.intensity(isnan(hazard.intensity)) = 0;
xlim = [min(hazard.lon) max(hazard.lon) min(hazard.lat) max(hazard.lat)];
_events = hazard.event_count;
_colors = jet(n_events);
 show a maximum number of events
vent_step = 1;
ax_events_to_show = 100;
f n_events&ampgtmax_events_to_show, event_step = round(n_events/max_events_to_show);end
ig = climada_figuresize(0.5,0.7);
 plot(entity.assets.lon, entity.assets.lat,'.','linewidth',0.2,'markersize',0.8,'color',[255 64 64 ]/255);
old on
egendstr = []; h = []; counter = 0;
or e_i = 1:event_step:n_events
   is_event = logical(hazard.intensity(e_i,:));
   if any(is_event)
       counter = counter+1;
       %hold on; plot3(hazard.lon(is_event), hazard.lat(is_event), ones(sum(is_event))*3000, 'dr','linewidth',2,'markersize',5,'color',[255 64 64 ]/255)
       h(counter) = plot(hazard.lon(is_event), hazard.lat(is_event),'dr','linewidth',2,'markersize',5,'color',n_colors(e_i,:));
       hold on; 
       %plot(polygon_canas.X, polygon_canas.Y, 'b-');
       legendstr{counter} = sprintf('Event %d',e_i);
   end
nd
itlestr = 'LS hazard binary';
ry titlestr = sprintf('%s hazard (%s), %d events, %d',hazard.peril_ID, hazard.units, n_events, hazard.reference_year);end
itle(titlestr); axis(axlim); box on; 
limada_figure_axis_limits_equal_for_lat_lon(axlim); climada_figure_scale_add('',1,1)
egend(h,legendstr,'location','eastoutside')
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_ls_hazard_binary_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_set">
<H2>climada_ls_hazard_set</H2></A>
<font color="blue">function [hazard, centroids, fig] = climada_ls_hazard_set(centroids,n_events,hazard_set_file,... </font>
                                       wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                       n_downstream_cells,focus_area,polygon_correction,random_trigger_condition,...
                                       check_plot)
 Generate a landslide hazard set
 MODULE:
   flood
 NAME:
   climada_ls_hazard_set
 PURPOSE:
   This is a all-in-one function to generate a landslide hazard set. The 
   landslide events are based solely on topographical information 
   (SRTM 90m digital elevation data) and calculates slope and 
    topographical wetness index. We create first a binary hazard,
   encode to distance and plot figures if required.
   invokes 
       - climada_ls_hazard_set_binary
       - climada_hazard_encode_distance
   and for plots
       - climada_ls_hazard_binary_plot
       - climada_map_plot
       - climada_hazard_stats
       - climada_hazard_stats_figure   
 PREVIOUS STEP:
   create centroids, select a rectangle box to create the landslide hazard
   centroids = climada_centroids_elevation_add;
 CALLING SEQUENCE:
   [hazard, centroids, fig] = climada_ls_hazard_set(centroids,n_events,hazard_set_file,...
                                         wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                         n_downstream_cells,focus_area,polygon_correction,random_trigger_condition,...
                                         check_plot)
 EXAMPLE:
   hazard = climada_ls_hazard_set(centroids)
   check_plot = 1;
   [hazard, centroids, fig]  = climada_ls_hazard_set([-89.145 -89.1 13.692 13.727],'','','','','','','','','','',check_plot)
 INPUTS:
   centroids:  a climada centroids stucture (ideally including topographical
   information) or a rectangle to define lon/lat box, if not given, the
   user can select a rectangle by first selecting a country and then drawing
   a rectangle on a map
 OPTIONAL INPUT PARAMETERS:
   n_events: number of events
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat)
       &ampgt promted for if not given
   wiggle_factor_TWI:    an array, default is 0.35, to modify topographical
                         wetness factor, which is a number between 0 and 1.4
   condition_TWI:        an array, default is 0.95, to define a minimum
                         topographical wetness index, where a landslide occurs
   wiggle_factor_slope:  an array, default is 0.35, to modify the slope factor, 
                         which is a number between 0 and 1
   condition_slope:      an array, default is 0.45, to define a minimum slope
                         where a landslide occurs
   n_downstream_cells:   number of downstream cells where the landslide is extended
   focus_area:           a polygon to define the focus area (with focus_area.lon, focus_area.lat),
                         landslides only in the given area will be filtered 
                         and the other areas are cut out
   polygon_correction:   a polygon to define an area where less landlislides should occur
   random_trigger_condition: a number between 0 and 1, 1 prevents all landslide 
                         in the polygon_correction area, 0 does not inhibit any
                         landlides in the polygon_correction area
   check_plot:          set to 1 if you want to see maps (elevation, slope, hazard, etc)
 OUTPUTS:
   hazard: a climada hazard structure with binary landslide information
       .peril_ID: 'LS'
       .date: the creation date of the set
       .intensity(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i, binary, 1 indicates a landslide, 0 no landslide
       .frequency(event_i): the frequency of each event
       .matrix_density: the density of the sparse array hazard.intensity
       .filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
   centroids: a climada centroids structure with fields
       .lon
       .lat
       .elevation_m, elevation in meters
       .slope_deg, slope in degree
       .TWI, topographical wetness index
       .aspect_deg, spect in degree
   fig: handle of figures (maps with elevation, slope, landslide
        hazard,etc)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20151124, init
 -
 init
azard = []; fig = [];
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('centroids', 'var'), centroids = []; end
f ~exist('n_events', 'var'), n_events = []; end
f ~exist('hazard_set_file', 'var'), hazard_set_file = []; end
f ~exist('wiggle_factor', 'var'), wiggle_factor_TWI = []; end
f ~exist('TWI_condition', 'var'), condition_TWI = []; end
f ~exist('wiggle_factor_slope', 'var'), wiggle_factor_slope = []; end
f ~exist('slope_condition', 'var'), condition_slope = []; end
f ~exist('n_downstream_cells', 'var'), n_downstream_cells = []; end
f ~exist('focus_area', 'var'), focus_area = []; end
f ~exist('polygon_correction', 'var'), polygon_correction = []; end
f ~exist('random_trigger_condition', 'var'), random_trigger_condition = []; end
f ~exist('check_plot', 'var'), check_plot = 0; end
 create binary landslide hazard
hazard_binary, centroids]  = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,...
                                   wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                   n_downstream_cells,focus_area,polygon_correction,random_trigger_condition);
              
 encode binary hazard to distance, so that we have the distance to
 landslides as intensity
utoff = 1000;
azard = climada_hazard_encode_distance(hazard_binary,centroids,cutoff);
 save hazard
pathname, filename, ext] = fileparts(hazard.filename);
f ~exist(pathname,'dir')
   hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep 'LSXX_hazard.mat'];
   [filename, pathname] = uiputfile(hazard_set_file, 'Save LS hazard set as:');
   if isequal(filename,0) || isequal(pathname,0)
       return; % cancel
   else
       hazard_set_file = fullfile(pathname,filename);
   end
lse
   filename = [strrep(filename,'binary','') 'distance'];
   hazard_set_file = fullfile(pathname,filename);
nd
printf('Save landslide (LS) hazard set (encoded to distance) as %s\n',hazard_set_file);
ave(hazard_set_file,'hazard')
f check_plot   
   % create landslide binary event map
   fig = climada_ls_hazard_binary_plot(hazard_binary);
   
   % plot centroids with characteristics (elevation, slope, twi, etc)
   fieldname_to_plot = {'elevation_m' 'slope_deg' 'TWI' 'aspect_deg'};
   plot_method = 'plotclr';
   [~, fig_temp] = climada_map_plot(centroids,fieldname_to_plot,plot_method);
   
   % plot hazard statistics
   hazard.orig_years = 1000; % we set the number of years to 1000 to have nice images, but please check if this is suitable
   hazard.frequency = ones(size(hazard.event_ID))*(1./hazard.orig_years);
   
   return_periods = [10 25 50 100 150 200];
   hazard_stats = climada_hazard_stats(hazard,return_periods,0);
   fig_temp_2 = climada_hazard_stats_figure(hazard_stats,return_periods);
  
   % concatenate figure handles
   fig = [fig fig_temp fig_temp_2];
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_ls_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ls_hazard_set_binary">
<H2>climada_ls_hazard_set_binary</H2></A>
<font color="blue">function [hazard, centroids]  = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,... </font>
                                   wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                                   n_downstream_cells,focus_area,polygon_correction,random_trigger_condition)
 Generate a binary landslide hazard set
 MODULE:
   flood
 NAME:
   climada_ls_hazard_set_binary
 PURPOSE:
   This is a function that is usually called from climada_ls_hazard_set.
   Generate a binary landslide hazard set based solely on topographical
   information (slope and topographical wetness index)
 PREVIOUS STEP:
   centroids = climada_centroids_elevation_add;
 CALLING SEQUENCE:
   hazard = climada_ls_hazard_set_binary(centroids,n_events,hazard_set_file,...
                    wiggle_factor_TWI,condition_TWI, wiggle_factor_slope,condition_slope,...
                    n_downstream_cells,focus_area,polygon_correction,random_trigger_condition)
 EXAMPLE:
   hazard = climada_ls_hazard_set_binary(centroids)
   hazard = climada_ls_hazard_set_binary([-89.145 -89.1 13.692 13.727])
   hazard = climada_ls_hazard_set_binary
 INPUTS:
   centroids:  a climada centroids stucture (ideally including topographical
   information) or a rectangle to define lon/lat box, if not given, the
   user can select a rectangle by first selecting a country and then drawing
   a rectangle on a map
 OPTIONAL INPUT PARAMETERS:
   n_events: number of events
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat)
       &ampgt promted for if not given
   wiggle_factor_TWI:    an array, default is 0.35, to modify topographical
                         wetness factor, which is a number between 0 and 1.4
   condition_TWI:        an array, default is 0.95, to define a minimum
                         topographical wetness index, where a landslide occurs
   wiggle_factor_slope:  an array, default is 0.35, to modify the slope factor, 
                         which is a number between 0 and 1
   condition_slope:      an array, default is 0.45, to define a minimum slope
                         where a landslide occurs
   n_downstream_cells:   number of downstream cells where the landslide is extended
   focus_area:           a polygon to define the focus area (with focus_area.lon, focus_area.lat),
                         landslides only in the given area will be filtered 
                         and the other areas are cut out
   polygon_correction:   a polygon to define an area where less landlislides should occur
   random_trigger_condition: a number between 0 and 1, 1 prevents all landslide 
                         in the polygon_correction area, 0 does not inhibit any
                         landlides in the polygon_correction area
 OUTPUTS:
   hazard: a climada hazard structure with binary landslide information
       .peril_ID: 'LS'
       .date: the creation date of the set
       .intensity(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i, binary, 1 indicates a landslide, 0 no landslide
       .frequency(event_i): the frequency of each event
       .matrix_density: the density of the sparse array hazard.intensity
       .filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150911, init
 Lea Mueller, muellele@gmail.com, 20150920, add polygon_correction with a random trigger condition, to reduce landslides in a given polygon
 Lea Mueller, muellele@gmail.com, 20151124, return centroids as output, use climada_hazard_focus_area
 Lea Mueller, muellele@gmail.com, 20151124, call from climada_ls_hazard_set
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_centroids_TWI_calc from centroids_TWI
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_hazard_crop from climada_hazard_focus_area
 -
azard = []; % init
lobal climada_global
f ~climada_init_vars, return; end
 check arguments
f ~exist('centroids', 'var'), centroids = []; end
f ~exist('n_events', 'var'), n_events = []; end
f ~exist('hazard_set_file', 'var'), hazard_set_file = []; end
f ~exist('wiggle_factor', 'var'), wiggle_factor_TWI = []; end
f ~exist('TWI_condition', 'var'), condition_TWI = []; end
f ~exist('wiggle_factor_slope', 'var'), wiggle_factor_slope = []; end
f ~exist('slope_condition', 'var'), condition_slope = []; end
f ~exist('n_downstream_cells', 'var'), n_downstream_cells = []; end
f ~exist('focus_area', 'var'), focus_area = []; end
f ~exist('polygon_correction', 'var'), polygon_correction = []; end
f ~exist('random_trigger_condition', 'var'), random_trigger_condition = []; end
f isnumeric(centroids) &amp&amp numel(centroids) == 4
   % we have a box that defines where centroids should be created on 90m
   % resolution (given by SRTM)
   % return
   centroids = climada_centroids_elevation_add('',centroids);
nd
f isempty(centroids) 
   % create centroids by asking user for a country and to define a
   % rectangle region on the figure
   % return
   centroids = climada_centroids_elevation_add('','');
nd
 PARAMETERS
f isempty(n_events); n_events = 100; end
f isempty(wiggle_factor_TWI); wiggle_factor_TWI = 0.35; end
f isempty(condition_TWI); condition_TWI = 0.95; end
f isempty(wiggle_factor_slope); wiggle_factor_slope = 0.2; end
f isempty(condition_slope); condition_slope = 0.45; end
f isempty(n_downstream_cells); n_downstream_cells = 5; end
f isempty(random_trigger_condition); random_trigger_condition = 0; end
 prompt for hazard_set_file if not given
f isempty(hazard_set_file) % local GUI
   hazard_set_file      = [climada_global.data_dir filesep 'hazards' filesep 'LSXX_hazard_binary.mat'];
   [filename, pathname] = uiputfile(hazard_set_file, 'Save LS (binary) hazard set as:');
   if isequal(filename,0) || isequal(pathname,0)
       return; % cancel
   else
       hazard_set_file = fullfile(pathname,filename);
   end
nd
 complete path, if missing
fP,fN,fE] = fileparts(hazard_set_file);
f isempty(fP),hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep fN fE];end
% load template for hazard-structure
azard_example_file = [climada_global.data_dir filesep 'hazards' filesep 'TCNA_today_small.mat'];
f exist(hazard_example_file,'file')
   load(hazard_example_file)
lse
   fprintf('No hazard example found to be loaded. \n')
nd
azard_ex = hazard;
 overwrite template hazrd with actual information
azard.lon = centroids.lon;
azard.lat = centroids.lat;
azard.centroid_ID = 1:numel(hazard.lon);
azard.peril_ID         = 'LS';
azard.orig_years       = 10000;
azard.orig_event_count = n_events;
azard.event_count      = n_events;
azard.event_ID         = 1:n_events;
azard.orig_event_flag  = ones(1,n_events);
azard.yyyy             = ones(1,n_events);
azard.mm               = ones(1,n_events);
azard.dd               = ones(1,n_events);
azard.intensity        = sparse(n_events,numel(hazard.lon));
azard.name             = cell(1,n_events);
azard.frequency        = ones(1,n_events)/hazard.orig_years;
azard.comment          = centroids.comment;
azard.date             = datestr(now);
azard.units            = 'binary';
azard.orig_yearset     = [];
azard.filename         = hazard_set_file;
azard.matrix_density   =  0.01; % estimate
 n_centroids = length(centroids.centroid_ID);
f ~isfield(centroids,'slope_deg')
   fprintf('Add topographical characteristics to the centroids, based on elevation\n')
   centroids = climada_centroids_TWI_calc(centroids);
nd
 calculate slope_factor as cos(slope)/sin(slope)
lope_factor = 1./(cosd(centroids.slope_deg) ./ sind(centroids.slope_deg));
lope_factor(isinf(slope_factor)) = 0;
lope_factor(slope_factor&ampgt0.55) = 0.6;
f ~isfield(centroids,'slope_factor')
   centroids.slope_factor = slope_factor;
nd
 normalize TWI
f ~isfield(centroids,'TWI_norm')
   % TWI_norm = centroids.TWI/10;
   % TWI_norm(TWI_norm&ampgt0.85) = 0.85;
   TWI_norm = centroids.TWI/10;
   TWI_norm(isnan(TWI_norm)) = 0;
   centroids.TWI_norm = TWI_norm;
nd
 % slope factor
 titlestr = 'Slope factor (-)';
 miv = 0;
 mav = 0.6;
 fig = climada_figuresize(0.5,0.6);
 plotclr(centroids.lon, centroids.lat, centroids.slope_factor, marker,markersize,cbar_on,miv,mav);
 title(titlestr); axis(axlim); box on; climada_figure_scale_add('',7,1)
 pdf_filename = sprintf('LS_slope_factor.pdf');
 print(fig,'-dpdf',[ls_dir pdf_filename])
 
 % TWI norm
 titlestr = 'TWI normalised';
 miv = 0;
 mav = 1;
 fig = climada_figuresize(0.5,0.6);
 plotclr(centroids.lon, centroids.lat, centroids.TWI_norm, marker,markersize,cbar_on,miv,mav);
 title(titlestr); axis(axlim); box on; climada_figure_scale_add('',7,1)
 pdf_filename = sprintf('LS_TWI_normalised.pdf');
 print(fig,'-dpdf',[ls_dir pdf_filename])
f ~isempty(polygon_correction)
   lon_lat_polygon = climada_concatenate_lon_lat(polygon_correction.lon,polygon_correction.lat);
   lon_lat = climada_concatenate_lon_lat(centroids.lon,centroids.lat);
   needs_correction = inpoly(lon_lat,lon_lat_polygon);
   %sum(needs_correction)
   needs_correction = find(needs_correction);
nd
 create TWI wiggle as the sum of TWI_norm + TWI_delta
 create slope wiggle as the sum of slope_factor + slope_delta
 TWI_wiggle = zeros(size(hazard.intensity)); %init
 slope_wiggle = zeros(size(hazard.intensity)); %init
elta_TWI = rand(size(hazard.intensity)) * wiggle_factor_TWI;
elta_slope = rand(size(hazard.intensity)) * wiggle_factor_slope;
or e_i = 1:n_events
   wiggle_TWI = centroids.TWI_norm + delta_TWI(e_i,:);
   wiggle_slope = centroids.slope_factor + delta_slope(e_i,:);
       
   % check where landslides occur
   ls_occurence(e_i,:) = wiggle_TWI&ampgtcondition_TWI &amp wiggle_slope&ampgtcondition_slope ;
   
   if ~isempty(polygon_correction)
       random_trigger = rand(numel(needs_correction),1);
       random_trigger(random_trigger&ampgtrandom_trigger_condition) = 1;
       random_trigger(random_trigger&amplt=random_trigger_condition) = 0;
       not_triggered = needs_correction(~random_trigger);
       ls_occurence(e_i,not_triggered) = 0;
   end
   
nd
 expand landslides to following n_cells downstream
f n_downstream_cells&ampgt1
   if ~isfield(centroids,'sink_ID_10')
       centroids = climada_flow_find(centroids);
   end
   if n_downstream_cells&ampgt10
       n_downstream_cells = 10;
       fprintf('Maximum numbers of downstream cells is 10.\n')
   end
   
   msgstr   = sprintf('Expand landslide to %d downstream cells for %i events ... ',n_downstream_cells,n_events);
   mod_step = 10; % first time estimate after 10 assets, then every 100
   if climada_global.waitbar
       fprintf('%s (updating waitbar with estimation of time remaining every 50th event)\n',msgstr);
       h        = waitbar(0,msgstr);
       set(h,'Name','Expand landslide to ownstream cells');
   else
       fprintf('%s (waitbar suppressed)\n',msgstr);
       format_str='%s';
   end
   
   % loop over all events
   for e_i = 1:n_events
       is_event = ls_occurence(e_i,:);
       centroid_list = find(is_event);
       
       % loop over centroids, that are sliding
       for i = centroid_list
           selected_sinks = centroids.sink_ID_10(i,:);
           % take only a given number of downstream cells
           if numel(selected_sinks)&ampgtn_downstream_cells
                selected_sinks = selected_sinks(1:n_downstream_cells);
           end
           if ~isempty(selected_sinks)
               is_sink = []; %init
               for s_i = 1:numel(selected_sinks)
                   if selected_sinks(s_i)&ampgt0
                       is_sink(s_i) = find(selected_sinks(s_i) == centroids.centroid_ID);
                   end
               end
               %is_sink = ismember(centroids.centroid_ID,selected_sinks);
               ls_occurence(e_i,is_sink) = ones(1,numel(is_sink));
           end
       end
       
       % the progress management
       if mod(e_i,mod_step)==0
           mod_step          = 50;
           msgstr = sprintf('%i/%i events',e_i,n_events);
           if climada_global.waitbar
               waitbar(e_i/n_events,h,msgstr); % update waitbar
           else
               fprintf(format_str,msgstr); % write progress to stdout
               format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
           end
       end
   
   end
   ls_occurence = logical(ls_occurence);
nd
 create sparse matrix
azard.intensity = sparse(ls_occurence);
f climada_global.waitbar
   close(h) % dispose waitbar
lse
   fprintf(format_str,''); % move carriage to begin of line
nd
 restrict hazard landslides to a given focus area (delete locations outside this area, .lon, .lat, .intensity)
f ~isempty(focus_area)
   fprintf('Filter out landslides in the given focus area.\n')
   hazard = climada_hazard_crop(hazard, focus_area);
   
     if isfield(focus_area,'lon') &amp&amp isfield(focus_area,'lat')
         polygon = climada_concatenate_lon_lat(focus_area(1).lon, focus_area(1).lat);
         
     elseif isfield(focus_area,'X') &amp&amp isfield(focus_area,'Y')
         polygon = climada_concatenate_lon_lat(focus_area(1).X, focus_area(1).Y);
         
     elseif isnumeric(focus_area) % it is already formatted as a polygon
         [i, j] = size(focus_area);
         if j == 2 &amp&amp i&ampgt2
             polygon = focus_area;
         end
     else
         fprintf('Please check the input of the focus area.\n')
         return
     end
     hazard_lon_lat = climada_concatenate_lon_lat(hazard.lon, hazard.lat);
     is_inside = inpoly(hazard_lon_lat,polygon);
     if any(is_inside)
         hazard.lon = hazard.lon(is_inside);
         hazard.lat = hazard.lat(is_inside);
         hazard.centroid_ID = 1:numel(hazard.lon);
         hazard.intensity = hazard.intensity(:,is_inside);
     end
nd
printf('Save landslide (LS) hazard set (binary) as %s\n',hazard_set_file);
ave(hazard_set_file,'hazard')
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_ls_hazard_set_binary.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_read_srtm_DEM">
<H2>climada_read_srtm_DEM</H2></A>
<font color="blue">function [DEM, centroids] = climada_read_srtm_DEM(srtm_dir, centroidsORcountry, DEM_save_file, smooth, check_plot) </font>
 climada
 MODULE:
   barisal_demo
 NAME:
   climada_read_srtm_DEM
 PURPOSE:
   Read the digital elevation model data from the files in an existing
   srtm directory. Data can be downloaded from http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp
 CALLING SEQUENCE:
   DEM = climada_read_srtm_DEM(srtm_dir, centroids, DEM_save_file, smooth, check_plot)
 EXAMPLE:
   DEM = climada_read_srtm_DEM(srtm_dir,[],[],[],1)
   DEM = climada_read_srtm_DEM
   [DEM, centroids] = climada_read_srtm_DEM(srtm_dir,[min_lon max_lon min_lat max_lat], DEM_save_file, 4,1)
 INPUTS:
   srtm_dir:   The directory of an srtm data tile folder, containing at
               least a .hdr and a .tif file. Can also be set to 'DL' which
               will initiate automatic download from SRTM website
               according to the centroid_rect given as input.
 OPTIONAL INPUT PARAMETERS:
   centroids:  If centroids are provided as an input, the DEM will contain
               elevation data sampled at the location of centroids, and
               hence will have an extra field .centroid_ID. The extra
               field is required for tc_surge_hazard_create if you wish to
               provide your own topography data (e.g. srtm).
               If this input is left empty , a
               centroids struct will be generated at the same resolution
               as the DEM.
               If set to a 4-element vector (centroids_rect), these 4
               points will define the area of interest, which is
               subsequently cropped out of the DEM.
               NOTE:   It is only sensible to provide a centroids struct
               as input if its resolution is significantly lower than that
               of the DEM, otherwise, it is much faster to generate
               centroids directly from the DEM.
   smooth:     Can either be set to an integer N (smooth by default filter
               specified by a matrix size NxN with values 1/N^2) or a
               smoothing filter. Default = [] (no smoothing).
   check plot: Specify whether to plot a relief of the DEM, default = 0
 OUTPUTS:
   DEM:        Struct containing information of the digital elevation
               model at full 90m resolution, with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
   centroids:  Climada centroids struct with fields:
               .elevation_m:   Elevation data
               .lat:           Latitude
               .lon:           Longitude
               .centroid_ID:   Only if centroids provided as input or if
                               centroids input set to 1.
               .onLand:        Set to 0 if .elevation_m &amplt0, 1 otherwise
               .admin0_name    Country name
               .admin0_ISO3    ISO 3 country code
 MODIFICATION HISTORY:
   Gilles Stassen 20150107
   Gilles Stassen 20150224     fixed some bugs in the plotting routines
                               and added messages to warn of DEM edges
   Gilles Stassen 20150225     cleanup and added automatic download and
                               unzip feature

   Jacob Anz      20150610     fixed the url DEM source

View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/climada_read_srtm_DEM.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="discharge_relation">
<H2>discharge_relation</H2></A>
discharge curves
variable declaration
   %h = river flood heigth for certain q values
   %h_norm= river base level heigth
   %Cr = factor
   %b = factor
   %base relation
   %bp_depth= breakpoint depth (specific to topography,landscape and human impact
   bp_depth=0.5;
          q=1:50;
          Cr=1;
          b=1;
          h=(Cr*log(q).^b);
          
case 5
; 
convert Accumulation object to vector [ttest,tX,tY] = GRIDobj2mat(A_quot2);
introduce rating curves
or i=1:length(flood_vec)
       flood_vec{p}(:,i) % ist die Differenz Hhe des DEM und DEM Hhe Fluss entlang der Querlinie
       %h(SW.acc(i))           Fluthhe, SW.acc(i) ist der Accum Factor auf dem Flusspunkt
       %value(i)=h(SW.acc(i))-bp_depth -flood_vec_dif{p}(:,i)          Hhe Fluss incl. Flut duch Acc - Hhe Terrain = Fluthhe
                                                    %Wenn negativ dann lsche es.
nd
create hazard struct 
or t=1:length(flood_vec)
   for j=1:length(flood_vec{1,t}(1,:))
       for i=1:length(flood_vec{1,t}(:,1))
           %function should be seperate
           value{t}(i,j)= Cr*log(SW2.xyz{1,t}(j)).^b-bp_depth -flood_vec{1,t}(i,j);
       end
   end
nd
plot new hazard struct
old on
or b=1:1%length(SW.X)
   for m=1:length(SW.X{1,b})
       plotclr(SW.X{1,b}(:,m),SW.Y{1,b}(:,m),value{1,b}(:,m));
   end

nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/discharge_relation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_calibrate">
<H2>flood_calibrate</H2></A>
<font color="blue">function max_ind_rp=flood_calibrate(SW_WO,max_ind_rp,i) </font>
floodmodel calibration code
find the maximum values acc values
or f=1:length(SW_WO.xyz); max_ind(f)=max(SW_WO.xyz{1,f});end
ax_ind_rp(i,1:length(max_ind))=max_ind;
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/flood_calibrate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_hazard_create">
<H2>flood_hazard_create</H2></A>
<font color="blue">function hazard=flood_hazard_create(hazard,WO_obj) </font>
 climada
 MODULE:
   flood
 NAME:
   flood_hazard_create
 PURPOSE:
   combining the single event(return period) hazards into one combined
   hazard
 EXAMPLE:
   hazard{i}=flood_hazard_create_single(SP,100,0,0);

   INPUTS:
   hazard:     A single event hazard struct, containing lon, lat and intensity 
   WO_obj:     A weigth object struct containing the return periods

 OUTPUTS:
   hazard:     A hazard struct, containing different frequencies
               according to the return periods

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

fill the hazard struct
azard_final.lon=hazard{1}.lon;
azard_final.lat=hazard{1}.lat;
azard_final.peril_ID='FL';
azard_final.date=datestr(now);
azard_final.event_count=length(hazard);
the frequency is set as 1/years return period
azard_final.frequency= 1./(WO_obj.returnp);
delet the control event, last entry
azard_final.frequency(length(WO_obj.returnp))=[];
combine the single return period hazards;
or i=1:length(hazard)-1
   intensity(i,:)=hazard{i}.value;
nd
azard_final.intensity=sparse(intensity);
   
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/flood_hazard_create.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_hazard_create_single">
<H2>flood_hazard_create_single</H2></A>
<font color="blue">function hazard=flood_hazard_create_single(SP,cutoff_top,cutoff_bottom,plot) </font>
 climada
 MODULE:
   flood
 NAME:
   flood_hazard_create_single
 PURPOSE:
   reshaping the crossection struct into a .lat, .lon, .value vector
 EXAMPLE:
   hazard{i}=flood_hazard_create_single(SP,100,0,0);

   INPUTS:
   SP:         A crossection struct
   cutoff_top: The maximum value to reach
   cutoff_bottom: The minimum value to reach
   plot:       Option to plot the hazard

 OUTPUTS:
   hazard:      A hazard struct, containing lon, lat and intensity 

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

f ~exist('plot','var'),plot=0;end
   
create an hazard vector
azard.lon=[];hazard.lat=[];hazard.value=[];
or i=1:length(SP.lon)
       vec.lon=reshape(SP.lon{1,i},1,[]);vec.lat=reshape(SP.lat{1,i},1,[]);vec.value=reshape(SP.value{1,i},1,[]);
       hazard.lon=[hazard.lon vec.lon];
       hazard.lat=[hazard.lat vec.lat];
       hazard.value=[hazard.value vec.value];
       clear vec
nd
hazard cutoff
low value cutoff
f exist('cutoff_bottom','var')
   cutoff=find(hazard.value&ampltcutoff_bottom);
   %hazard.lon(cutoff)=[];hazard.lat(cutoff)=[];
   hazard.value(cutoff)=0;
   clear cutoff
nd
high value cutoff
f exist('cutoff_top','var')
   cutoff=find(hazard.value&ampgtcutoff_top);
   hazard.lon(cutoff)=0;%hazard.lat(cutoff)=[];hazard.value(cutoff)=[];
   clear cutoff
nd
plot the hazard
f plot==1; 
   if length(hazard.lon)&ampgt1
   plotclr(hazard.lon,hazard.lat,hazard.value,'','',1)
   axis equal
   else
       display('hazard has no entries');
   end
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/flood_hazard_create_single.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_innund_estim">
<H2>flood_innund_estim</H2></A>
<font color="blue">function [ hazard ] = flood_innund_estim(pack,delta) </font>
UNTITLED2 Summary of this function goes here
   Detailed explanation goes here
delta=2;
lot=[];
varibale initialisation
   hazard_comb.vec_x=[];
   hazard_comb.vec_y=[];
   hazard_comb.vec_z=[];
   
   hazard.vec_x=[];
   hazard.vec_y=[];
   hazard.vec_z=[];
calculate the different tiles
or m=1:length(pack)
   SW=pack{m};   

   for p=1:length(SW.xyz)
            for i=1:numel(SW.xyz{1,p})
               flood_vec{p}(:,i)=(SW.xyz{1,p}(i)+delta)&ampgtSW.Z{1,p}(:,i);
            end
   end
   
     %run on heigth level difference, future implementation
     for p=1:length(SW.xyz)
              for i=1:numel(SW.xyz{1,p})
                 flood_vec_dif{p}(:,i)=SW.xyz{1,p}(i)-SW.Z{1,p}(:,i);
              end
     end
   
   %create a hazard vector/ matrix
   for j=1:length(SW.X)
       stream_vec_x=SW.X{1,j}(:,1);
       stream_vec_y=SW.Y{1,j}(:,1);
       stream_vec_z=flood_vec{1,j}(:,1);
       for i=2:length(SW.X{1,j}(1,:))
           stream_vec_x=[stream_vec_x;SW.X{1,j}(:,i)];
           stream_vec_y=[stream_vec_y;SW.Y{1,j}(:,i)];
           stream_vec_z=[stream_vec_z;flood_vec{1,j}(:,i)];
       end
      hazard.vec_x= [stream_vec_x;hazard.vec_x];
      hazard.vec_y= [stream_vec_y;hazard.vec_y];
      hazard.vec_z= [stream_vec_z;hazard.vec_z];
      clear stream_vec_x stream_vec_y stream_vec_z
   end
 
   %combine the hazard vectors
   hazard_comb.vec_x=[hazard_comb.vec_x;hazard.vec_x];
   hazard_comb.vec_y=[hazard_comb.vec_y;hazard.vec_y];
   hazard_comb.vec_z=[hazard_comb.vec_z;hazard.vec_z];
   
nd
f exist(plot)
    plotclr(hazard.vec_x,hazard.vec_y,hazard.vec_z);
nd
 
azard=hazard_comb;
   
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/flood_innund_estim.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_remote_centroids_clean">
<H2>flood_remote_centroids_clean</H2></A>
<font color="blue">function SP=flood_remote_centroids_clean(SP,SW,mode) </font>
 climada
 MODULE:
   flood
 NAME:
   flood_remote_centroids_clean
 PURPOSE:
  Applies vector geometrics to cut overlaying crosssections
 EXAMPLE:
   SP=flood_remote_centroids_clean(SP,SW,1);

   INPUTS:
   SP:         A crossection struct 
   SW:         A swathobject crosssetion struct
   mode:       Defines if the check is done profound (0) looking 
               at much earlier (25,50) so more distant crosssections 

 OUTPUTS:
   SP:         A cleaned SP crosssection struct

 Comment:      Still not satisfying results, some crosssection overlays are
               not recognized 

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

Clean the flood points, whose inner neighbour has no flooding anymore
Goal is, to delete flood points,which have a flood level, but lay behind a
damm or mountain etc.
f ~exist('mode','var');mode=0;end 
cleanup_level, is the value below which all outside centroids with a lower flood depth are st to 0.
leanup_level=0;
utoff_dist_length=31;
the crossection vector is always uneven
nner_river_line=((length(SP.lon{1,1}(:,1))-1)/2)+1;
nner_river_line_width=(length(SP.lon{1,1}(:,1))-1)/2;
or b=1:length(SP.value)
   for m=1:length(SP.value{1,b}(1,:))
       trigger_up=0;trigger_down=0;
       for l=1:inner_river_line_width
           %up 
           if SP.value{1,b}(inner_river_line+l,m)&amplt=cleanup_level;
               trigger_up=1;
           end
           if trigger_up==1;
               SP.value{1,b}(inner_river_line+l,m)=0;
           end            
           
           %down
           if SP.value{1,b}(inner_river_line-l,m)&amplt=cleanup_level;   
               trigger_down=1;
           end
           if trigger_down==1;                
               SP.value{1,b}(inner_river_line-l,m)=0;
           end
       end
   end
nd
f mode==1
   %overlay of crosssections:
   %get the points
   %go back 5, 25 and 50 crosssections
   %loop over all stream
    for i=1:length(SW.Y) 
        %i=37;
    %loop over all crosssections
    if cutoff_dist_length &amplt length(SW.Y{1,i}(1,:))
    for index=cutoff_dist_length:length(SW.Y{1,i}(1,:))
        %cutoff_dist_length=30;
           %index=3290;
           
        m2=index;
        m1=index-30;         
       %m1=3240;
       %m2=3290;
       %vector 1
       x1=SW.X{1,i}(1,m1);
       x2=SW.X{1,i}(end,m1);
       y1=SW.Y{1,i}(1,m1);
       y2=SW.Y{1,i}(end,m1);
       %vector 2
       x3=SW.X{1,i}(1,m2);
       x4=SW.X{1,i}(end,m2);
       y3=SW.Y{1,i}(1,m2);
       y4=SW.Y{1,i}(end,m2);
       %vector analysis and construction
       % xs=x1+s(x2-x1);ys=y1+s(y2-y1);
       % xt=x3+t(x4-x3);yt=y3+t(y4-y3);
       %DGL of from
       %((x3-x1)+t(x4-x3))/(x2-x1)=((y3-y1)+t(y4-y3))/(x2-x1);
       t=((x3-x1)/(x2-x1)+(y1-y3)/(y2-y1))/((y4-y3)/(y2-y1)+(x3-x4)/(x2-x1));
       x_cross=x3+t*(x4-x3);y_cross=y3+t*(y4-y3); %based on second line
       %for t_lim &amplt t delete entries in Swathobj crosssection
       %check the different option that can occure
       for j=1:length(SW.X{1,i}(:,1))
           %left side of crosssection
           if (t&ampgt0 &amp&amp t&amplt0.5) &amp&amp (x3&ampltSW.X{1,i}(j,m2) &amp&amp SW.X{1,i}(j,m2)&ampltx_cross) &amp&amp (SW.Y{1,i}(j,m2)&ampgty_cross &amp&amp SW.Y{1,i}(j,m2)&amplty3) 
               SP.value{1,i}(j,m2)=0;
           end
           
           %right side of crosssection
           if (t&ampgt0.5 &amp&amp t&amplt1) &amp&amp (x4&ampgtSW.X{1,i}(j,m2) &amp&amp SW.X{1,i}(j,m2)&ampgtx_cross) &amp&amp (SW.Y{1,i}(j,m2)&amplty_cross &amp&amp SW.Y{1,i}(j,m2)&ampgty4) 
               SP.value{1,i}(j,m2)=0;
           end
                       
       end
       x_cross=NaN;y_cross=NaN;  
    end
    end
    end
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/flood_remote_centroids_clean.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="flood_shape_write">
<H2>flood_shape_write</H2></A>
flood_shape_write
MS] = SWATHobj2mapstruct(SW,'lines');
hapewrite(MS,['test_shape' '.shp'])
plot
igure, imageschs(DEM), hold on
apshow(MS)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/flood_shape_write.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="rain_statistics">
<H2>rain_statistics</H2></A>
<font color="blue">function [WO_obj]=rain_statistics(precip,DEM) </font>
 climada
 MODULE:
   flood
 NAME:
   rain_statistics
 PURPOSE:
   generating higher return periods from the existing rainfall data set
 EXAMPLE:
   [WO_obj]=rain_statistics(precip,DEM);

   INPUTS:
   precip:         A precipitation event set
   DEM:            The digital elevation model

 OUTPUTS:
   WO_obj:      A weight object struct containing, lon, lat, returnperiods
                and a grid matrix with the intensity

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

Derive the weightobject from rain statistics
Input: DEM,precip
get the max rainfall
daily rainfall values
set a maximum rainfall value for the region that extrapolation for higher
return periods (150,250, 500 etc. can exceed)
ax_rain_cap=500;
return periods
py_axis=[1,2,5,10,25,50,100,150,250,500];
isplay('calculating return periods:')
isplay(sprintf('%d\t',rpy_axis))
or i=1:length(precip.precip(:,1))
N,centers] = hist(precip.precip(i,:));
requ=N/length(precip.precip);
p=1./frequ;
py=rp/365;
old on
lot(rpy,centers,'*')
remove 0 respectively Inf values, as polyfit doesn't work otherwise
ndex=find(isinf(rpy));
py(index)=[];centers(index)=[];
 = polyfit(log10(rpy),centers,2);
1 = polyval(P,log10(rpy));
lot(rpy, Y1)

 for i=1:length(precip.precip(:,1))
     max_rain(i)=max(precip.precip(i,:));
 end
statistical rain analysis
timespan years
tspan=length(precip.precip)/365;
 bin_max=max(precip.precip(1,:));
 steps=10;
 step_size=bin_max/10;
 bin_steps(1)=0;
 for i=1:steps
     bin_steps(i+1)=bin_steps(i)+step_size;
 end

set the return periods to the existing one:
recip_rp(i,:) = polyval(P,log10(rpy_axis));                              %one offest due to standart event
   %cap at maximum rainfall:
   precip_rp(precip_rp&ampgtmax_rain_cap)=max_rain_cap;
lot(rpy_axis, precip_rp(i,1:10))
    %average event, special case
     if i==length(precip.precip(:,1));
 precip_rp(:,length(rpy_axis)+1)=mean(precip.precip')';
     end
nd
%
 
 %strongest event
 p_data.precip_event(:,2)=max(precip.precip')';
 
 %minimum event
 p_data.precip_event(:,3)=min(precip.precip')';
 
 %random event
 p_data.precip_event(:,4)=(precip.precip(:,100)')';
takes long but no alternative to scatteredintp is found
or i=1:length(precip_rp(1,:))
           F_p_x = scatteredInterpolant(precip.lon,precip.lat,precip_rp(:,i),'linear','nearest');
           WO_object.intensity(:,i)=F_p_x(DEM.lon,DEM.lat);
           if i&amplt=length(rpy_axis);display(sprintf('calculating %d year return period successful',rpy_axis(i)))
           else display(sprintf('calculating mean scenario successful'))
           end
nd
O_object.lon=DEM.lon;
O_object.lat=DEM.lat;
O_object.intensity=WO_object.intensity';
or i=1:length(WO_object.intensity(:,1))
   [WO_object] =vec2grid(WO_object,i);
   WO_obj.grid(:,:,i)=WO_object.grid;
nd
O_obj.lon=DEM.lon;
O_obj.lat=DEM.lat;
O_obj.returnp(1:length(rpy_axis))=rpy_axis;
O_obj.returnp(length(rpy_axis)+1)=0;                                      %the average rain event
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/rain_statistics.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="rating_curve">
<H2>rating_curve</H2></A>
<font color="blue">function output=rating_curve(input,SO) </font>
 climada
 MODULE:
   flood
 NAME:
   rating_curve
 PURPOSE:
   assigning a flood heigth value to each input value according to the rating curve
   function and its parameters
 EXAMPLE:
   output=rating_curve(input,SO)

   INPUTS:
   input:         An accumulation value, e.g. 50
   SO:           The stream order
 OUTPUTS:
   output:      A flood depth value (m)

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

function for the rating curves
The rating curves need to be calibrated for each region, country.
The sigmoid function (S Shape) represents the river bank flood the best,
but is very sensitive to the paratmeters given
parameters:
 Cr defines the maximum reachable water level,
 bd_depth represents the river channel depth
 b changes the inclination of the curve on its ascending part
 mid_input represents the input value, where the strongest inclination is
 reached
SO is the streamorder
unit: meters
f ~exist('SO','var') || SO&ampgt5; SO=1;end
id_input=25;
stream order (SO) dependant parameters
f SO==1;
       bp_depth=0;Cr=3;b=7;
lseif SO==2;
       bp_depth=0;Cr=2.8;b=7;
lseif SO==3;
       bp_depth=0;Cr=2.5;b=7;
lseif SO==4;
       bp_depth=0;Cr=2.3;b=7;
lseif SO==5;
       bp_depth=0;Cr=2;b=7;
nd
calibration value:
r=10;
different functions to choose from:
log function
output= (Cr*log(input+1).^b) - bp_depth;
sqrt function   
output= (Cr*sqrt(input).^b) - bp_depth;
sigmoid function (logistical S shape)
utput=Cr./(1+exp(-(input-mid_input)*1/b))- bp_depth;
set treshold, if flooding less than 0.1m, set to 0m.
f output&amplt0.1
   output=0;
nd
 %plot rating curve
 figure(2)
 hold on
 input=-50:100;
 % output= (Cr*log(input+1).^b); %- bp_depth;
 output= (Cr*sqrt(input+1).^b);
 plot(input,output);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/rating_curve.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="stream_elevation_correct">
<H2>stream_elevation_correct</H2></A>
<font color="blue">function [SW,SW_original]=stream_elevation_correct(SW) </font>
 climada
 MODULE:
   flood
 NAME:
   stream_elevation_correct
 PURPOSE:
   correction the continuos stream elevation for exceptional values:
   The stream elevation should always decrease downstream, so higher
   values of a following cell that are higher than the previous one, are
   set to the previous value.
 EXAMPLE:
   [SW,SW_original]=stream_elevation_correct(SW); 

   INPUTS:
   SW:         A swathobject crossection struct

 OUTPUTS:
   SW_original:      The original swathobject crosssection struct
   SW         :      The corrected swathobject crosssection struct

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init


Correct exceeding river elevation points
Reason: The elevation at the swathobj intersections is not standart
derived (contains more points than SW.zd0) and can exceed the base
elevation
savety copy
W_original=SW;
the entire stream network
or j=1:length(SW.xyz)
   %single rivers
   for i=2:length(SW.xyz{1,j})
       if SW.xyz{1,j}(i-1)&ampgtSW.xyz{1,j}(i)
           %reset value to value before: simple one step correction
           SW.xyz{1,j}(i-1)=SW.xyz{1,j}(i);
       end
       if i&ampgt3
           if SW.xyz{1,j}(i-2)&ampgtSW.xyz{1,j}(i)
               %reset value to value before: two step correction
               SW.xyz{1,j}(i-2)=SW.xyz{1,j}(i);
           end
       end       
   end
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/stream_elevation_correct.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="streamord">
<H2>streamord</H2></A>
streamorder assigning
get streamorder for each river point
create coord.vector with streamorder
[st,hs,MS]=streamorder(S);
o_vec.x=[];so_vec.y=[];so_vec.streamorder=[];
or i=1:length(MS)
   so_vec_temp.x=MS(i).X;
   so_vec_temp.y=MS(i).Y;
   so_vec_temp.streamorder(1:length(MS(i).X))=MS(i).streamorder;
   
   so_vec.x=[so_vec.x so_vec_temp.x];
   so_vec.y=[so_vec.x so_vec_temp.y];
   so_vec.streamorder=[so_vec.streamorder so_vec_temp.streamorder];
   clear so_vec_temp
nd
o_vec.xy(:,1)=so_vec.x;
o_vec.xy(:,2)=so_vec.y;
lear so_vec.x so_vec.y
or i=1:length(pack{1,1}.xy0)
   for j=1:length(pack{1,1}.xy0{1,i})
       [row,col]=find(pack{1,1}.xy0{1,i}(j,i)==so_vec.xy(:,1) &amp pack{1,1}.xy0{1,i}(j,2)==so_vec.xy(:,2));
       
       for k=1:length(row)
           temp_str_order(k)=so_vec.streamorder(row(k));
       end
       streamord{1,i}(j)=max(temp_str_order);
       clear row col temp_str_order
   end
nd
ack{1,1}.georef=streamord;
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/streamord.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="streamorder2swathobj">
<H2>streamorder2swathobj</H2></A>
<font color="blue">function SO=streamorder2swathobj(MS,SW_WO) </font>
 climada
 MODULE:
   flood
 NAME:
   streamorder2swathobj
 PURPOSE:
   adding to each crosssection point SW_WO a Strahler streamorder value (MS) in the
   same structure SO
 EXAMPLE:
   SO=streamorder2swathobj(MS,SW_WO)

   INPUTS:
   MS:         A strahler streamoder struct, similar to a shape file
   SW_WO:      A crosssection struct

 OUTPUTS:
   SO:         A crosssection struct with a Strahler streamoder value at
               each point

 MODIFICATION HISTORY:
   Jacob Anz, j.anz@gmx.net, 20151210 init

comments:leaves room for optimization to speedup
Streamorder specific
for every swath point find a rating curve value
SW.xy is the central line of SWATHobj
SW_WO.xyz -&ampgt SW_WO.xy point find the middle of the river point and a point in the MS streamorder struct.
ind=find(test_vec(:,1)==test_vec_MS(:,1)&amptest_vec(:,2)==test_vec_MS(:,2));
ind=find(MS_tot.X==SW_WO.xy{1,1}(:,1)&amp MS_tot.Y==SW_WO.xy{1,1}(:,2));
create one Streamorder vector
S_tot.X=[];MS_tot.Y=[];MS_tot.strod=[];
or i=1:length(MS)
MS_tot.X=[MS_tot.X MS(i).X];
MS_tot.Y=[MS_tot.Y MS(i).Y];
st_ord(1:length(MS(i).Y))=MS(i).streamorder;
MS_tot.strod=[MS_tot.strod st_ord];
clear st_ord
nd
find streamorder by using the middleline of the SWATHobj
or j=1:length(SW_WO.xy)
   for i=1:length(SW_WO.xy{1,j})
       index=find(SW_WO.xy{1,j}(i,1)==MS_tot.X &amp SW_WO.xy{1,j}(i,2)==MS_tot.Y);
       ind_str=MS_tot.strod(index);
       if length(ind_str)&ampgt1
           ind_temp=find(max(ind_str));                                   %Takes the maximum streamorder value, could also be set to min
           SO.x{j}(i)=MS_tot.X(index(ind_temp));
           SO.y{j}(i)=MS_tot.Y(index(ind_temp));
           SO.strod{j}(i)=ind_str(ind_temp);
           clear ind_temp index ind_str
       elseif length(ind_str==1)
           SO.x{j}(i)=MS_tot.X(index);
           SO.y{j}(i)=MS_tot.Y(index);        
           SO.strod{j}(i)=ind_str;
           clear ind_temp index ind_str
       else
           %Fill linepoints with no streamorder value with value from left neighbours (usually higher, right neighbour is lower)                     
           SO.x{j}(i)=SW_WO.xy{1,j}(i,1);
           SO.y{j}(i)=SW_WO.xy{1,j}(i,2); 
           %ind.strod{j}(i)=9999;
           SO.strod{j}(i)=SO.strod{j}(i-1);
       end
   end
   display(sprintf('preparing stream %d from %d for calculation',j,length(SW_WO.xy)))
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/flood_TEST/code/streamorder2swathobj.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="README">
<H2>README</H2></A>
f isempty(which('kml'))
   disp(repmat('_',1,80))
   disp('     _  ____  __ _      _____         _ _             ')
   disp('    | |/ /  \/  | |    |_   _|__  ___| | |__  _____ __')
   disp('    | '' &amplt| |\/| | |__    | |/ _ \/ _ \ | ''_ \/ _ \ \ /')
   disp('    |_|\_\_|  |_|____|   |_|\___/\___/_|_.__/\___/_\_\')
   disp(sprintf('\n'));
   disp('          Thanks for downloading the KML toolbox v1.4!');
   disp(sprintf('\n'));
   disp('For some cool examples on how to use the KML toolbox,');
   disp(sprintf('please check the file RunTests.m located in the folder %s',pwd));
   disp(repmat('_',1,80));
lse
   tmp = getpref('kmltoolbox','ShowDisclaimer',true);
   setpref('kmltoolbox','ShowDisclaimer',true);
   display(kml);
   setpref('kmltoolbox','ShowDisclaimer',tmp);
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/kml_toolbox/code/README.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_meteorite_hazard_set">
<H2>climada_meteorite_hazard_set</H2></A>
<font color="blue">function hazard=climada_meteorite_hazard_set </font>
 climada
 NAME:
   climada_meteorite_hazard_set
 PURPOSE:
   generate the meteorite hazard event set

   first, create a centroids file prior to calling this code:
   ...data/system/Meteorite_centroids.xls

   for 1'000'000 events:
       generation of 1000000 events took 0.107830 sec
       latitude/longitude conversion took 0.620342 sec
       diameter conversion took 1.090989 sec
       CalculationUnit interpolation took 13996.156000 sec (almost 4h)
       37272 (100.00%) CalculationUnits hit (by 1390444 events)
       matrix density 0.0037%
       storing as C:\Data\climada\climada_data\hazards\MEXX_B_Probabilistic_1e6.mat ...
       for the Test ptf: loss calculation took 10.275969 seconds, based
       upon 5000000 events @ 279 locations
 CALLING SEQUENCE:
   hazard=climada_meteorite_hazard_set
 EXAMPLE:
   hazard=climada_meteorite_hazard_set
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   hazard: a climada hazard set structure, stored automatically also 
       in ...data/hazards... struct fields are:
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one - here all=0
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY: 
 David N. Bresch, david.bresch@gmail.com, 20130317, based on work back in 20080801
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/meteorite/code/climada_meteorite_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_measure_viewer">
<H2>climada_measure_viewer</H2></A>
<font color="blue">function varargout = climada_measure_viewer(varargin) </font>
 climada_measure_viewer MATLAB code for climada_measure_viewer.fig
      climada_measure_viewer, by itself, creates a new climada_measure_viewer or raises the existing
      singleton*.

      H = climada_measure_viewer returns the handle to a new climada_measure_viewer or the handle to
      the existing singleton*.

      climada_measure_viewer('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in climada_measure_viewer.M with the given input arguments.

      climada_measure_viewer('Property','Value',...) creates a new climada_measure_viewer or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_measure_viewer_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_measure_viewer_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES
 MODULE:
   viewer
 NAME:
   climada_measure_viewer
 PURPOSE:
   plots entities, assets and damage
 CALLING SEQUENCE:
   climada_measure_viewer
EXAMPLE
   climada_measure_viewer
 INPUT:
   (all inputs are asked for by the GUI)
   entity: an entity structure, see e.g. climada_entity_load and climada_entity_read
   measures_impact: a measures_impact structure, e.g. produced by salvador_calc_measures
   type: must be specified from 'assets','benefits' and 'damage'
   unit: must be specified from 'USD' or 'people'
   timestamp: position in the measures_impact that is selected, e.g. can be specified from
                  1- current state
                  2- economic growth
                  3- moderate climate change
                  4- extreme climate change
    
  index_measures:  can be selected from a certain measure (see measure list in the measures_impactfile), default =1;
  categories:      Select a certain category from the list


 OUTPUTS:
   Graphical result
 OPTIONAL OUTPUTS:
   A .mat file with the current selection
   An excel with the curretn selection
   A .kmz file with the current selection
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20151106 init
 Jacob Anz, j.anz@gmx.net, 20151203 set new structure, make ready to process San Salvador and Barisal results
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/climada_measure_viewer.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_value_sum">
<H2>climada_value_sum</H2></A>
<font color="blue">function selection= climada_value_sum(entity,measures_impact,type,unit,timestamp,index_measures,handles) </font>
 % MODULE:
   viewer
 NAME:
   climada_value_sum
 PURPOSE:
   Select all values for a specific output of one unit (USD/people) 
   like assets, benefit or damage
 CALLING SEQUENCE:
   selection= climada_value_sum(entity,measures_impact,type,unit,timestamp,index_measures,handles)
EXAMPLE
   selection= climada_value_sum(entity,measures_impact,'assets','USD',1);
 INPUT:
   entity: an entity structure, see e.g. climada_entity_load and
       climada_entity_read
   measures_impact: a measures_impact structure, e.g. produced by salvador_calc_measures
   type: must be specified from 'assets','benefits' and 'damage'
   unit: must be specified from 'USD' or 'people'
   timestamp: identifies the position of the chosen EDS in the measures
   impact struct, e.g. can be specified from
                  1- current state
                  2- economic growth
                  3- moderate climate change
                  4- extreme climate change
                    (default is 1)
  index_measures: can be selected from a certain measure (see measure list in the measures_impactfile), default =1;
  
                 
 OPTIONAL INPUT PARAMETERS:
   handles: only used if called from the GUI (measures_viewer)
 OUTPUTS:
   selection: structure with .lon (.point_lon), .lat (.point_lat) and .value (.point_value) variables from the
   current selected values.
 MODIFICATION HISTORY:
 Jacob Anz, j.anz@gmx.net, 20151106 init
 Jacob Anz, j.anz@gmx.net, 20151203 modified the input so that
 climada_assets_select can be called if categories are not numbers but
 names

f ~climada_init_vars,return;end % init/import global variables
initialize
topper=0; index_USD=[]; index_people=[];
derive list of measures
   for i=1:length(measures_impact(timestamp).EDS)
       index_measures_list{i,1}=measures_impact(timestamp).EDS(i).annotation_name;
   end
default values
f ~exist('unit','var'); unit='USD';end
f ~exist('timestamp','var'); timestamp=1;end
f ~exist('type','var'); type='assets';end
f ~exist('index_measures','var'); index_measures=1;end
detection of peril
f exist('measures_impact','var')
   rb_peril=measures_impact(timestamp).peril_ID;
   message1=sprintf('recognized %s peril',rb_peril);
   message2=sprintf('Measure %s selected',index_measures_list{index_measures,1});
   message=[message1 ' and ' message2];
   
   %interaction with GUI (measures_viewer)
   try 
       set(handles.text15,'String',message);
   catch
       msgbox(message);
   end
nd
ategories=unique(entity.assets.Category);
f iscell(categories)
   categories{length(categories)+1}='all categories';
lse
   categories(length(categories)+1)=length(categories)+1;
nd
automatical detection of position of value_unit: USD or people
or i=1:length(categories)-1
   if iscell(categories)   
       pos=find(strcmp(entity.assets.Category,categories(i)));
       posi=pos(1);
       position{i}=entity.assets.Value_unit{posi};
   else
       pos=(find(entity.assets.Category==categories(i)));
       posi=pos(1);
       position{i}=entity.assets.Value_unit{posi};
   end
nd
   position{length(position)+1}='all categories with same unit';
or i=1:length(categories)
   if iscell(categories)
       string_vec{i}=[categories{i} '-' position{i}];
   else
       string_vec{i}=[num2str(categories(i)) ' - ' position{i}];
   end
nd
or i=1:length(string_vec)-1
   if findstr(string_vec{i},'USD')&ampgt=1
       index_USD(i)=i;
   elseif findstr(string_vec{i},'people')&ampgt=1
       index_people(i)=i;
   end
nd
ndex_USD(index_USD==0)=[];index_people(index_people==0)=[];
ategory_list_usd=categories(index_USD)';category_list_people=categories(index_people)';
f strcmp(unit,'USD')
   temp_ind_cat=category_list_usd; 
lseif strcmp(unit,'people')
   temp_ind_cat=category_list_people;
nd
   t.coord_tot=[];t.value_tot=[];
   %main part, climada_assets_select is called
   if iscell(temp_ind_cat)
           for counter=1:length(temp_ind_cat)
         
               is_selected = climada_assets_select(entity,rb_peril,unit,temp_ind_cat(counter));
               if strcmp(type,'assets');
                   coord(:,1)=entity.assets.lon(is_selected);
                   coord(:,2)=entity.assets.lat(is_selected);
                   value=entity.assets.Value(is_selected);
               elseif strcmp(type,'damage');
                  coord(:,1)= measures_impact(timestamp).EDS(index_measures).assets.lon(is_selected);
                  coord(:,2)= measures_impact(timestamp).EDS(index_measures).assets.lat(is_selected);
                  value=measures_impact(1).EDS(1).ED_at_centroid(is_selected);
               elseif strcmp(type,'benefit');
                   stopper=stopper+1;
                   if stopper==1;
                       for i=1:length(measures_impact(1).EDS)
                           benefit{i}=measures_impact(1).EDS(length(measures_impact(1).EDS)).ED_at_centroid-measures_impact(1).EDS(i).ED_at_centroid;
                       end
                   end
                  coord(:,1)= measures_impact(timestamp).EDS(index_measures).assets.lon(is_selected);
                  coord(:,2)= measures_impact(timestamp).EDS(index_measures).assets.lat(is_selected);
                  value= benefit{1,index_measures}(is_selected);
               end
                  t.coord_tot=[t.coord_tot;coord];
                  t.value_tot=[t.value_tot;value];
                  clear is_selected coord value
           end
                      
    else
           for index_cat=temp_ind_cat
               is_selected = climada_assets_select(entity,rb_peril,unit,index_cat);
               if strcmp(type,'assets');
                   coord(:,1)=entity.assets.lon(is_selected);
                   coord(:,2)=entity.assets.lat(is_selected);
                   value=entity.assets.Value(is_selected);
               elseif strcmp(type,'damage');
                  coord(:,1)= measures_impact(timestamp).EDS(index_measures).assets.lon(is_selected);
                  coord(:,2)= measures_impact(timestamp).EDS(index_measures).assets.lat(is_selected);
                  value=measures_impact(1).EDS(1).ED_at_centroid(is_selected);
               elseif strcmp(type,'benefit');
                   stopper=stopper+1;
                   if stopper==1;
                       for i=1:length(measures_impact(1).EDS)
                           benefit{i}=measures_impact(1).EDS(length(measures_impact(1).EDS)).ED_at_centroid-measures_impact(1).EDS(i).ED_at_centroid;
                       end
                   end
                  coord(:,1)= measures_impact(timestamp).EDS(index_measures).assets.lon(is_selected);
                  coord(:,2)= measures_impact(timestamp).EDS(index_measures).assets.lat(is_selected);
                  value= benefit{1,index_measures}(is_selected);
               end
                  t.coord_tot=[t.coord_tot;coord];
                  t.value_tot=[t.value_tot;value];
                  clear is_selected coord value
           end
    end
      
   [~,~,idx]=unique(t.coord_tot,'rows','stable');
   t_max=max(idx);
   for j=1:t_max
       t_indx{j}=find(idx==j);
   end
   
   for j=1:length(t_indx)
           selection.point_value(j)=sum(t.value_tot(t_indx{j}));
           selection.point_lon(j)=unique(t.coord_tot(t_indx{j},1));
           selection.point_lat(j)=unique(t.coord_tot(t_indx{j},2));
   end
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/climada_value_sum.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_LS_screw">
<H2>salvador_LS_screw</H2></A>
<font color="blue">function [screw_mod, screw_ext] = salvador_LS_screw </font>
 create moderate and extreme climate change screw for LS San Salvador
 NAME:
   salvador_LS_screw
 PURPOSE:
   create moderate and extreme climate change screw for LS San Salvador
 CALLING SEQUENCE:
   [screw_mod, screw_ext] = salvador_LS_screw
 EXAMPLE:
   [screw_mod, screw_ext] = salvador_LS_screw
 INPUTS:
   none, input is hardwired in the code
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   screw_mod: a screw structure for moderate climate change, that fits
   as input for climada_hazard_climate_screw.m. A 1xN structure with fields:
       .hazard_fld     defines the hazard field to be changed
       .change         extent of the change at time horizon
       .year           time horizon
       .hazard_crit    hazard field to which criteria apply
       .criteria       criteria for events/locations to change
       .bsxfun_op      operation of change (e.g. @times,@plus) (function handle)
   screw_ext: a screw for extreme climate change
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Jacob Anz, 20150923, init
 Lea Mueller, muellele@gmail.com, 20150924, add documentation
 Lea Mueller, muellele@gmail.com, 20151022, increase frequency and use stable intensity for cc scenarios
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/salvador_LS_screw.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_TC_screw">
<H2>salvador_TC_screw</H2></A>
<font color="blue">function [screw_mod, screw_ext] = salvador_TC_screw </font>
 create moderate and extreme climate change screw for TC San Salvador
 NAME:
   salvador_TC_screw
 PURPOSE:
   create moderate and extreme climate change screw for TC San Salvador
 CALLING SEQUENCE:
   [screw_mod, screw_ext] = salvador_TC_screw
 EXAMPLE:
   [screw_mod, screw_ext] = salvador_TC_screw
 INPUTS:
   none, input is hardwired in the code
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   screw_mod: a screw structure for moderate climate change, that fits
   as input for climada_hazard_climate_screw.m. A 1xN structure with fields:
       .hazard_fld     defines the hazard field to be changed
       .change         extent of the change at time horizon
       .year           time horizon
       .hazard_crit    hazard field to which criteria apply
       .criteria       criteria for events/locations to change
       .bsxfun_op      operation of change (e.g. @times,@plus) (function handle)
   screw_ext: a screw for extreme climate change
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Jacob Anz, 20150923, init
 Lea Mueller, muellele@gmail.com, 20150924, add documentation
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/salvador_TC_screw.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_calc_measures">
<H2>salvador_calc_measures</H2></A>
<font color="blue">function salvador_calc_measures(nametag,assets_file,damfun_file,measures_file,results_dir,peril_ID,m_file) </font>
 calculate measures for salvador FL (for now)
 NAME:
   salvador_calc_measures
 PURPOSE:
   calc measures and save reports and figures in a newly created directory
   in results/...
 CALLING SEQUENCE:
   salvador_calc_measures(nametag,assets_file,damfun_file,measures_file,results_dir)
 EXAMPLE:
   salvador_calc_measures('FL_v2',assets_file,damfun_file,measures_file,'20150922_measures_FL_v2')
   salvador_calc_measures('FL',[],[],[], [],'FL','AB2');
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   reports and figures 
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150910, init
 Lea Mueller, muellele@gmail.com, 20150921, use new assets for FL
 Lea Mueller, muellele@gmail.com, 20150921, use new functions salvador_hazard_future_save, salvador_entity_files_set, 
              add diary file, add future scenarios (2040 eco. development, 2040 moderate cc, 2040 extreme cc)
 Lea Mueller, muellele@gmail.com, 20150925, add urban planning (set to nil for 2015), use different 
              hazard_intensity_impact_a for today, moderate and extreme cc
 Lea Mueller, muellele@gmail.com, 20150930, add adaptation_cost_curve for 2040, moderate cc
 Lea Mueller, muellele@gmail.com, 20150930, add special xlim for medidas 1 FL
 Lea Mueller, muellele@gmail.com, 20151020, add switch for peril_IDs (FL, TC, LS_las_canas, LS_acelhuate)
 Lea Mueller, muellele@gmail.com, 20151020, add special xlim for LS_las_canas people
 Lea Mueller, muellele@gmail.com, 20151020, add special xlim for LS_acelhuate people
 Jacob Anz,   j.anz@gmx.net     , 20151021, add input parameter m_file
 Jacob Anz,   j.anz@gmx.net     , 20151026, set xlim_value for TC and cleanup
 Jacob Anz,   j.anz@gmx.net     , 20151026, set special m_file limits only for peril FL
 Lea Mueller, muellele@gmail.com, 20151030, enable to select any entity/assets,damfun (uigetfile)
 Lea Mueller, muellele@gmail.com, 20151106, rename to climada_EDS_ED_per_category_report from salvador_EDS_ED_per_category_report
 Lea Mueller, muellele@gmail.com, 20151125, rename to climada_adaptation_bar_chart from climada_adaptation_bar_chart_v2
 Lea Mueller, muellele@gmail.com, 20151217, use climada_global.data_dir instead of project_dir, use climada_assets_read and climada_discount_read instead of climada_entity_read
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/salvador_calc_measures.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_calc_waterfall">
<H2>salvador_calc_waterfall</H2></A>
<font color="blue">function EDS = salvador_calc_waterfall(nametag,assets_file,damfun_file,results_dir, growth_rate_eco, growth_rate_people,peril_ID) </font>
 calculate waterfall graph 
   - for San Salvador 
   - salvador_calc_waterfall.m
   - calculate EDS for today, economic development,
     2040 moderate and 2040 extreme cc
   - for USD and for people
Example
 EDS=salvador_calc_waterfall_2('','','','','','','TC');
Input parameter
 peril_ID = 'LS','FL','TC' ;

 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150901, init
 Lea Mueller, muellele@gmail.com, 20150924, cleanup and add new functions (salvador_entity_files_set, salvador_entity_future_create, salvador_hazard_future_save) 
 Lea Mueller, muellele@gmail.com, 20150924, add diary_file
 Lea Mueller, muellele@gmail.com, 20150925, check damagefunctions
 Lea Mueller, muellele@gmail.com, 20150925, set max_encoding_distance_m to 10^6 if not FL
 Lea Mueller, muellele@gmail.com, 20151020, do not show legend in waterfall graph
 Lea Mueller, muellele@gmail.com, 20151030, enable to select any entity/assets,damfun (uigetfile)
 Lea Mueller, muellele@gmail.com, 20151106, rename to climada_EDS_ED_per_category_report from salvador_EDS_ED_per_category_report
 Lea Mueller, muellele@gmail.com, 20151217, use climada_global.data_dir instead of project_dir, use climada_assets_read and climada_discount_read instead of climada_entity_read
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/salvador_calc_waterfall.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_entity_files_set">
<H2>salvador_entity_files_set</H2></A>
<font color="blue">function [assets_file, damfun_file, measures_file, m_file] = salvador_entity_files_set(assets_file,damfun_file,measures_file,peril_ID,m_file) </font>
 set assets_file, damfun_file and measures_file for San Salvador, depending on peril_ID
 NAME:
   salvador_entity_files_set
 PURPOSE:
   set assets_file, damfun_file and measures_file for San Salvador, depending on peril_ID
 CALLING SEQUENCE:
   assets_file, damfun_file, measures_file] = salvador_entity_files_set(peril_ID,assets_file,damfun_file,measures_file)
 EXAMPLE:
   assets_file, damfun_file, measures_file] = salvador_entity_files_set('TC','','','')
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   assets_file: empty
   damfun_file: empty
   measures_file: empty
   peril_ID: default is 'TC'
   m_file: string, e.g. 'AB1', to tage the measures version in case of FL
 OUTPUTS:
   assets_file: filename of assets, e.g. '20150917_TC\entity_AMSS_WIND_NEW.xlsx' 
   damfun_file: filename of damagefunctions
   measures_file: filename of measures
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller,  muellele@gmail.com, 20150924, init
 Jacob Anz,    j.anz@gmx.net,      20151020, added input m_file and cleanup
 Lea Mueller, muellele@gmail.com, 20151022, add m_file option
 Lea Mueller, muellele@gmail.com, 20151022, default m_file is '', only for FL it is 'AB1'
 Lea Mueller, muellele@gmail.com, 20151030, enable to select any entity/assets,damfun (uigetfile)
 Lea Mueller, muellele@gmail.com, 20151217, rename default files that have been nicely put together, 
         containing assets, damagefunctions, measures, discount all in one excel
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/salvador_entity_files_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_entity_future_create">
<H2>salvador_entity_future_create</H2></A>
<font color="blue">function entity = salvador_entity_future_create(entity, growth_rate_eco, growth_rate_people, peril_ID) </font>
 create future entity for San Salvador
 NAME:
   salvador_entity_future_create
 PURPOSE:
   create and save future entity for San Salvador, based on a growth rate for USD
   values and a growth rate for people, for the timespan from
   climada_global.present_reference_year and climada_global.future_reference_year
 CALLING SEQUENCE:
   entity = salvador_entity_future_create(entity, growth_rate_eco, growth_rate_people, peril_ID)
 EXAMPLE:
   entity = salvador_entity_future_create
 INPUTS:
   none, input is hardwired in the code
 OPTIONAL INPUT PARAMETERS:
   entity: a climada entity structure
   growth_rate_eco: default is 0.04 (4% per year)
   growth_rate_people: default is 0.002 (0.2% per year)
   peril_ID: default is 'FL'
 OUTPUTS:
   entity, a climada entity structure with upscaled values (different for
   USD and people values) for climada_global.future_reference_year
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150924, init
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/salvador_entity_future_create.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_hazard_future_save">
<H2>salvador_hazard_future_save</H2></A>
<font color="blue">function salvador_hazard_future_save(peril_ID) </font>
 create future hazard for San Salvador (TC, LS_las_canas, LS_acelhuate)
 NAME:
   salvador_hazard_future_save
 PURPOSE:
   create and save future hazard for San Salvador, for TC, LS_las_canas,
   LS_acelhuate, based on climada_global.future_reference_year and
   salvador_LS_screw and salvador_TC_screw
 CALLING SEQUENCE:
   salvador_hazard_future_save(peril_ID)
 EXAMPLE:
   salvador_hazard_future_save
 INPUTS:
   none, input is hardwired in the code
 OPTIONAL INPUT PARAMETERS:
   peril_ID: default is 'TC'
 OUTPUTS:
   none, hazards are created and saved in climada_global.project_dir
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150923, init
 Lea Mueller, muellele@gmail.com, 20151030, hazards can be saved in project_dir or project_dir/hazards
 Lea Mueller, muellele@gmail.com, 20151217, add .scenario 
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/salvador_hazard_future_save.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_resolution_test_LS">
<H2>salvador_resolution_test_LS</H2></A>
 Resolution sensitivity analysis for climada applied to 
 landslides and tropical cyclones in San Salvador
 Lea Mueller, 20160219
 Perform sensitivity analysis for different resolutions for two cases, 
 1) landslides in Las Caas neighborhood in San Salvador and 
 2) tropical cyclones in the metropolitan area of San Salvador (AMSS). 
 Analyzed resolutions range from high resolution (~50 meter), mid 
 resolution (~1 km) to low resolution (~10 km).
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
% landslides
limada_global.max_encoding_distance_m = 10^6;
 load shps files
oad([climada_global.data_dir filesep 'results' filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'])
 landslide hazard las canas
S_hazard_file = [climada_global.data_dir filesep 'hazards' filesep 'Salvador_hazard_LS_las_canas_2015.mat'];
azard = climada_hazard_load('Salvador_hazard_LS_las_canas_2015.mat');
azard = rmfield(hazard,'name');
limada_map_plot(hazard)
azard.intensity_all = sum(hazard.intensity,1);
igure; climada_map_plot(hazard,'intensity_all'); hold on; climada_shapeplotter(polygon_canas,'','lon','lat')
old on; plot(entity_mid_res.assets.lon, entity_mid_res.assets.lat,'x','markersize',12)
eturn_periods = [50 500 1000]; check_plot = 0;
azard_stats = climada_hazard_stats(hazard,return_periods,check_plot);
 high resolution assets
S_entity_file = [climada_global.data_dir filesep 'entities' filesep 'LS_entity_las_canas.xls'];
ntity = climada_entity_read(LS_entity_file,'NOENCODE');
limada_global.markersize = 3;
limada_figuresize(0.6,0.8); climada_map_plot(entity_high_res,'Value','',{'Cat. 31' 'Cat. 32' 'Cat. 33' 'Cat. 34' 'Cat. 35' 'Cat. 36'}); 
 hold on; climada_shapeplotter(polygon_canas,'','lon','lat')
limada_geo_distance(entity_high_res.assets.lon(1), entity_high_res.assets.lat(1), entity_high_res.assets.lon(2), entity_high_res.assets.lat(2))
 figure;climada_shapeplotter(polygon_ilopango,'','lon','lat')
 climada_shapeplotter(shape_rivers)
 rios_25k_shapes = climada_shaperead([salvador_data_dir filesep 'system' filesep 'rios_25k_polyline_WGS84.shp'],1);
 EDS high resolution
nnotation_name = 'high resolution assets';
DS = climada_EDS_calc(entity,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS,'ED_at_centroid','','',{'Cat. 31' 'Cat. 32' 'Cat. 33' 'Cat. 34' 'Cat. 35' 'Cat. 36'});
 adaptation measures high resolution
easures_impact_reference = 'no';
easures_impact_high_res = climada_measures_impact(entity,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_high_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'entity_high_res.mat'],'entity_high_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'measures_impact_high_res.mat'],'measures_impact_high_res')
% mid resolution (1km)
 mid resolution assets
dmin0_name = 'El Salvador'; admin1_name = 'San Salvador'; selections = 0; scale_Value = [0 1 0];
ntity_nightlight = climada_nightlight_entity(admin0_name,admin1_name,selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight)
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
limada_geo_distance(entity.assets.lon(1), entity.assets.lat(1), entity.assets.lon(2), entity.assets.lat(2))
limada_geo_distance(entity_mid_res.assets.lon(2), entity_mid_res.assets.lat(2), entity_mid_res.assets.lon(3), entity_mid_res.assets.lat(3))
 filter out 18 points within las caas
 is_inside = inpoly([entity_nightlight.assets.lon; entity_nightlight.assets.lat]', [shapes.lon; shapes.lat]');
s_inside = inpoly([entity_nightlight.assets.lon; entity_nightlight.assets.lat]', [polygon_canas.lon; polygon_canas.lat]');
 create mid_res assets (18 points)
ntity_nightlight.assets.Value_orig = entity_nightlight.assets.Value;
ntity_nightlight.assets.Value(~is_inside)= 0;
ntity_mid_res = entity_high_res;
ssets = entity_nightlight.assets;
ssets.lon = entity_nightlight.assets.lon(is_inside);
ssets.lat = entity_nightlight.assets.lat(is_inside);
ssets.Value = entity_nightlight.assets.Value(is_inside);
ssets.DamageFunID = entity_nightlight.assets.DamageFunID(is_inside);
ssets.DamageFunID = assets.DamageFunID*131;
ssets.Deductible = entity_nightlight.assets.Deductible(is_inside);
ssets.Cover = entity_nightlight.assets.Cover(is_inside);
ssets = rmfield(assets,'Value_orig');
cale_Value = [0 -1.0159e8 2.1351e7 sum(entity_high_res.assets.Value)];
ssets.Value = scale_Value(1) + scale_Value(2)*assets.Value + scale_Value(3)*assets.Value.^2;
ssets.comment=sprintf('%s: y = %2.2f + %2.2f*x^1 + %2.2f*x^2',mfilename,scale_Value(1:3));
f length(scale_Value)==4
   assets.Value = assets.Value/sum(assets.Value)*scale_Value(4); % normalize, multiply
   assets.comment=[assets.comment sprintf(', normalized, then *%2.2f',scale_Value(4))];
nd
ssets.Cover = assets.Value;
ntity_mid_res.assets = assets;
ntity_mid_res.measures = rmfield(entity_mid_res.measures,'regional_scope');
ntity_mid_res.measures.regional_scope = logical(ones(10,9));
limada_global.markersize = 65;
limada_figuresize(0.6,0.8);climada_map_plot(entity_mid_res)
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.145 -89.10 13.6895 13.727]); climada_figure_scale_add('',1,1)
 EDS mid resolution
nnotation_name = 'mid resolution assets';
DS(2) = climada_EDS_calc(entity_mid_res,hazard,annotation_name);
limada_global.markersize = 35;
limada_figuresize(0.6,0.8); climada_map_plot(EDS(2),'ED_at_centroid','','');
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
 axis([-89.145 -89.095 13.6895 13.732])
limada_figure_axis_limits_equal_for_lat_lon([-89.145 -89.10 13.6895 13.727]); climada_figure_scale_add('',1,1)
 adaptation measures mid resolution
limada_global.font_scale = 1.4;
easures_impact_reference = 'no';
easures_impact_mid_res = climada_measures_impact(entity_mid_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_mid_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'entity_mid_res.mat'],'entity_mid_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'measures_impact_mid_res.mat'],'measures_impact_mid_res')
% low resolution
 assets, just one point
ntity_low_res = entity_mid_res;
ntity_low_res.assets.lon = [mean(entity_mid_res.assets.lon) entity_mid_res.assets.lon(:)'];
ntity_low_res.assets.lat = [mean(entity_mid_res.assets.lat) entity_mid_res.assets.lat(:)'];
ntity_low_res.assets.Value = [sum(entity_mid_res.assets.Value) zeros(1,18)];
ntity_low_res.assets.Cover = entity_low_res.assets.Value;
ntity_low_res.assets.DamageFunID = [131 zeros(1,18)]; 
ntity_low_res.assets.Deductible = [0 zeros(1,18)]; 
limada_global.markersize = 120;
limada_figuresize(0.6,0.8);climada_map_plot(entity_low_res)
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
 axis([-89.145 -89.095 13.6895 13.732])
limada_figure_axis_limits_equal_for_lat_lon([-89.145 -89.10 13.6895 13.727]); climada_figure_scale_add('',1,1)
 EDS low resolution
nnotation_name = 'low resolution assets';
DS(3) = climada_EDS_calc(entity_low_res,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS(3),'ED_at_centroid','','');
old on; climada_shapeplotter(polygon_canas,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.145 -89.10 13.6895 13.727]); climada_figure_scale_add('',1,1)
 adaptation measures low resolution
limada_global.font_scale = 1.4;
easures_impact_reference = 'no';
easures_impact_low_res = climada_measures_impact(entity_low_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_low_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'entity_low_res.mat'],'entity_low_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'measures_impact_low_res.mat'],'measures_impact_low_res')
%
igure;climada_entity_plot(entity_nightlight)
S_entity_file = [climada_global.data_dir filesep 'entities' filesep 'LS_entity_las_canas.xls'];
ntity = climada_entity_read(LS_entity_file,'NOENCODE');
limada_global.markersize = 3;
limada_figuresize(0.6,0.8); climada_map_plot(entity,'Value','',{'Cat. 31' 'Cat. 32' 'Cat. 33' 'Cat. 34' 'Cat. 35' 'Cat. 36'});
limada_geo_distance(entity.assets.lon(1), entity.assets.lat(1), entity.assets.lon(2), entity.assets.lat(2))
 figure;climada_shapeplotter(polygon_LS,'','lon','lat')
 figure;climada_shapeplotter(polygon_ilopango,'','lon','lat')
 climada_shapeplotter(shape_rivers)
 rios_25k_shapes = climada_shaperead([salvador_data_dir filesep 'system' filesep 'rios_25k_polyline_WGS84.shp'],1);
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/salvador_resolution_test_LS.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="salvador_resolution_test_TC">
<H2>salvador_resolution_test_TC</H2></A>
 Resolution sensitivity analysis for climada applied to 
 landslides and tropical cyclones in San Salvador
 Lea Mueller, 20160219
 Perform sensitivity analysis for different resolutions for two cases, 
 1) landslides in Las Caas neighborhood in San Salvador and 
 2) tropical cyclones in the metropolitan area of San Salvador (AMSS). 
 Analyzed resolutions range from high resolution (~50 meter), mid 
 resolution (~1 km) to low resolution (~10 km).
 Lea Mueller, muellele@gmail.com, 20160229, rename to climada_shapeplotter from shape_plotter
% Tropical cyclones wind
limada_global.font_scale = 1.4;
limada_global.max_encoding_distance_m = 10^6;
limada_global.markersize = 5;
 load shps files
oad([climada_global.data_dir filesep 'results' filesep 'san_salvador_shps_adm2_rivers_salvador_polygon_LS.mat'])
 TC hazard san salvador AMSS
C_hazard_file = [climada_global.data_dir filesep 'hazards' filesep 'Salvador_hazard_TC_2015.mat'];
azard = climada_hazard_load('Salvador_hazard_TC_2015.mat');
 hazard = rmfield(hazard,'name');
limada_map_plot(hazard)
azard.intensity_all = sum(hazard.intensity,1);
igure; climada_map_plot(hazard,'intensity_all'); hold on; climada_shapeplotter(polygon_LS,'','lon','lat')
 hold on; plot(entity_high_res.assets.lon, entity_high_res.assets.lat,'x','markersize',12)
 return_periods = [50 500 1000]; check_plot = 0;
 hazard_stats = climada_hazard_stats(hazard,return_periods,check_plot);
 high resolution assets
C_entity_file = [climada_global.data_dir filesep 'entities' filesep 'TC_entity_AMSS.xls'];
ntity_high_res = climada_entity_read(TC_entity_file,'NOENCODE');
ntity_high_res.assets.Value(entity_high_res.assets.Category==2) = 0;
limada_global.markersize = 6;
limada_figuresize(0.6,0.8); climada_map_plot(entity_high_res,'Value');
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.32 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 polygon_AMSS = climada_shape_selector(gcf,1);
 climada_geo_distance(entity_high_res.assets.lon(1), entity_high_res.assets.lat(1), entity_high_res.assets.lon(2), entity_high_res.assets.lat(2))
 
 climada_geo_distance(entity_high_res.assets.lon(2), entity_high_res.assets.lat(2), entity_high_res.assets.lon(3), entity_high_res.assets.lat(3))
 % figure;climada_shapeplotter(polygon_ilopango,'','lon','lat')
 % climada_shapeplotter(shape_rivers)
 % rios_25k_shapes = climada_shaperead([salvador_data_dir filesep 'system' filesep 'rios_25k_polyline_WGS84.shp'],1);
 EDS high resolution
nnotation_name = 'high resolution assets';
DS = climada_EDS_calc(entity_high_res,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS,'ED_at_centroid');
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.32 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 adaptation measures high resolution
easures_impact_reference = 'no';
easures_impact_high_res = climada_measures_impact(entity_high_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_high_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_entity_high_res.mat'],'entity_high_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_measures_impact_high_res.mat'],'measures_impact_high_res')
% mid resolution (1km)
 mid resolution assets
dmin0_name = 'El Salvador'; admin1_name = 'San Salvador'; selections = 0; scale_Value = [0 1 0];
ntity_nightlight = climada_nightlight_entity(admin0_name,admin1_name,selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
igure;climada_entity_plot(entity_nightlight)
ntity_nightlight_2 = climada_nightlight_entity(admin0_name,'La Libertad',selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight_2)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
 combine the two
ntity_nightlight.assets.Value = [entity_nightlight.assets.Value entity_nightlight_2.assets.Value];
ntity_nightlight.assets.lon = [entity_nightlight.assets.lon entity_nightlight_2.assets.lon];
ntity_nightlight.assets.lat = [entity_nightlight.assets.lat entity_nightlight_2.assets.lat];
 climada_geo_distance(entity.assets.lon(1), entity.assets.lat(1), entity.assets.lon(2), entity.assets.lat(2))
 climada_geo_distance(entity_mid_res.assets.lon(2), entity_mid_res.assets.lat(2), entity_mid_res.assets.lon(3), entity_mid_res.assets.lat(3))
 filter out points within AMSS polygon (648 points)
s_inside = inpoly([entity_nightlight.assets.lon; entity_nightlight.assets.lat]', [polygon_AMSS.lon; polygon_AMSS.lat]');
um(is_inside)
 create mid_res assets (18 points)
ntity_nightlight.assets.Value_orig = entity_nightlight.assets.Value;
ntity_nightlight.assets.Value(~is_inside)= 0;
ntity_mid_res = entity_high_res;
ssets = entity_nightlight.assets;
ssets.lon = entity_nightlight.assets.lon(is_inside);
ssets.lat = entity_nightlight.assets.lat(is_inside);
ssets.Value = entity_nightlight.assets.Value(is_inside);
ssets.DamageFunID = ones(size(assets.Value))*121;
ssets.Deductible = zeros(size(assets.Value));
ssets.Cover = zeros(size(assets.Value));
ssets = rmfield(assets,'Value_orig');
cale_Value = [0 -1.0159e8 2.1351e7 sum(entity_high_res.assets.Value)];
ssets.Value = scale_Value(1) + scale_Value(2)*assets.Value + scale_Value(3)*assets.Value.^2;
ssets.comment=sprintf('%s: y = %2.2f + %2.2f*x^1 + %2.2f*x^2',mfilename,scale_Value(1:3));
f length(scale_Value)==4
   assets.Value = assets.Value/sum(assets.Value)*scale_Value(4); % normalize, multiply
   assets.comment=[assets.comment sprintf(', normalized, then *%2.2f',scale_Value(4))];
nd
ssets.Cover = assets.Value;
ntity_mid_res.assets = assets;
ntity_mid_res.measures = rmfield(entity_mid_res.measures,'regional_scope');
ntity_mid_res.measures.regional_scope = logical(ones(10,9));
limada_global.markersize = 10;
limada_figuresize(0.6,0.8);climada_map_plot(entity_mid_res)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.32 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 EDS mid resolution
nnotation_name = 'mid resolution assets';
DS(2) = climada_EDS_calc(entity_mid_res,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS(2),'ED_at_centroid','','');
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.32 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 adaptation measures mid resolution
easures_impact_reference = 'no';
easures_impact_mid_res = climada_measures_impact(entity_mid_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_mid_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_entity_mid_res.mat'],'entity_mid_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_measures_impact_mid_res.mat'],'measures_impact_mid_res')
% low resolution (10 km)
dmin0_name = 'El Salvador'; admin1_name = 'San Salvador'; selections = 10; scale_Value = [0 1 0];
ntity_nightlight_10km = climada_nightlight_entity(admin0_name,admin1_name,selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight_10km)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
 figure;climada_entity_plot(entity_nightlight_10km)
ntity_nightlight_10km_2 = climada_nightlight_entity(admin0_name,'La Libertad',selections,0,scale_Value);
igure;climada_map_plot(entity_nightlight_10km_2)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
 combine the two
ntity_nightlight_10km.assets.Value = [entity_nightlight_10km.assets.Value entity_nightlight_10km_2.assets.Value];
ntity_nightlight_10km.assets.lon = [entity_nightlight_10km.assets.lon entity_nightlight_10km_2.assets.lon];
ntity_nightlight_10km.assets.lat = [entity_nightlight_10km.assets.lat entity_nightlight_10km_2.assets.lat];
 filter out points within AMSS polygon (648 points)
olygon_AMSS_buffer = climada_shape_selector(gcf,1);
olygon_AMSS_buffer.lon = polygon_AMSS_buffer.X; polygon_AMSS_buffer.lat = polygon_AMSS_buffer.Y;
s_inside = inpoly([entity_nightlight_10km.assets.lon; entity_nightlight_10km.assets.lat]', [polygon_AMSS_buffer.lon; polygon_AMSS_buffer.lat]');
um(is_inside)
 figure
 plot(entity_nightlight_10km.assets.lon,entity_nightlight_10km.assets.lat,'x')
 hold on
 plot(entity_nightlight_10km.assets.lon(is_inside),entity_nightlight_10km.assets.lat(is_inside),'or')
 create low_res assets (9 points)
ntity_nightlight_10km.assets.Value_orig = entity_nightlight_10km.assets.Value;
ntity_nightlight_10km.assets.Value(~is_inside)= 0;
ntity_low_res = entity_high_res;
ssets = entity_nightlight_10km.assets;
ssets.lon = entity_nightlight_10km.assets.lon(is_inside);
ssets.lat = entity_nightlight_10km.assets.lat(is_inside);
ssets.Value = entity_nightlight_10km.assets.lat(is_inside);
ssets.lon = assets.lon(1:9);
ssets.lat = assets.lat(1:9);
ssets.Value = assets.lat(1:9);
ssets.DamageFunID = ones(size(assets.Value))*121;
ssets.Deductible = zeros(size(assets.Value));
ssets.Cover = zeros(size(assets.Value));
ssets = rmfield(assets,'Value_orig');
cale_Value = [0 -1.0159e8 2.1351e7 sum(entity_high_res.assets.Value)];
ssets.Value = scale_Value(1) + scale_Value(2)*assets.Value + scale_Value(3)*assets.Value.^2;
ssets.comment=sprintf('%s: y = %2.2f + %2.2f*x^1 + %2.2f*x^2',mfilename,scale_Value(1:3));
f length(scale_Value)==4
   assets.Value = assets.Value/sum(assets.Value)*scale_Value(4); % normalize, multiply
   assets.comment=[assets.comment sprintf(', normalized, then *%2.2f',scale_Value(4))];
nd
ssets.Cover = assets.Value;
ntity_low_res.assets = assets;
ntity_low_res.measures = rmfield(entity_mid_res.measures,'regional_scope');
ntity_low_res.measures.regional_scope = logical(ones(7,9));
limada_global.markersize = 60;
limada_figuresize(0.6,0.8);climada_map_plot(entity_low_res)
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.35 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 for i=1:9
     hold on
     text(assets.lon(i),assets.lat(i),sprintf('%d',i))
 end
 assets.Value = [20 50 65 10 27 64 45 15 40];
 EDS low resolution
nnotation_name = 'low resolution assets';
DS(3) = climada_EDS_calc(entity_low_res,hazard,annotation_name);
limada_figuresize(0.6,0.8); climada_map_plot(EDS(3),'ED_at_centroid','','');
old on; climada_shapeplotter(polygon_AMSS,'','lon','lat')
limada_figure_axis_limits_equal_for_lat_lon([-89.35 -89.03 13.629 13.84]); climada_figure_scale_add('',1,1)
 adaptation measures low resolution
limada_global.font_scale = 1.4;
easures_impact_reference = 'no';
easures_impact_low_res = climada_measures_impact(entity_low_res,hazard,measures_impact_reference);
limada_figuresize(0.4,0.9); climada_adaptation_cost_curve(measures_impact_low_res)
 save
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_entity_low_res.mat'],'entity_low_res')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_EDS.mat'],'EDS')
ave([climada_global.data_dir filesep 'results' filesep 'resolution_test' filesep 'TC_measures_impact_low_res.mat'],'measures_impact_low_res')
%
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/salvador_demo/code/salvador_resolution_test_TC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="WS_intensity_correction">
<H2>WS_intensity_correction</H2></A>
<font color="blue">function WS_intensity_correction(save_files) </font>
 climada
 NAME:
   WS_intensity_correction
 PURPOSE:
   correct WS intenisty as documented in the paper:

   Schwierz, C., P. K?llner-Heck, E. Zenklusen Mutter, D. N. Bresch,
   P.-L.Vidale, M. Wild, C., and Sch?r, 2010: Modelling European winter
   wind storm losses in current and future climate. Climatic Change (2010)
   101:485?514, doi: 10.1007/s10584-009-9712-1.

   If applied a second time, the correction is reversed

   WARNING: a truly expert level code, to be used with utmost caution

   see also winterstorm_compare and winterstorm_compare_severity
 CALLING SEQUENCE:
   WS_intensity_correction(param1);
 EXAMPLE:
   WS_intensity_correction
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   save_files: whether files are saves(=1) or only inspected (=0, default)
 OUTPUTS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141129
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/storm_europe/code/WS_intensity_correction.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_TEST">
<H2>winterstorm_TEST</H2></A>
<font color="blue">function winterstorm_TEST(check_plots) </font>
 climada
 NAME:
   winterstorm_TEST
 PURPOSE:
   TEST European winter storm module
 CALLING SEQUENCE:
   winterstorm_TEST(check_plot);
 EXAMPLE:
   winterstorm_TEST(1);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   check_plots: if =1, show figures to check hazards etc.
       If =0, skip figures (default)
       If country_name is set to 'ALL', be careful to set check_plots=1
 OUTPUTS:
   to stdout and storing an encoded entity to data/entities
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141029
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/storm_europe/code/winterstorm_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_blend_hazard_event_sets">
<H2>winterstorm_blend_hazard_event_sets</H2></A>
<font color="blue">function hazard=winterstorm_blend_hazard_event_sets(hazard_save_file,frequency_screw,intensity_screw) </font>
 climada
 MODULE:
   ws_europe
 NAME:
   winterstorm_blend_hazard_event_sets
 PURPOSE:
   Blend the four WS hazard events sets into one, see PARAMETERS in code

   Hazard sets from:
   Schwierz, C., P. Koellner-Heck, E. Zenklusen Mutter, D. N. Bresch,
   P.-L.Vidale, M. Wild, C., and Sch?r, 2010: Modelling European winter
   wind storm losses in current and future climate. Climatic Change (2010)
   101:485?514, doi: 10.1007/s10584-009-9712-1.

   See also winterstorm_compare and winterstorm_compare_severity
 CALLING SEQUENCE:
   hazard=winterstorm_blend_hazard_event_sets(hazard_save_file,frequency_screw)
 EXAMPLE:
   hazard=winterstorm_blend_hazard_event_sets('WS_Europe_blend.mat',0.9)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   hazard_save_file: the filename (w/o path) of the blended output file
       It is always stored in the same folder as the files it is blended
       from, e.g. only a filename, such as 'WS_Europe_blend.mat'.
   frequency_screw: an EXPERIMENTAL multiplier for the frequency, just
       multiplies all single event frequencies. Default=1 (obviously)
       (Can be justified to adjust, due to the fact that we blend hazard
       sets, an adjustment accounts for especially smaller scale events) 
   intensity_screw: scale intensity with, default=1
 OUTPUTS:
   hazard: the blended hazard event set, usually named WS_Europe.mat, see
       optional input parameter hazard_save_file
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141201, initial
 David N. Bresch, david.bresch@gmail.com, 20141206, frequency_screw added
 David N. Bresch, david.bresch@gmail.com, 20141213, intensity_screw added
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/storm_europe/code/winterstorm_blend_hazard_event_sets.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_compare">
<H2>winterstorm_compare</H2></A>
<font color="blue">function EDS=winterstorm_compare(entity,compare_damage_functions,compare_hazard_sets,compare_scenarios) </font>
 climada
 NAME:
   winterstorm_compare
 PURPOSE:
   Run a winterstorm Europe analysis for a given entity with different
   damage functions and different hazard event sets.

   compare_damage_functions: those derived based upon DWD and EuroTempest gust
   data. The code tries to use the matching hazard event set (as as
   created by country_risk_calc). If not found, the code prompts for a WS
   hazard event set and re-encodes assets.

   compare_hazard_sets, hazard sets from:
   Schwierz, C., P. K?llner-Heck, E. Zenklusen Mutter, D. N. Bresch,
   P.-L.Vidale, M. Wild, C., and Sch?r, 2010: Modelling European winter
   wind storm losses in current and future climate. Climatic Change (2010)
   101:485?514, doi: 10.1007/s10584-009-9712-1.

   compare_scenarios: show the modeled scenario loss for the events as
   defined in the data/validation folder in Database_master_table.xls
   WARNING: does not make much sense, since the scenario hazard intensity
   is not calibrated with the hazard intensities in the hazard event sets
   based on Schwierz et al. Code just kept for reference.

   See also winterstorm_validate and winterstorm_compare_severity
   See also climada_DFC_compare in core climada
 CALLING SEQUENCE:
   EDS=winterstorm_compare(entity,compare_damage_functions,compare_hazard_sets,compare_scenarios)
 EXAMPLE:
   EDS=winterstorm_compare('',1,1) % run damage function and hazard set
       comparisons
 INPUTS:
   entity: an encoded entity, see climada_entity_read
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   compare_damage_functions: if =1, compare damage functions (default)
       run 4 times: damage function as in entity, 2 versions with explicit
       function and using the standard WS damage function, see
       damagefunctions_filename in PARAMETERS in code
       =0: omit this
   compare_hazard_sets: if =1, compare hazard sets using the standard
       damage function, see damagefunctions_filename in PARAMETERS in code
       =0: omit this (default)
       =2, use the damage function as in entity, not the standard one
       Note that for each damage calculation, the entity is re-encoded (to
       be on the safe side)
   compare_scenarios: if =1, show modeled scenario losses, using standard
       damage function, see damagefunctions_filename in PARAMETERS in code.
       See PARAMETERS to define the location and name of the
       Database_master_table. WARNING: results do not make much sense,
       since scenario hazard intensities are not calibrated.
       =0: omit (default)
       =2, use the damage function as in entity, not the standard one
       Note that for each damage calculation, the entity is re-encoded (to
       be on the safe side)
       Note further that compare_scenarios only does not make much sense,
       but is permitted, as one might want to overlay scenario results to
       an existing DFC plot.
 OUTPUTS:
   EDS: the event damage set(s), see climada_EDS_calc
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141121, ICE initial
 David N. Bresch, david.bresch@gmail.com, 20141128, compare_hazard_sets, compare_scenarios
 David N. Bresch, david.bresch@gmail.com, 20141201, WARNING for compare_scenarios added
 David N. Bresch, david.bresch@gmail.com, 20141223, LOCAL folders moved
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/storm_europe/code/winterstorm_compare.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_compare_severity">
<H2>winterstorm_compare_severity</H2></A>
<font color="blue">function severity=winterstorm_compare_severity(compare_scenarios,plot_linear) </font>
 climada
 NAME:
   winterstorm_compare_severity
 PURPOSE:
   Compare the hazard severity of different hazard sets

   See also winterstorm_compare
   See also climada_DFC_compare in core climada
 CALLING SEQUENCE:
   severity=winterstorm_compare_severity(compare_scenarios)
 EXAMPLE:
   severity=winterstorm_compare_severity
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   compare_scenarios: if =1, run the severity calculation for single
       scenarios, too, and add them to the severity comparison
       =0: omit (default)
       See HARD CHOICE, TO BE REVISED in code, too
 OUTPUTS:
   severity: the severity information for all
       hazard event sets is stored (inspect yourself)
       For speedup, the routine saves .mat files with each hazard set's
       results in {module_data_dir}/results
   plot_linear: if =1, plot linear (default), otherwise loglog (=0)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141128, initial
 David N. Bresch, david.bresch@gmail.com, 20141223, folders moved
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/storm_europe/code/winterstorm_compare_severity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_scenario_hazard">
<H2>winterstorm_scenario_hazard</H2></A>
<font color="blue">function hazard=winterstorm_scenario_hazard(storm_data_filename,plot_gust_field,save_hazard_flag) </font>
 climada
 NAME:
   winterstorm_scenario_hazard
 PURPOSE:
   read the single storm gust table and create a single storm hazard event

   see winterstorm_validate and winterstorm_compare
 CALLING SEQUENCE:
   hazard=winterstorm_scenario_hazard(storm_data_filename,save_hazard_flag)
 EXAMPLE:
   hazard=winterstorm_scenario_hazard(storm_data_filename,save_hazard_flag)
 INPUTS:
   storm_data_filename: the filename of a single storm (.csv). The file
   just contains n lines with grid number, gust. Hence we also read the
   grid table (see )
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   plot_gust_field: if =1, plot the gust field (default=0)
   save_hazard_flag: if =1, save as single hazard event set (default=0)
       on subsequent calls, the hazard is read from this file, rather than
       re-created (hence delete the .mat file to re-create from .csv).
       If =2, force re-creation of the .mat file, i.e. re-read from the
       .csv file and create the scenario hazard set again
 OUTPUTS:
   hazard: a single hazard event set
       if save_hazard_flag=1, stored as climada hazard event set (with
       just one event)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141128, initial
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/storm_europe/code/winterstorm_scenario_hazard.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="winterstorm_severity">
<H2>winterstorm_severity</H2></A>
<font color="blue">function severity=winterstorm_severity(hazard,check_plot) </font>
 climada
 NAME:
   winterstorm_severity
 PURPOSE:
   calculate the winterstorm severity, a measure for it's 'strength'

   in essence, calculate sum of v^3 over all centroids of a each event

   see winterstorm_compare_severity (to show severity exceedence curve etc)
 CALLING SEQUENCE:
   severity=winterstorm_severity(hazard)
 EXAMPLE:
   severity=winterstorm_severity(hazard)
 INPUTS:
   hazard: the filename of a hazard event set
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   check_plot: if =1, show check plot of selected centroids
       =0: no plot (default)
 OUTPUTS:
   severity: a structure with
       index= the storm severity index
       frequency: the event frequency
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20141128, initial
 David N. Bresch, david.bresch@gmail.com, 20141212, compatible with new admin0.mat
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/storm_europe/code/winterstorm_severity.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="_climada_nonspheric_distance_m">
<H2>_climada_nonspheric_distance_m</H2></A>
<font color="blue">function [fDistance_km GridVect] = climada_nonspheric_distance_m(fLon1,fLat1,fLon2,fLat2,... </font>
                                                        CUID, inreach)      
 This function calculates the distance for each individual gridpoint from
 the TC center. Distance differences in x direction, depending on
 latitude, are normalized in the whole inreach-box with the value at the
 TC-Center

 --------------------------------------------------------------------------
 Modified Haversine Formula to normalize distance differences in y (longitudinal)
 direction at different latitudes
 --------------------------------------------------------------------------
 used in climada_tc_rainfield
 MODIFICATION HISTORY:
 Fabian Schoenenberger, 20110601
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/_climada_nonspheric_distance_m.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_EDS_scaleup_factor">
<H2>climada_EDS_scaleup_factor</H2></A>
<font color="blue">function ELS = climada_ELS_scaleup_factor(ELS, factor_) </font>
lobal climada_global
f ~climada_init_vars,return;end % init/import global variables
 poor man's version to check arguments
f ~exist('ELS'    ,'var'), ELS     = []; end
f ~exist('factor_','var'), factor_ = []; end
f isempty(ELS)
   ELS = climada_ELS_load;
nd
f isempty(factor_)
   fprintf('No scaleup factor given. Unable to proceed.\n')
   return
nd
 % scale up ELS with given factor
f ~isempty(ELS)
   ELS.loss        = factor_ * ELS.loss;
   ELS.loss_per_cu = factor_ * ELS.loss_per_cu;
   ELS.EL_per_cu   = factor_ * ELS.EL_per_cu;
   ELS.Value       = factor_ * ELS.Value;
   ELS.comment     = sprintf('Scaled up ELS with factor %2.2f, %s',...
                              factor_, ELS.comment);
   ELS.annotation_name = sprintf('Scaled up ELS with factor %2.2f, %s',...
                                  factor_, ELS.annotation_name);
   ELS.EL          = factor_ * ELS.EL;                           
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_EDS_scaleup_factor.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_RCLIPER">
<H2>climada_RCLIPER</H2></A>
<font color="blue">function [rainrate] = climada_RCLIPER(fmaxwind_kn,inreach,Radius_km)                                   </font>
 calculate rainrate based on RCLIPER in mm/h
 NAME:
   climada_RCLIPER
 PURPOSE:
   given the windspeed (kn) at a specific node calculate the rainrate at 
   all centroids according to RCLIPER (symmetric rainfield)

   usually called from: climada_tr_rainfield (see there)
 CALLING SEQUENCE:
   climada_RCLIPER(fmaxwind_kn, inreach, Radius_km)
 EXAMPLE:
   rainrate=climada_RCLIPER(tc_track.MaxSustainedWind(i),inreach,fRadius_km);      
 INPUTS:
   fmaxwind_kn: maximum sustained wind at specific node (array) 
   inreach:     logical vector of centroids length, containing 1 if centroid
                is within (3, see climada_tr_rainfield) deg of node, otherwise 0 
   Radius_km:   vector of centroids length, containing distance to node
                for every centroid
 OPTIONAL INPUT PARAMETERS:
   none
 OUTPUTS:
   res.G: the rainrate [mm/h] at all centroids
       the single-character variables refer to the Pioneer offering circular
       that's why we kept these short names (so one can copy the OC for
       documentation)
   res.lat: the latitude of the centroids
   res.lon: the longitude of the centroids
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 201106038
 david.bresch@gmail.com, 20140804, GIT update
 david.bresch@gmail.com, 20160529, header edited
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_RCLIPER.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_admin_name">
<H2>climada_admin_name</H2></A>
<font color="blue">function [admin_name, admin_shapes, adm_lvl, shape_ndx, country_name, location] ... </font>
   = climada_admin_name(country_name,admin_name,adm_lvl,climada_global_border_file_check)
 climada_admin_name
 MODULE:
   climada core
 NAME:
   climada_admin_name
 PURPOSE:
   check for valid admin name on different levels (0: country, 1: states, 2: districts) 
   and download admin shape files, return all the arguments incl. shape files
   Same concept as climada_country_name, but for admin regions. The map
   border file in climada_global as used in climada_plot_world_borders
   may be replaced with the shape files for the desired admin level, but
   this may cause problems later
 CALLING SEQUENCE:
   [admin_name, admin_shapes, adm_lvl, shape_ndx, country_name, location] ...
     = climada_admin_name(country_name,admin_name,adm_lvl,climada_global_border_file_check)
 EXAMPLE:
   [admin_name, admin_shapes, adm_lvl, shape_ndx, country_name, location] ...
     = climada_admin_name('Netherlands','Utrecht',2,1)
 INPUTS: 
 OPTIONAL INPUT PARAMETERS:
   country_name:   country of interest,prompted from if not given
   admin_name:     set to 'SINGLE' (default) for single admin region
                   selection at the specified admin level
                   set to 'MULTIPLE' for multi-region select within one
                   admin level, e.g. admin level set to 2 =&ampgt select
                   country, select admin region at level 1, then choose
                   multiple regions at level 2
                   set to 'ALL' to return all admin regions at desired
                   admin level for entire country
   adm_lvl:        define admin level of interest (max admin level varies
                   per country)
   climada_global_border_file_check:   whether to set admin shapes as
                                       default climada global map border file.
 OUTPUTS:
   admin_name:     name of the selected admin region
   admin_shapes:   shapes struct array at admin level
   adm_lvl:        administrative region (0 = country)
   shape_ndx:      shape index of selected admin region in admin shapes
                   structure array
   country_name:   country name
   location:       struct with .lon .lat for centre of selected admin region
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150508 init
 Gilles Stassen, gillesstassen@hotmail.com, 20150615, documentation, hopefully all bugs are gone (they never are...)
 Lea Mueller, muellele@gmail.com, 20150615, climada_global.data dir instead of module_dir
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_admin_name.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_distance_to_coast">
<H2>climada_centroids_distance_to_coast</H2></A>
<font color="blue">function centroids = climada_centroids_distance_to_coast(centroids, coastline, check_figure) </font>
 calculate distance to coast in km for every centroid and add information
 in the field centroids.dist_to_coast
 NAME:
   climada_centroids_distance_to_coast
 PURPOSE:
   calculate distance to coast in km for every centroid and add information
   in the field centroids.dist_to_coast
   within: climada_hazard_distance_to_coast
 CALLING SEQUENCE:
   centroids = climada_centroids_distance_to_coast(centroids, coastline,
   check_figure)
 EXAMPLE:
   centroids = climada_centroids_distance_to_coast
 INPUTS:
   none, if coastline_file empty default file is loaded from 
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   centroids structure variable including field centroids.dist_to_coast
   with distance to coast in km
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_centroids_distance_to_coast.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_centroids_hazard_expand">
<H2>climada_centroids_hazard_expand</H2></A>
<font color="blue">function [centroids,hazard] = climada_centroids_hazard_expand(centroids_ori, hazard_ori, tc_track) </font>
 UNDOCUMENTED
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_centroids_hazard_expand.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_coastline_read">
<H2>climada_coastline_read</H2></A>
<font color="blue">function coastline = climada_coastline_read(coastline_file, check_plot) </font>
read the coastline file, data source NOAA
 http://www.ngdc.noaa.gov/mgg/coast/
 NAME:
   climada_coastline_read
 PURPOSE:
   read the coastline and have coastline as output
   within: climada_centroids_distance_to_coast
 CALLING SEQUENCE:
   coastline = climada_coastline_read(coastline_file)
 EXAMPLE:
   coastline = climada_coastline_read
 INPUTS:
   none, if coastline_file empty default file is loaded from globalGDP
   modul data folder
 OPTIONAL INPUT PARAMETERS:
   check_plot to create figure
 OUTPUTS:
   coastline
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_coastline_read.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_event_damage_animation_ge">
<H2>climada_event_damage_animation_ge</H2></A>
<font color="blue">function res=climada_event_damage_animation_ge(animation_data_file,google_earth_save,schematic_tag) </font>
 climada_event_damage_animation_ge
 MODULE:
   tc_hazard_advanced
 NAME:
   climada_event_damage_animation_ge
 PURPOSE:
   Animation of event damage in google earth
   This code write the kmz file for google earth, see e.g.
   climada_event_damage_data_tc to calculate all the data. As one often
   needs to play with visualization parameters, the process is split.

   An animation of the tropical cylclone track hitting the assets as
   defined in entity.

   The code determines the plot area based on entity (but since there can be
   more than one ocean basin's tracks hitting the centroids, the user has
   to select the track file).

   prior calls: climada_event_damage_data_tc or similar to prepare the
   event damage information
 CALLING SEQUENCE:
   res=climada_event_damage_animation_ge(animation_data_file,google_earth_save)
 EXAMPLE:
   res=climada_event_damage_animation_ge; % prompt for
 INPUTS:
   animation_data_file: the data file (.mat) with hazard set which
       includes event damage information, see e.g. climada_event_damage_data_tc
       &ampgt promted for if not given
   google_earth_save: the filename of the resulting .kmz google earth file
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   schematic_tag: set to 1 if schematic plot (no colorbar, indicative
   colorscale). if set to 0, e.g. tc wind color scale is yellow
   (20-30 m/s), orange (30-40 m/s), dark orange (40-50 m/s), etc...
 OUTPUTS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20150130, initial
 Lea Mueller, muellele@gmail.com, 20150203, schematic tag
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_event_damage_animation_ge.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_clim_scen_IPCC">
<H2>climada_hazard_clim_scen_IPCC</H2></A>
<font color="blue">function hazard = climada_hazard_clim_scen_IPCC(hazard, tc_track, hazard_save_name, reference_year, screw) </font>
 NAME:
   climada_hazard_clim_scen
 PURPOSE:
   starting from a given hazard event set (hazard), construct the
   hazard event set (hazard_clim_file) for a climate change scenario, e.g.
   from IPCC SREX
 CALLING SEQUENCE:
   hazard = climada_tc_hazard_clim_scen(hazard, tc_track, reference_year, screw)
 EXAMPLE:
   hazard = climada_tc_hazard_clim_scen
 INPUTS:
   hazard  :         either a hazard set (struct) or a hazard set file (.mat with a struct)
                     &ampgt promted for if not given
   tc_track:         either a tc track set (struct) or a tc track set file (.mat with a struct)
                     &ampgt promted for if not given (important for storm
                     category)
 OPTIONAL INPUT PARAMETERS:
   reference_year:   the reference year for the give climate change scenario, 
                     e.g. 2017 (+5 years), and then frequency and or intensity 
                     changes are linearly interpolated from the projected time 
                     horizon (e.g. 2100 from IPCC SREX) to the requested
                     reference year.
   screw:            structure of one or multiple frequency or intensity 
                     changes given a certain projected time horizon, default
                     from IPCC SREX taken if not given
                     example:  
                        screw.variable_to_change = 'frequency';
                        screw.frequency          = 0.8;
                        screw.time_horizon       = 2100;
                        screw.cat                = [4 5];
   hazard_save_name: the filename of the new climate scenario hazard event set
                     &ampgt promted for if not given
 OUTPUTS:
   hazard  :        the hazard event set for the climate scenario, also
                     stored to hazard_save_name
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090920
 Lea Mueller, 20120816
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_clim_scen_IPCC.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_clim_scen_advanced">
<H2>climada_hazard_clim_scen_advanced</H2></A>
<font color="blue">function hazard = climada_hazard_clim_scen_advanced(hazard, tc_track, hazard_save_name, reference_year, screw) </font>
 NAME:
   climada_hazard_clim_scen_advanced
 PURPOSE:
   starting from a given hazard event set (hazard), construct the
   hazard event set (hazard_clim_file) for a climate change scenario, e.g.
   from IPCC SREX
   
   see also core climada code climada_hazard_clim_scen
 CALLING SEQUENCE:
   hazard = climada_tc_hazard_clim_scen(hazard, tc_track, reference_year, screw)
 EXAMPLE:
   hazard = climada_tc_hazard_clim_scen
 INPUTS:
   hazard  :         either a hazard set (struct) or a hazard set file (.mat with a struct)
                     &ampgt promted for if not given
   tc_track:         either a tc track set (struct) or a tc track set file (.mat with a struct)
                     &ampgt promted for if not given (important for storm
                     category)
 OPTIONAL INPUT PARAMETERS:
   reference_year:   the reference year for the give climate change scenario, 
                     e.g. 2017 (+5 years), and then frequency and or intensity 
                     changes are linearly interpolated from the projected time 
                     horizon (e.g. 2100 from IPCC SREX) to the requested
                     reference year.
   screw:            structure of one or multiple frequency or intensity 
                     changes given a certain projected time horizon, default
                     from IPCC SREX taken if not given
                     example:  
                        screw.variable_to_change = 'frequency';
                        screw.frequency          = 0.8;
                        screw.time_horizon       = 2100;
                        screw.cat                = [4 5];
   hazard_save_name: the filename of the new climate scenario hazard event set
                     &ampgt promted for if not given
 OUTPUTS:
   hazard  :        the hazard event set for the climate scenario, also
                     stored to hazard_save_name
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090920
 Lea Mueller, 20120816
 David N. Bresch, david.bresch@gmail.com, 20141103, named climada_hazard_clim_scen_advanced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_clim_scen_advanced.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_climate_screw">
<H2>climada_hazard_climate_screw</H2></A>
<font color="blue">function hazard = climada_hazard_climate_screw(hazard, hazard_set_file, reference_year, screw) </font>
 NAME:
 climada_hazard_climate_screw
 PURPOSE:
   Compute the future hazard set for a given climate change scenario from
   a hazard set defining the risk today.
 CALLING SEQUENCE:
   hazard = climada_hazard_climate_screw(hazard, hazard_set_file, reference_year, screw)
 EXAMPLE:
   hazard_cc = climada_hazard_climate_screw(hazard, '', 2040, screw)
   hazard_cc = climada_hazard_climate_screw(hazard, 'NO_SAVE')
   hazard_cc = climada_hazard_climate_screw
 INPUTS:
   hazard:     hazard set today (can be any peril which may be subject to
               climate change)
 OPTIONAL INPUT PARAMETERS:
   hazard_set_file:    file name defining where the new hazard should be
                       saved. If set to 'NO_SAVE', the hazard set will not 
                       be saved. Prompted for if left empty.
   reference_year:     time horizon for which one wishes to compute the
                       climate change hazard set. If left empty, the 
                       reference year in climada_global will be used.
   screw:      defines the climate change scenario. A 1xN structure with
               fields:
                   .hazard_fld     defines the hazard field to be changed
                   .change         extent of the change at time horizon
                   .year           time horizon
                   .hazard_crit    hazard field to which criteria apply
                   .criteria       criteria for events/locations to change
                   .bsxfun_op      operation of change (e.g. @times,@plus) (function handle)
               specifying N transformations to the original hazard set.
 OUTPUTS:
   hazard:     new hazard for a future reference year, given a climate
               change scenario specified by screw.
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150421 based on original
           function climada_hazard_clim_scen_advanced by David N. Bresch &amp Lea Mueller
 Lea Mueller, muellele@gmail.com, 20151021, do not change hazard if it corresponds already to the required year
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_climate_screw.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast">
<H2>climada_hazard_distance_to_coast</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast_USA">
<H2>climada_hazard_distance_to_coast_USA</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast_USA(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast_USA.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast_australia">
<H2>climada_hazard_distance_to_coast_australia</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast_australia(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast_australia.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast_china">
<H2>climada_hazard_distance_to_coast_china</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast_china(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast_china.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_distance_to_coast_japan">
<H2>climada_hazard_distance_to_coast_japan</H2></A>
<font color="blue">function hazard = climada_hazard_distance_to_coast_japan(hazard, centroids, tc_track, check_figure) </font>
 Weakening of hazard, namely maximum sutained wind over land depending on
 distance to coast 
 NAME:
   climada_hazard_distance_to_coast
 PURPOSE:
   Weakening of hazard, namely maximum sutained wind over land depending
   on
   previous step:  climada_tc_hazard_set
   next step    :  climada_ELS_calc, or climada_hazard_clim_scen, diverse
 CALLING SEQUENCE:
   hazard = climada_hazard_distance_to_coast(hazard, centroids, tc_track)
 EXAMPLE:
   hazard = climada_hazard_distance_to_coast
 INPUTS:
   none, if hazard, centroids or tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_figure to create figure
 OUTPUTS:
   same hazard structure but hazard.intensity are lower values depending on
   distance to coast
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_distance_to_coast_japan.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_extract_event">
<H2>climada_hazard_extract_event</H2></A>
<font color="blue">function event = climada_hazard_extract_event(hazard,event_i) </font>
 climada
 MODULE:
 NAME:
   climada_hazard_extract_event
 PURPOSE:
   easily extract one event from a hazard set for faster testing/debugging/developing
 CALLING SEQUENCE:
   event = climada_hazard_extract_event(hazard,event_i)
 EXAMPLE:
   event = climada_hazard_extract_event
   event = climada_hazard_extract_event(hazard,153)
 INPUTS:
   hazard:     standard climada hazard event set struct
   event_i:    event number of interest, can be a vector containing
               multiple event numbers
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   event:  struct of the same format as a hazard event set, but only
           containing the events specified by the event numbers in event_i
 MODIFICATION HISTORY:
 Gilles Stassen, gillesstassen@hotmail.com, 20150428
 Gilles Stassen, 20150706, multiple events, negative input for nth largest event
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_extract_event.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_footprint_plot">
<H2>climada_hazard_footprint_plot</H2></A>
<font color="blue">function climada_hazard_footprint_plot(hazard, event_no, nametag) </font>
 TC footprint figure
 NAME:
   climada_plot_tc_footprint
 PURPOSE:
 create footprint figure
 CALLING SEQUENCE:
   [contr t_handle] = climada_plot_tc_footprint(hazard, tc_track, track_no)
 EXAMPLE:
   climada_plot_tc_footprint
 INPUTS:
   hazard: hazard.intensity with intensities per centroid
   event_no: a number, event number of hazard to be shown
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   figure with footprint
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20121205
 Lea Mueller, muellele@gmail.com, 20150423
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_footprint_plot.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_hazard_merge">
<H2>climada_hazard_merge</H2></A>
<font color="blue">function hazard = climada_hazard_merge(hazard1, hazard2) </font>
 hazard1 = hazard_wkn;
 hazard2 = hazard_ext;
f hazard1.reference_year ~= hazard2.reference_year   
   fprintf(['Warning: Reference years are not equal: ' int2str(hazard1.reference_year) ' and ' int2str(hazard2.reference_year) '\n']);
nd
f hazard1.peril_ID ~= hazard2.peril_ID   
   fprintf(['Warning: Peril IDs are not equal: ' hazard1.peril_ID ' and ' hazard2.peril_ID '\n']);
nd
f hazard1.orig_years ~= hazard2.orig_years   
   fprintf(['Warning: orig years are not equal: ' int2str(hazard1.orig_years) ' and ' int2str(hazard2.orig_years) '\n']);
nd
f hazard1.event_count ~= hazard2.event_count   
   fprintf(['Warning: event counts are not equal: ' int2str(hazard1.event_count) ' and ' int2str(hazard2.event_count) '\n']);
nd
f size(hazard1.lon,2) ~= size(hazard2.lon,2)
   fprintf('Merge two hazards with different centroids\n');
   
   hazard     = hazard2;
   hazard.lon = [hazard1.lon hazard2.lon];
   hazard.lat = [hazard1.lat hazard2.lat];
   no_cen     = size(hazard.lon,2);
   hazard.centroid_ID = 1:no_cen;
   hazard.intensity = [hazard1.intensity hazard2.intensity];
nd
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_hazard_merge.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_loss_hist">
<H2>climada_plot_loss_hist</H2></A>
<font color="blue">function climada_plot_loss_hist(event_loss) </font>
 EDS loss damage histogram
 NAME:
   climada_plot_loss_hist
 PURPOSE:
 	plot a histogram of event losses
 CALLING SEQUENCE:
   [contr t_handle] = climada_plot_windfield(hazard, tc_track, track_no)
 EXAMPLE:
   climada_plot_windfield
 INPUTS:
   hazard: hazard.intensity with wind intensities per centroid
   tc_track: a structure with the track information:
   track_no: number of track to show footprint
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   figure with footprint
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, david.bresch@gmail.com, 20121205
 Lea Mueller, david.bresch@gmail.com, 20141121, fixed (was a mess)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_plot_loss_hist.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_lossfootprint">
<H2>climada_plot_lossfootprint</H2></A>
<font color="blue">function climada_plot_lossfootprint(event_loss, centroids, tc_track, nametag) </font>
 TC footprint figure
 NAME:
   climada_plot_windfield
 PURPOSE:
 create footprint figure
 CALLING SEQUENCE:
   [contr t_handle] = climada_plot_windfield(hazard, tc_track, track_no)
 EXAMPLE:
   climada_plot_windfield
 INPUTS:
   hazard: hazard.intensity with wind intensities per centroid
   tc_track: a structure with the track information:
   track_no: number of track to show footprint
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   figure with footprint
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, david.bresch@gmail.com, 20121205
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_plot_lossfootprint.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_probabilistic_wind_speed_decay">
<H2>climada_plot_probabilistic_wind_speed_decay</H2></A>
<font color="blue">function track_req = climada_plot_probabilistic_wind_speed_decay(tc_track, track_req, single) </font>
 plot historical tc track (Longitude, Latitude) in world map according to
 saffir-simpson hurrican scale. Add plot of probabilistic generated sister
 storms. Historical tracks has black lines around markers to identify as
 original track.
 NAME:
   climada_plot_probabilistic_wind_speed_map
 PURPOSE:
   analyse visuallly historical tc track and its generated probabilistic
   sister storms. Check Longitude, Latitude and wind speed category
   (saffir-simpson hurricane scale) 
 CALLING SEQUENCE:
   climada_plot_probabilistic_wind_speed_decay(tc_track)
 EXAMPLE:
   climada_plot_probabilistic_wind_speed_decay
 INPUTS:
   tc_track: probabilistic tc track set (random walk of wind speed, 
   longitude and latitude), wind speed in knots, nodes every six hours, if
   not given, prompted for
 OPTIONAL INPUT PARAMETERS:
   track_req:  number of specific historical track to be displayed with
   its probabilistic sister storms, prompts for input 
   p:          to print figure
   x:          to exit
   41:         or any other track number. will be rounded to the nearest 
               historical track.
   enter:      to continue.
 OUTPUTS:
   figure, printout of figure if requested
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110628
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_plot_probabilistic_wind_speed_decay.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_plot_probabilistic_wind_speed_map_gui">
<H2>climada_plot_probabilistic_wind_speed_map_gui</H2></A>
<font color="blue">function [track_req h g] = climada_plot_probabilistic_wind_speed_map_gui(tc_track, track_req) </font>
 plot historical tc track (Longitude, Latitude) in world map according to
 saffir-simpson hurrican scale. Add plot of probabilistic generated sister
 storms. Historical tracks has black lines around markers to identify as
 original track.
 NAME:
   climada_plot_probabilistic_wind_speed_map
 PURPOSE:
   analyse visuallly historical tc track and its generated probabilistic
   sister storms. Check Longitude, Latitude and wind speed category
   (saffir-simpson hurricane scale) 
 CALLING SEQUENCE:
   climada_plot_probabilistic_wind_speed_map(tc_track)
 EXAMPLE:
   climada_plot_probabilistic_wind_speed_map
 INPUTS:
   tc_track: probabilistic tc track set (random walk of wind speed, 
   longitude and latitude), wind speed in knots, nodes every six hours, if
   not given, prompted for
 OPTIONAL INPUT PARAMETERS:
   track_req:  number of specific historical track to be displayed with
   its probabilistic sister storms, prompts for input 
   p:          to print figure
   x:          to exit
   41:         or any other track number. will be rounded to the nearest 
               historical track.
   enter:      to continue.
 OUTPUTS:
   figure, printout of figure if requested
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110628
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_plot_probabilistic_wind_speed_map_gui.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_scale_to_MSP_to_market">
<H2>climada_scale_to_MSP_to_market</H2></A>
<font color="blue">function [entity ELS] = climada_scale_to_MSP_to_market(entity, ELS, MSP_AEL, market_TIV) </font>
 UNDOCUMENTED
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_scale_to_MSP_to_market.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_hazard_set_slow">
<H2>climada_tc_hazard_set_slow</H2></A>
<font color="blue">function hazard = climada_tc_hazard_set_slow(tc_track,hazard_set_file,centroids) </font>
 climada TC hazard event set generate
 NAME:
   climada_tc_hazard_set
 PURPOSE:
   SLOW, only kept for backward compatibility, see climada_tc_hazard_set

   generate a tc (tropical cyclone) hazard event set

   If centroids.distance2coast_km exists, the hazard intensity is only
   calculated in the coastal_range_km (usually 200km, see PARAMETERS in
   climada_tc_windfield) - this speeds up calculation for large countries
   considerably.

   Special: the hazard event set is stored every 100 tracks in order to
   allow for interruption of the hazard set generation. Just re-start the
   calculation by calling climada_tc_hazard_set with exactly the same
   input parameters (the last track calculated is stored in hazard.track_i
   and the field track_i is removed in the final complete hazard event set).  
   Therefore, if you get errors such as 
       Subscripted assignment dimension mismatch.
       Error in climada_tc_hazard_set (line 270) % ... or nearby
       hazard.intensity(track_i,:)     = res.gust;
   It is VERY likely that you changed something between subsequent calls
   (i.e. different centroids). Just delete the hazard set .mat file and run
   climada_tc_hazard_set again.

   previous: likely climada_random_walk
   next: diverse
 CALLING SEQUENCE:
   res=climada_tc_hazard_set_slow(tc_track,hazard_set_file,centroids)
 EXAMPLE:
   res=climada_tc_hazard_set_slow(tc_track)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_tc_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name (and path, optional) of the hazard set file
       If no path provided, default path ../data/hazards is used (and name
       can be without extension .mat). If ='NOSAVE', the hazard set is not
       saved (but returned as output)
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           lon(1,:): the longitudes
           lat(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a .mat-file which contains a centroids struct (saved by
       climada_centroids_read) or the filename of an Excel file (the original
       input to climada_centroids_read) which holds the centroids, in
       which case climada_centroids_read is called.
       OR: an entity, in which case the entity.assets.lat and
       entity.assets.lon are used as centroids.
       &ampgt promted for .mat or .xls filename if not given
       NOTE: if you then select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090729
 David N. Bresch, david.bresch@gmail.com, 20130506, centroids filename handling improved
 David N. Bresch, david.bresch@gmail.com, 20140421, waitbar with secs
 David N. Bresch, david.bresch@gmail.com, 20141226, optional fields in centroids added
 David N. Bresch, david.bresch@gmail.com, 20150103, equal_timestep (much) improved
 Lea Mueller, muelleleh@gmail.com, 20150420, include tc category into hazard structure
 David N. Bresch, david.bresch@gmail.com, 20150804, allow for filename without path for hazard set name on input
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir
 David N. Bresch, david.bresch@gmail.com, 20150824, removed 'TCNA' from hazard.comment
 David N. Bresch, david.bresch@gmail.com, 20150906, note on a frequent issue added to header
 David N. Bresch, david.bresch@gmail.com, 20151008, NOSAVE option added
 Lea Mueller, muelleleh@gmail.com, 20151127, add hazard.scenario, default is 'no climate change'
 David N. Bresch, david.bresch@gmail.com, 20160514, -v7.3 in save added
 David N. Bresch, david.bresch@gmail.com, 20160529, renamed to climada_tc_hazard_set_slow
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_hazard_set_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_on_land">
<H2>climada_tc_on_land</H2></A>
<font color="blue">function tc_track = climada_tc_on_land(tc_track, border_mask) </font>
 Add on land variable to tc track structure for every tc track (former
 climada_tc_track_on_land)
 NAME:
   climada_tc_on_land
 PURPOSE:
   add on land variable (1 on land, 0 over sea) for every tc track in tc 
   track strucuture based on world map (raster file)
   within:  climada_tc_track_wind_decay
 CALLING SEQUENCE:
   tc_track = climada_tc_on_land(tc_track, border_mask);
 EXAMPLE:
   tc_track = climada_tc_on_land;
 INPUTS:
   none, if tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   tc_track: a structure with the track information including
   tc_track.onLand (1 for on land, 0 for over sea)
 OUTPUTS:
   same structure now including tc track variable for every tc track
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20140716, minor edit to catch date-line issue
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_on_land.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_google_earth">
<H2>climada_tc_track_google_earth</H2></A>
<font color="blue">function climada_tc_track_google_earth(tc_track, google_earth_save) </font>
 climada_tc_track_google_earth
 MODULE:
   tc_hazard_advanced
 NAME:
   climada_tc_track_google_earth
 PURPOSE:
   visualisation of historical tracks with time stamp in google
   create kml-file of all historical tc tracks 
   lines with colors according to saffir-simpson scale
 CALLING SEQUENCE:
   climada_tc_track_google_earth(tc_track, google_earth_save)
 EXAMPLE:
   climada_tc_track_google_earth
 INPUTS:
   tc_track: track set, historical or probabilistic, but only historical
   tracks are visualized. prompted for, if not given.
 OPTIONAL INPUT PARAMETERS:
   google_earth_save:  file to be saved in
                       \climada\data\tc_tracks\tc_track....kml
 OUTPUTS:
   kmz-file, visualisation of historical tracks with time stamp in google
   earth
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20110724
 Lea Mueller, muellele@gmail.com, 20150123, changed nodetime_mat to datenum
 Lea Mueller, muellele@gmail.com, 20150130, new kml toolbox
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_track_google_earth.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_wind_decay">
<H2>climada_tc_track_wind_decay</H2></A>
<font color="blue">function tc_track = climada_tc_track_wind_decay(tc_track, p_rel, check_plot) </font>
 Incorporate wind decay after landfall for probabilistic tracks, based on
 historical tc tracks
 NAME:
   climada_tc_track_wind_decay
 PURPOSE:
   incorporate wind decay after landfall of probabilistic tracks. The
   decay can be calculated based on historical tracks or can be loaded
   from a mat file (p_rel)
   within:  climada_tc_random_walk_position_windspeed
 CALLING SEQUENCE:
   tc_track = climada_tc_track_wind_decay(tc_track, p_rel, check_plot)
 EXAMPLE:
   tc_track = climada_tc_track_wind_decay(tc_track)
 INPUTS:
   none, if tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   p_rel: parameters for exponential decay, y = exp(B) * exp(x*A), where 
          A = p_rel(1,1), B = p_rel(1,2), can be newly calculated or can
          be loaded from data within globalGDP modul
   check_plot: to create plot
 OUTPUTS:
   same structure now MaxSustainedWind in tc track decays after landfall
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150106, climada_tc_equal_timestep
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_track_wind_decay.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_wind_decay_calculate">
<H2>climada_tc_track_wind_decay_calculate</H2></A>
<font color="blue">function [tc_track p_rel] = climada_tc_track_wind_decay_calculate(tc_track, check_plot) </font>
 Calculate wind decay after landfall based on historical tc tracks
 NAME:
   climada_tc_track_wind_decay_calculate
 PURPOSE:
   Calculate wind decay after landfall based on historical tc tracks
   within:  climada_tc_random_walk_position_windspeed
 CALLING SEQUENCE:
   [tc_track p_rel] = climada_tc_track_wind_decay_calculate(tc_track, check_plot)
 EXAMPLE:
   [tc_track p_rel] = climada_tc_track_wind_decay_calculate(tc_track)
 INPUTS:
   none, if tc_track empty prompted for
 OPTIONAL INPUT PARAMETERS:
   check_plot: to create plot
 OUTPUTS:
   p_rel contains the parameters for exponential decay for tropical
   depression, tropical storm and hurricanes category 1 to 5
   wind decay = exp(B) * exp(x*A), where A = p_rel(1,1), B = p_rel(1,2)
   wind decay = 1      * exp(x*A), where A = p_rel(1,1), B = p_rel(1,2)
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20121203
 David N. Bresch, david.bresch@gmail.com, 20150106, climada_tc_equal_timestep
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_track_wind_decay_calculate.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_track_windfield_google_earth">
<H2>climada_tc_track_windfield_google_earth</H2></A>
<font color="blue">function climada_tc_track_windfield_google_earth(tc_track,centroids,aggregation,google_earth_save) </font>
 climada_tc_track_windfield_google_earth
 MODULE:
   tc_hazard_advanced
 NAME:
   climada_tc_track_windfield_google_earth
 PURPOSE:
   create kmz-file of wind field animation in google earth
 CALLING SEQUENCE:
   climada_tc_track_windfield_google_earth(tc_track, centroids, aggregation, google_earth_save)
 EXAMPLE:
   climada_tc_track_windfield_google_earth
 INPUTS:
   tc_track: track set, historical or probabilistic, but only historical
   tracks are visualized. prompted for, if not given.
   centroids
 OPTIONAL INPUT PARAMETERS:
   aggregation:        aggregation time, default is 6h
   google_earth_save:  filename, to be saved in
                       \climada\data\tc_tracks\tc_track....kml
 OUTPUTS:
   kmz-file, visualisation of historical track and winfield with time stamp in google
   earth
 RESTRICTIONS:
   none
 MODIFICATION HISTORY:
 Lea Mueller, muellele@gmail.com, 20110724
 Lea Mueller, muellele@gmail.com, 20150123, changed nodetime_mat to datenum
 Lea Mueller, muellele@gmail.com, 20150130, new kml toolbox
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_track_windfield_google_earth.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_wind_decay">
<H2>climada_tc_wind_decay</H2></A>
<font color="blue">function tc_track = climada_tc_wind_decay(tc_track) </font>
 UNDOCUMENTED
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_wind_decay.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tc_windfield_slow">
<H2>climada_tc_windfield_slow</H2></A>
<font color="blue">function res=climada_tc_windfield_slow(tc_track,centroids,equal_timestep,silent_mode,check_plot) </font>
 TC windfield calculation
 NAME:
   climada_tc_windfield_slow
 PURPOSE:
   SLOW version, see climada_tc_windfield

   given a TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the wind field at locations (=centroids)

   If centroids.distance2coast_km exists, the hazard intensity is only
   calculated in the coastal_range_km (usually 300km, see PARAMETERS) -
   this speeds up calculation for large countries considerably. To switch
   this feature off, just centroids=rmfield(centroids,'distance2coast_km')
   prior to passing centroids to climada_tc_windfield_slow

   mainly called from: see climada_tc_hazard_set
 CALLING SEQUENCE:
   climada_tc_windfield_slow(tc_track,centroids,equal_timestep,silent_mode)
 EXAMPLE:
   climada_tc_windfield_slow
   plot windfield:
   climada_tc_windfield_slow(tc_track(1411), centroids,1,1,1)
 INPUTS:
   tc_track: a structure with the track information:
       tc_track.lat
       tc_track.lon
       tc_track.MaxSustainedWind: maximum sustained wind speed (one-minute)
       tc_track.MaxSustainedWindUnit as 'kn', 'mph', 'm/s' or 'km/h'
       tc_track.CentralPressure: optional
       tc_track.Celerity: translational (forward speed) of the hurricane.
           optional, calculated from lat/lon if missing
       tc_track.TimeStep: optional, only needed if Celerity needs to be
           calculated, 6h assumed as default
       tc_track.Azimuth: the forward moving angle, calculated if not given
           to ensure consistency, it is even suggested not to pass Azimuth
       tc_track.yyyy: 4-digit year, optional
       tc_track.mm: month, optional
       tc_track.dd: day, optional
       tc_track.ID_no: unique ID, optional
       tc_track.name: name, optional
       tc_track.SaffSimp: Saffir-Simpson intensity, optional
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
       If centroids.distance2coast_km exists, the hazard intensity is only
       calculated in the coastal_range_km (usually 300km, see PARAMETERS) -
       this speeds up calculation for large countries considerably. To switch
       this feature off, just centroids=rmfield(centroids,'distance2coast_km')
       prior to passing centroids to climada_tc_windfield_slow.
       Some other fields of centroids are also appended to res struct
 OPTIONAL INPUT PARAMETERS:
   equal_timestep: if set=1 (default), first interpolate the track to a common
       timestep, if set=0, no equalization of TC track data (not recommended)
       BUT: for speedup, run climada_tc_equal_timestep for ALL tracks
       prior to calling climada_tc_windfield_slow (see e.g. climada_tc_hazard_set)
       and then set equal_timestep=0 in calling climada_tc_windfield_slow
   silent_mode: if =1, do not write to stdout unless severe warning
       If silent_mode=-1, use step-by-step detailed windfield, i.e. reduce
       wind to zero at center of the eye (not recommended for
       probabilistic, since hit/miss issue with closest node, see variable
       max_wind_at_bullseye in code).
   check_plot: disabled, see code, commented out for speedup
 OUTPUTS:
   res: the output strcuture, with fields
       gust(i): the windfield [m/s] at all centroids i
       lat(i): the latitude of the centroids i
       lon(i): the longitude of the centroids i
       Some other fields of centroids are also appended to res struct
 RESTRICTIONS:
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20090728
 David N. Bresch, david.bresch@gmail.com, 20141227, centroids.distance2coast_km treatment added
 David N. Bresch, david.bresch@gmail.com, 20150124, wind_threshold=15 (was 0), coastal_range_km=375 (was 300)
 David N. Bresch, david.bresch@gmail.com, 20150315, back to real Holland for single timestep
 David N. Bresch, david.bresch@gmail.com, 20150319, eye 'filled' for probabilistic windfields
 David N. Bresch, david.bresch@gmail.com, 20150515, optional plot debugged (usually commented out, starting line 333)
 David N. Bresch, david.bresch@gmail.com, 20150807, climada_global.tc.extratropical_transition
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tc_windfield_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_hazard_set">
<H2>climada_tr_hazard_set</H2></A>
<font color="blue">function hazard  = climada_tr_hazard_set(tc_track,hazard_set_file,centroids) </font>
 generate hazard rain set from tc_tracks
 NAME:
   climada_tr_hazard_set
 PURPOSE:
   generate tropical cyclone hazard rain set
   previous: likely climada_random_walk

   See climada_tr_hazard_set_slow for backward compatibility.

   next: diverse, e.g. climada_EDS_calc
 CALLING SEQUENCE:
   hazard = climada_tr_hazard_set(tc_track,hazard_set_file)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   hazard=climada_tr_hazard_set(tc_track,'_TR_TEST_PARFOR',centroids);
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           lon(1,:): the longitudes
           lat(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       or an entity with entity.assets, centroids are then inferred from
       if you select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 Lea Mueller, 20110722
 david.bresch@gmail.com, 20140804, GIT update
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, parfor, much faster (factor 3-10)
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_hazard_set_slow">
<H2>climada_tr_hazard_set_slow</H2></A>
<font color="blue">function hazard  = climada_tr_hazard_set_slow(tc_track, hazard_set_file, centroids) </font>
 generate hazard rain set from tc_tracks
 NAME:
   climada_tr_hazard_set_slow
 PURPOSE:
   see climada_tr_hazard_set, this is the SLOW version, kep for backward
   compatibility only

   generate tropical cyclone hazard rain set
   previous: likely climada_random_walk
   next: diverse
 CALLING SEQUENCE:
   hazard = climada_tr_hazard_set_slow(tc_track,hazard_set_file)
 EXAMPLE:
   hazard = climada_tr_hazard_set_slow(tc_track)
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
   tc_track: a TC track structure, or a filename of a saved one
       details: see e.g. climada_random_walk
       &ampgt promted for if not given
   hazard_set_file: the name of the hazard set file
       &ampgt promted for if not given
   centroids: the variable grid centroids (see climada_centroids_read)
       a structure with
           Longitude(1,:): the longitudes
           Latitude(1,:): the latitudes
           centroid_ID(1,:): a unique ID for each centroid, simplest: 1:length(Longitude)
       or a file which contains the struct (saved after climada_centroids_read)
       if you select Cancel, a regular default grid is used, see hard-wired definition in code
 OUTPUTS:
   hazard: a struct, the hazard event set, more for tests, since the
       hazard set is stored as hazard_set_file, see code
       lon(centroid_i): the longitude of each centroid
       lat(centroid_i): the latitude of each centroid
       centroid_ID(centroid_i): a unique ID for each centroid
       peril_ID: just an ID identifying the peril, e.g. 'TC' for
       tropical cyclone or 'ET' for extratropical cyclone
       comment: a free comment, normally containing the time the hazard
           event set has been generated
       orig_years: the original years the set is based upon
       orig_event_count: the original events
       event_count: the total number of events in the set, including all
           probabilistic ones, hence event_count&ampgt=orig_event_count
       orig_event_flag(event_i): a flag for each event, whether it's an original
           (1) or probabilistic (0) one
       event_ID: a unique ID for each event
       date: the creation date of the set
       arr(event_i,centroid_i),sparse: the hazard intensity of event_i at
           centroid_i
       frequency(event_i): the frequency of each event
       matrix_density: the density of the sparse array hazard.intensity
       windfield_comment: a free comment, not in all hazard event sets
       filename: the filename of the hazard event set (if passed as a
           struct, this is often useful)
 MODIFICATION HISTORY:
 Lea Mueller, 20110722
 david.bresch@gmail.com, 20140804, GIT update
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, renamed to climada_tr_hazard_set_slow
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_hazard_set_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_rainfield">
<H2>climada_tr_rainfield</H2></A>
<font color="blue">function rainsum=climada_tr_rainfield(tc_track,centroids,~,~,~,~) </font>
 TC rainfield calculation (rainsum)
 NAME:
   climada_tr_rainfield
 PURPOSE:
   given a single TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the rain sum field at locations (=centroids)

   Note: this code is optimized for speed, hence assumes that tc_track is
   free of missing data, climada_tc_equal_timestep applied and
   MaxSustainedWind calculated.

   there is still the old SLOW version climada_tr_rainfield_slow, not
   recommended, just kep for backward compatibility

   mainly called from: see climada_tr_hazard_set
 CALLING SEQUENCE:
   rainsum=climada_tr_rainfield(tc_track,centroids,~,~,~,~)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   tc_track=climada_tc_equal_timestep(tc_track);
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   rainsum=climada_tr_rainfield(tc_track(68),centroids);
   climada_color_plot(rainsum,centroids.lon,centroids.lat);
 INPUTS:
   tc_track: a structure with the single track information (length(tc_track)!=1)
       see e.g. climada_tc_read_unisys_tc_track
       tc_track.Azimuth and/or tc_track.Celerity calculated, if not existing
       but climada_tc_equal_timestep mist have been run and
       tc_track.MaxSustainedWind must exist on input
   centroids: a structure with the centroids information (see e.g.
       climada_centroids_read):
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   rainsum(i): the rain fall sum [mm over full lieftime of the event] 
       at all centroids(i)

   One could also return res (switched off for speedup, 
   search for res. in code to swithc this on):
   (res.rainsum: the rain fall sum [mm per storm] at all centroids
       the single-character variables refer to the Pioneer offering circular
       that's why we kept these short names (so one can copy the OC for
       documentation)
   (res.lat: the latitude of the centroids (=centroids.lat)
   (res.lon: the longitude of the centroids (=centroids.lon)
   (res.rainrate: COULD be returned, but most cases not needed, see code)
   (res.time: time in sec, coiuld be returned, see TIMING in code)
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110606
 Martin Heyenn 20120503
 david.bresch@gmail.com, 20140804, GIT update
 david.bresch@gmail.com, 20141020, cleanup, inreach speedup
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, major speedup, five times faster
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_rainfield.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_rainfield_slow">
<H2>climada_tr_rainfield_slow</H2></A>
<font color="blue">function rainsum=climada_tr_rainfield_slow(tc_track,centroids,equal_timestep,silent_mode,check_plot,unit_) </font>
 TC rainfield calculation (rainsum)
 NAME:
   climada_tr_rainfield_slow
 PURPOSE:
   see climada_tr_rainfield for a much FASTER version (same result), 
   kept for backward compatipibility only

   given a single TC track (lat/lon,CentralPressure,MaxSustainedWind), calculate
   the rain sum field at locations (=centroids)
   mainly called from: see climada_tr_hazard_set

 CALLING SEQUENCE:
   [res,tc_track_ori,centroids]=climada_tr_rainfield_slow(tc_track,centroids,equal_timestep,silent_mode,check_plot,unit_)
 EXAMPLE:
   tc_track=climada_tc_track_load('TEST_tracks.atl_hist');
   centroids=climada_centroids_load('USFL_MiamiDadeBrowardPalmBeach');
   rainsum=climada_tr_rainfield_slow(tc_track(68),centroids);
   climada_color_plot(rainsum,centroids.lon,centroids.lat);
 INPUTS:
   tc_track: a structure with the information for a single (1) tc track:
       tc_track.lat
       tc_track.lon
       tc_track.MaxSustainedWind: maximum sustained wind speed (one-minute)
       tc_track.MaxSustainedWindUnit as 'kn', 'mph', 'm/s' or 'km/h'
       tc_track.CentralPressure: optional
       tc_track.Celerity: translational (forward speed) of the hurricane.
           optional, calculated from lat/lon if missing
       tc_track.TimeStep: optional, only needed if Celerity needs to be
           calculated, 6h assumed as default
       tc_track.Azimuth: the forward moving angle, calculated if not given
           to ensure consistency, it is even suggested not to pass Azimuth
       tc_track.yyyy: 4-digit year, optional
       tc_track.mm: month, optional
       tc_track.dd: day, optional
       tc_track.ID_no: unique ID, optional
       tc_track.name: name, optional
       tc_track.SaffSimp: Saffir-Simpson intensity, optional
       NOTE: if empty, the user can also select a file with tc_track and will then
       get promted for a single track number to use (mainly useful for TESTs)
   centroids: a structure with the centroids information
       centroids.lat: the latitude of the centroids
       centroids.lon: the longitude of the centroids
 OPTIONAL INPUT PARAMETERS:
   unit_: rainfall unit, either unit_='mm' (millimeters, default) or for inches unit_='in'
   equal_timestep: if set=1 (default), first interpolate the track to a common
       timestep, if set=0, no equalization of TC track data (not recommended)
   silent_mode: if =1, do not write to stdout unless severe warning
   check_plot: whether some plots are created =1 (default=0, silent_mode=1
       sets check_plot also =0)
 OUTPUTS:
   rainsum(i): the rain fall sum [mm over full lieftime of the event] 
       at all centroids(i)

   One could also return res (switched off for speedup, 
   search for res. in code to swithc this on):
   (res.rainsum: the rain fall sum [mm per storm] at all centroids
       the single-character variables refer to the Pioneer offering circular
       that's why we kept these short names (so one can copy the OC for
       documentation)
   (res.lat: the latitude of the centroids (=centroids.lat)
   (res.lon: the longitude of the centroids (=centroids.lon)
   (res.rainrate: COULD be returned, but most cases not needed, see code)
   (res.time: time in sec, coiuld be returned, see TIMING in code)
 RESTRICTIONS:
 MODIFICATION HISTORY:
 Lea Mueller, 20110606
 Martin Heyenn 20120503
 david.bresch@gmail.com, 20140804, GIT update
 david.bresch@gmail.com, 20141020, cleanup, inreach speedup
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
 David N. Bresch, david.bresch@gmail.com, 20160529, renamed to climada_tr_rainfield_slow
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_rainfield_slow.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_rainrate_field_animation">
<H2>climada_tr_rainrate_field_animation</H2></A>
<font color="blue">function climada_tr_rainrate_field_animation(tc_track, centroids,... </font>
                                            aggregation,check_avi)                        
 plot animation of rainrate field for a specific historical or
 probabilistic storm
 NAME:
   climada_tc_rainrate_field_animation
 PURPOSE:
   plot animation of rainrate field for a specific historical or
   probabilistic storm, plot is produced every aggregation time step
   (minimum 1 hour or more)
 CALLING SEQUENCE:
   climada_tr_rainrate_field_animation(tc_track       ,...
                                  centroids      ,...
                                  aggregation    ,...
                                  check_printplot)
 EXAMPLE:
   climada_tc_rainrate_field_animation(tc_track_prob(1226), centroids, 1, 6)
 INPUTS:
	tc_track:           just one tc_track, tc_track_prob(1)
   centroids:          centroid mat file
 OPTIONAL INPUT PARAMETERS:
   aggregation:        desired timestep for plots (minimum one plot per
   hour, can be one plot for 6 hours or more)
   check_avi:         if set to 1 will save animation as avi-file
 OUTPUTS:
   plot of rainrate field (footprint) for every aggreagation step
   (minimum 1 hour) for one specific storm track
 MODIFICATION HISTORY:
 Lea Mueller, 20110603
 david.bresch@gmail.com, 20140804, GIT update
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_rainrate_field_animation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_tr_rainsum_field_animation">
<H2>climada_tr_rainsum_field_animation</H2></A>
<font color="blue">function climada_tr_rainsum_field_animation(tc_track, centroids,... </font>
                                           aggregation,check_avi)                                        
 plot animation of rainrate field for a specific historical or
 probabilistic storm
 NAME:
   climada_tc_rainrate_field_animation
 PURPOSE:
   plot animation of rainrate field for a specific historical or
   probabilistic storm, plot is produced every aggregation time step
   (minimum 1 hour or more)
 CALLING SEQUENCE:
   climada_tr_rainrate_field_animation(tc_track       ,...
                                  centroids      ,...
                                  aggregation    ,...
                                  check_printplot)
 EXAMPLE:
   climada_tr_rainrate_field_animation(tc_track_prob(1226), centroids, 1, 6)
 INPUTS:
	tc_track:           just one tc_track, tc_track_prob(1)
   centroids:          centroid mat file
 OPTIONAL INPUT PARAMETERS:
   aggregation:        desired timestep for plots (minimum one plot per
   hour, can be one plot for 6 hours or more)
   check_avi:         if set to 1 will save animation as avi-file
 OUTPUTS:
   plot of rainrate field (footprint) for every aggreagation step
   (minimum 1 hour) for one specific storm track
 MODIFICATION HISTORY:
 Lea Mueller, 20110603
 david.bresch@gmail.com, 20140804, GIT update
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_tr_rainsum_field_animation.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_track_map">
<H2>climada_track_map</H2></A>
<font color="blue">function varargout = climada_track_map(varargin) </font>
 CLIMADA_TRACK_MAP M-file for climada_track_map.fig
      CLIMADA_TRACK_MAP, by itself, creates a new CLIMADA_TRACK_MAP or raises the existing
      singleton*.

      H = CLIMADA_TRACK_MAP returns the handle to a new CLIMADA_TRACK_MAP or the handle to
      the existing singleton*.

      CLIMADA_TRACK_MAP('CALLBACK',hObject,eventData,handles,...) calls the local
      function named CALLBACK in CLIMADA_TRACK_MAP.M with the given input arguments.

      CLIMADA_TRACK_MAP('Property','Value',...) creates a new CLIMADA_TRACK_MAP or raises the
      existing singleton*.  Starting from the left, property value pairs are
      applied to the GUI before climada_track_map_OpeningFcn gets called.  An
      unrecognized property name or invalid value makes property application
      stop.  All inputs are passed to climada_track_map_OpeningFcn via varargin.

      *See GUI Options on GUIDE's Tools menu.  Choose &quotGUI allows only one
      instance to run (singleton)&quot.

 See also: GUIDE, GUIDATA, GUIHANDLES

 Edit the above text to modify the response to help climada_track_map

 Last Modified by GUIDE v2.5 08-Feb-2013 18:15:03
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_track_map.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="climada_ts_hazard_set">
<H2>climada_ts_hazard_set</H2></A>
<font color="blue">function hazard=climada_ts_hazard_set(hazard,hazard_set_file,elevation_data,check_plots) </font>
 climada storm surge TS hazard event set
 NAME:
   climada_ts_hazard_set
 PURPOSE:
   create a storm surge (TS) hazard event, based on an existing
   tropical cyclone (TC) hazard event set

   two steps:
   1) check wether we need to obtain bathymetry (high res, calls etopo_get
   from module etopo) or elevation is provided (see elevation_data)
   2) convert all TC footprints into TS footprints
   see CORE_CONVERSION in code below for the conversion formula

   Note on bathymetry data: see https://github.com/davidnbresch/climada_module_elevation_models 

   see tc_surge_TEST for a testbed for this code

 CALLING SEQUENCE:
   hazard=climada_ts_hazard_set(hazard,hazard_set_file,elevation_data,check_plot)
 EXAMPLE:
   hazard_TC=climada_hazard_load('TCNA_today_small')
   hazard_TS=climada_ts_hazard_set(hazard_TC,'TCNA_today_small_TS')
 INPUTS:
   hazard: an already existing tropical cyclone (TC) hazard event set (a
       TC hazard structure)
       &ampgt prompted for if not given (for .mat file containing a TC hazard event set)
       Note: if hazard.elevation_m exists on input, this elevation
       information is used, hence elevation_data is ignored
       The variable hazard is modified on output (saves a lot of memory).
   hazard_set_file: the name of the newly created storm surge (TS) hazard
       event set (if ='NO_SAVE', the hazard is just returned, not saved)
       &ampgt promted for if not given
 OPTIONAL INPUT PARAMETERS:
   elevation_data: if a scalar, take elevation (or bathymetry) from etopo
       (needs module etopo). If =1, save bathymetry in a .mat file (speeds up
       subsequent calls), if =0 do not save bathymetry (default)
       If elevation_data is a structure with the fields lon(i), lat(i),
       elevation_m(i) and centroid_ID(i), check for centroid IDs being the
       same as in hazard.centroid_ID and then just 'attach' the elevation
       to hazard (i.e. hazard.elevation_m=elevation_data.elevation_m)
       Note: if hazard.elevation_m exists on input, this elevation
       information is used.
   check_plots: =1, do show check plots (only if BATI used), =0: no plots (default)
 OUTPUTS:
   hazard: a hazard event set, see core climada doc
       also written to a .mat file (see hazard_set_file)
       NOTE: for memory allocation reasons, the input hazard is used and
       modified to create the output hazard
 MODIFICATION HISTORY:
 david.bresch@gmail.com, 20140421
 david.bresch@gmail.com, 20141017, module path relative
 david.bresch@gmail.com, 20141026, save_bathymetry_flag
 david.bresch@gmail.com, 20150106, elevation_data
 david.bresch@gmail.com, 20160516, elevation_data single precision allowed (as eg from SRTM)
 david.bresch@gmail.com, 20160525, better error messaging for ETOPO issues
 david.bresch@gmail.com, 20160529, renamed to climada_ts_hazard_set and tc_surge_hazard_create deleted
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/climada_ts_hazard_set.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="figures_for_hazard_advanced_manual">
<H2>figures_for_hazard_advanced_manual</H2></A>
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/figures_for_hazard_advanced_manual.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="haversine">
<H2>haversine</H2></A>
<font color="blue">function [km nmi mi] = haversine(loc1, loc2) </font>
 HAVERSINE     Compute distance between locations using Haversine formula
   KM = HAVERSINE(LOC1, LOC2) returns the distance KM in km between
   locations LOC1 and LOC2 using the Haversine formula.  LOC1 and LOC2 are
   latitude and longitude coordinates that can be expressed as either
   strings representing degrees, minutes, and seconds (suffixed with
   N/S/E/W), or numeric arrays representing decimal degrees (where
   negative indicates West/South).

   [KM, NMI, MI] = HAVERSINE(LOC1, LOC2) returns the computed distance in
   kilometers (KM), nautical miles (NMI), and miles (MI).

   Examples
       haversine('53 08 50N, 001 50 58W', '52 12 16N, 000 08 26E') returns
           170.2547
       haversine([53.1472 -1.8494], '52 12.16N, 000 08.26E') returns
           170.2508
       haversine([53.1472 -1.8494], [52.2044 0.1406]) returns 170.2563

   Inputs
       LOC must be either a string specifying the location in degrees,
       minutes and seconds, or a 2-valued numeric array specifying the
       location in decimal degrees.  If providing a string, the latitude
       and longitude must be separated by a comma.

   Notes
       The Haversine formula is used to calculate the great-circle
       distance between two points, which is the shortest distance over
       the earth's surface.

       This program was created using equations found on the website
       http://www.movable-type.co.uk/scripts/latlong.html
 Created by Josiah Renfree
 May 27, 2010
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/haversine.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="tc_surge_TEST">
<H2>tc_surge_TEST</H2></A>
<font color="blue">function hazard=tc_surge_TEST </font>
 climada
 NAME:
   tc_surge_TEST
 PURPOSE:
   TEST the tropical cyclone (TC) storm surge (TS) hazard creation
   1) get centroids for the test country (eg Bangladesh, see PARAMETERS)
      if they do not exist, try to run GDP_entity in order to create them
   2) create TC wind hazard event set
   call climada_ts_hazard_set in order to
      3) create bathymetry file for region
      4) create TC surge hazard event set
   show the result

   In essence, you define the country and the code checks the generation
   of centroids, TC and TS hazard event sets

   in essence a caller for code climada_ts_hazard_set

   see tc_surge_plot_3d for 3D plots of surge fields
 CALLING SEQUENCE:
   hazard=tc_surge_TEST
 EXAMPLE:
   tc_surge_TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   writes a couple files, such as entity, assets, bathymetry and a
       hazard event set
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140420
 David N. Bresch, david.bresch@gmail.com, 20141017 module independent of location
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/tc_surge_TEST.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="tc_surge_TEST_Netherlands">
<H2>tc_surge_TEST_Netherlands</H2></A>
<font color="blue">function hazard=tc_surge_TEST_Netherlands </font>
 climada
 NAME:
   tc_surge_TEST
 PURPOSE:
   See tc_surge_TEST for the real TEST environment

   A kind of silly test, just to see whether it all works with just one or
   just ten tracks...

   TEST the tropical cyclone (TC) storm surge (TS) raw hazard creation
   1) get centroids for the test country (eg Bangladesh, see PARAMETERS)
      if they do not exist, try to run GDP_entity in order to create them
   2) create TC wind hazard event set
   call climada_ts_hazard_set in order to
      3) create bathymetry file for region
      4) create TC surge hazard event set
   show the result

   In essence, you define the country and the code checks the generation
   of centroids, TC and TS hazard event sets

   in essence a caller for code climada_ts_hazard_set
 CALLING SEQUENCE:
   tc_surge_TEST(force_recalc_ts)
 EXAMPLE:
   tc_surge_TEST
 INPUTS:
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   writes a couple files, such as entity, assets, bathymetry and a
       hazard event set
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140421
 David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/tc_surge_TEST_Netherlands.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>


<A NAME="tc_surge_plot_3d">
<H2>tc_surge_plot_3d</H2></A>
<font color="blue">function tc_surge_plot_3d(hazard,event_i) </font>
 climada
 NAME:
   tc_surge_plot3d
 PURPOSE:
   plot surge hazard as 3D surface, 'overshadowing' terrain
 CALLING SEQUENCE:
   tc_surge_plot3d(hazard,event_i);
 EXAMPLE:
   climada_hazard_plot(climada_hazard_load);
 INPUTS:
   hazard: hazard structure
       consider to use climada_hazard_load, as in the example
   event_i: the i-th event in the hazard event set to be displayed
       if event_i=0, the maximum intensity at each centroid is shown
       if event_i=-i, the i-th 'largest' event (sum of intensities) is shown
           e.g. for event_i=-2, the second largest event is shown
       default=-1 (just to get something on the screen ;-)
 OPTIONAL INPUT PARAMETERS:
 OUTPUTS:
   figure
 MODIFICATION HISTORY:
 David N. Bresch, david.bresch@gmail.com, 20140503
View <A HREF=file:/Users/bresch/Documents/ETH_lecture/climada_GIT/climada_modules/tropical_cyclone/code/tc_surge_plot_3d.m>source</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<PRE>
